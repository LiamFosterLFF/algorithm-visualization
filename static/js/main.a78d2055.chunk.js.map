{"version":3,"sources":["Sorting/BarChart/Bar.js","Sorting/utilities/index.js","Sorting/BarChart/index.js","Sorting/ColorMap/ColorBar.js","Sorting/utilities/colorBarFunctions.js","Sorting/ColorMap/index.js","Sorting/PixelMap/PixelBar.js","Sorting/utilities/pixelMapFunctions.js","Sorting/PixelMap/index.js","Sorting/index.js","Pathfinding/PathfindingFunctions/mazeGeneratingFunctions.js","Pathfinding/PathfindingFunctions/mazeSolvingFunctions.js","Pathfinding/PathfindingFunctions/mazeAnimatingFunctions.js","Pathfinding/index.js","App.js","index.js"],"names":["Bar","height","barStyle","className","style","defaultSort","defaultAnimations","bubbleSort","origArr","arr","animations","n","length","i","j","push","bubbleSortBarChartAnimation","chart","document","getElementsByClassName","barAnimations","forEach","animation","index","bar1","bar2","ht1","ht2","animation1","animate","backgroundColor","duration","delay","animation2","fill","animation3","animation4","selectionSort","minIndex","swap","selectionSortBarChartAnimation","baseChild","checkingChild","minChild","baseHeight","minHeight","insertionSort","insertionSortBarChartAnimation","swapElLt","swapElLtHt","swapElRt","swapElRtHt","mergeSort","origArray","mainArray","auxArray","mergeSortHelper","startIdx","endIdx","midIdx","Math","floor","merge","k","comparison","range","mergeSortBarChartAnimation","compareEl1","compareEl2","swapEl","swapHt","quickSort","array","partition","left","right","pivot","quickSortHelper","quickSortBarChartAnimation","leftEl","rightEl","leftHt","rightHt","barChartRadixSort","countBuckets","max","toString","l","stringNum","d","shift","counter","num","radixSortBarChartAnimation","element","BarChart","sort","useState","bars","barList","bar","barHeight","random","barShuffle","setAnimations","function","sortType","setSortType","animationType","setAnimationType","useEffect","cancelAnimations","buildAnimations","map","cancel","barIndex","key","ButtonGroup","Button","size","onClick","playState","play","playAnimations","pause","pauseAnimations","ColorBar","color","colorBarStyle","colorMapBubbleSort","colorMapBubbleSortAnimation","swapColor1","swapColor2","colorMapSelectionSortAnimation","baseColor","minColor","colorMapInsertionSortAnimation","swapElLtColor","swapElRtColor","colorMapMergeSortAnimation","swapColor","colorMapQuickSortAnimation","leftColor","rightColor","radixSort","colorMapRadixSortAnimation","ColorMap","colorList","hueValue","colorShuffle","colors","runAnimations","colorAnimations","colorIndex","PixelBar","heights","firstSegmentStyle","secondSegmentStyle","thirdSegmentStyle","pixelBarShuffle","pixelBarList","pixBar","pixelBarHeights","shuffle","pixelMapBubbleSortAnimation","compareEl1Bottom","childNodes","compareEl1Top","compareEl2Bottom","compareEl2Top","swapHt1Top","swapHt1Bottom","swapHt2Top","swapHt2Bottom","pixelMapSelectionSort","pixelMapSelectionSortAnimation","baseChildTop","baseChildBottom","minChildTop","minChildBottom","baseTopHeight","baseBottomHeight","minTopHeight","minBottomHeight","pixelMapInsertionSort","pixelMapInsertionSortAnimation","swapElLtTop","swapElLtBottom","swapElLtTopHeight","swapElLtBottomHeight","swapElRtTop","swapElRtBottom","swapElRtTopHeight","swapElRtBottomHeight","pixelMapMergeSort","pixelMapMergeSortAnimation","swapElTop","swapElBottom","swapTopHeight","swapBottomHeight","pixelMapQuickSort","pixelMapQuickSortAnimation","leftElTop","leftElBottom","rightElTop","rightElBottom","leftTopHeight","leftBottomHeight","rightTopHeight","rightBottomHeight","pixelMapRadixSort","numArr","pixelMapRadixSortAnimation","elementTop","elementBottom","heightTop","heightBottom","PixelMap","pixelBars","barHeights","Sorting","setSort","dropdownText","setDropdownText","showDropdown","setShowDropdown","showButton","handleChartTypeClick","handleSortTypeClick","type","charAt","toUpperCase","slice","Nav","Item","Link","to","Fade","in","Dropdown","Toggle","variant","id","Menu","path","clearCanvas","canvas","cellSize","ctx","current","getContext","width","clearRect","cols","rows","clearGrid","row","col","fillCanvas","fillStyle","fillRect","fillGrid","ellersMazeAlgorithm","startNode","prevNode","origMazeGrid","mazeGrid","JSON","parse","stringify","setNoCounter","undefined","placeHolder","setNo","setCounter","extensionNo","extensionCounter","extensionColumn","pathMazeGrid","depthFirstMazeAlgorithm","node","prevRow","prevCol","newAnimations","directionArray","Array","keys","nodeFinder","entrance","exit","nodeAnimations","nodeList","directions","direction","nodeMazeGrid","weightFinder","nodeWeights","nodeDirections","depthFirstSearchSolvingAlgorithm","endNode","newGrid","backtrackingAnimations","mazeEndFound","solvingAnimations","newNode","breadthFirstSearchSolvingAlgorithm","frontierQueue","backtrackDictionary","checking","breadthFirstRecursion","btNode","nodeAndWeightFinder","baseNode","nodeAndWeightList","isANode","dijkstrasSolvingAlgorithm","enterNode","exitNode","heuristic","lowestUnvisitedNode","distances","visitedNodes","min","Infinity","Object","entries","distance","currentDistanceStr","split","parentNodes","unvisitedNodes","currentNode","console","log","Number","currentNodeStr","currentDistance","edge","childNode","childNodeStr","totalWeight","edgeDistance","distanceFromStart","backtrackNode","newNodeStrArray","aStarSolvingAlgorithm","animateMazeDrawing","mazeAnimations","drawPath","drawingAnimations","window","requestAnimationFrame","Pathfinding","useRef","x","y","canvasDimensions","setCanvasDimensions","grid","setGrid","setMazeAnimations","setSolvingAnimations","drawSpeed","mazeGenAlgo","setMazeGenAlgo","mazeSolveAlgo","setMazeSolveAlgo","initialGrid","getBoundingClientRect","initializeGrid","innerHeight","mazeGenerating","setMazeGenerating","algorithm","mazeFinished","start","mazeAlgorithm","generateMaze","setBacktrackingAnimations","mazeSolving","setMazeSolving","defaults","enter","solvingAlgorithm","solveMaze","test","setTimeout","animateMazeSolving","animateMazeSolvingBacktrack","mouseDown","setMouseDown","fillType","setFillType","mazeGenAlgoTitle","setMazeGenAlgoTitle","handleMazeGenSelect","title","mazeSolveAlgoTitle","setMazeSolveAlgoTitle","handleMazeSolveSelect","href","onChange","value","class","e","clientY","clientX","onMouseDown","onMouseUp","onMouseOut","onMouseMove","ref","App","activeKey","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.a78d2055.chunk.js","sourcesContent":["import React from 'react';\n\nconst Bar = ({ height }) => {\n    \n    const barHeightinPercent = height/10;\n    const barStyle = {\n        height: `${barHeightinPercent}%`\n    }\n    \n    return (\n        <div className=\"bar\" style={barStyle}></div>\n    )\n}\n\nexport default Bar;","import $ from 'jquery';\n\n// ***Sort Functions***\n\nexport const defaultSort = () => {\n    return []\n}\n\nexport const defaultAnimations = () => {\n    return []\n}\n\n// Bubble Sort\nexport const bubbleSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n                animations.push([[j, arr[j+1]], [j + 1, arr[j]]])\n            }\n        }\n        \n    }\n    return animations\n}\n\nexport const bubbleSortBarChartAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const bar1 = chart[animation[0][0]];\n        const bar2 = chart[animation[1][0]];\n        const ht1 = `${animation[0][1] / 10}%`\n        const ht2 = `${animation[1][1] / 10}%`\n        \n\n        // Highlight the two elements to be swapped, and swap their heights\n        // Default as paused so they don't start automatically every time\n        const animation1 = bar1.animate([{backgroundColor: 'rgb(51, 226, 217)'}, {backgroundColor: 'red'}], {duration: duration, delay: index * duration});\n        const animation2 = bar1.animate([{ height: ht2 }, { height: ht2 }], { fill: \"forwards\", duration: duration, delay: index * duration });\n        const animation3 = bar2.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration });\n        const animation4 = bar2.animate([{ height: ht1 }, { height: ht1 }], { fill: \"forwards\", duration: duration, delay: index * duration });\n\n        // Save animations for reuse\n        barAnimations.push(\n            animation1, animation2, animation3, animation4\n        )\n    })\n\n    return barAnimations\n}\n\n// Selection Sort \nexport const selectionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        let minIndex = i;\n        for (let j = i; j < n; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j\n            }\n            // Checks if sort has reached the end of Array, if so, records that there will be a swap between i and min\n            let swap = false;\n            if (j === n - 1) {\n                swap = true;\n            }\n            // Push the base Element, the element being checked, the current minimum, and an indication of whether a swap has occurred\n            animations.push([[i, arr[i]], [j, arr[j]], [minIndex, arr[minIndex]], swap])\n        }\n        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n    return animations\n}\n\n\nexport const selectionSortBarChartAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 3;// The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n    \n    animations.forEach((animation, index) => {\n        const baseChild = chart[animation[0][0]];\n        const checkingChild = chart[animation[1][0]];\n        const minChild = chart[animation[2][0]];\n        const baseHeight = `${animation[0][1] / 10}%`\n        const minHeight = `${animation[2][1] / 10}%`\n        const swap = animation[3];\n\n        // Highlight the base of the section being checked, and the current element being compared against the minimum, in bubbleSort, while the min is highlighted in red\n        barAnimations.push(\n            baseChild.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'blue' }], { duration: duration, delay: index * duration }),\n            checkingChild.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'blue' }], { duration: duration, delay: index * duration }),\n            minChild.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration }),\n        )\n        // if the two elements are to be swapped, perform the swap \n        if (swap === true) {\n            barAnimations.push(\n                minChild.animate([{ height: baseHeight }, { height: baseHeight }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChild.animate([{ height: minHeight }, { height: minHeight }], { fill: \"forwards\", duration: duration, delay: index * duration })\n            )\n        }\n    })\n\n    return barAnimations\n}\n\n// Insertion Sort \nexport const insertionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n\n\n    // Move up through the array one at a time, and insert each new element into already sorted numbers to the left in its proper (ascending) position \n    for (let i = 1; i < n; i++) {\n        const key = arr[i]\n        let j = i - 1;\n        while (j >= 0 && arr[j] > arr[j+1]) {\n            animations.push([[j, arr[j]], [j+1, arr[j+1]]]);\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            j = j - 1\n        }\n    }\n    \n    return animations\n}\n\n\nexport const insertionSortBarChartAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElLt = chart[animation[0][0]];\n        const swapElLtHt = `${animation[0][1] / 10}%`;\n        const swapElRt = chart[animation[1][0]];\n        const swapElRtHt = `${animation[1][1] / 10}%`;\n        \n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElRt.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            swapElRt.animate([{ height: swapElLtHt }, { height: swapElLtHt }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElLt.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            swapElLt.animate([{ height: swapElRtHt }, { height: swapElRtHt }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n    \n    return barAnimations\n}\n\n\n// Merge Sort \nexport const mergeSort = (origArray) => {\n    // Two separate arrays, one main one and one to hold swapped values until they can be unswapped. Avoids having to create a buffer array during the sorting process\n    const mainArray = [...origArray];\n    const auxArray = [...mainArray]\n    const n = mainArray.length\n    const animations = [];\n    if (n <= 1) {\n        return mainArray\n    }\n    // Initialize first function call\n    mergeSortHelper(mainArray, 0, n - 1, auxArray, animations);\n\n    return animations;\n}\n\nconst mergeSortHelper = (mainArray, startIdx, endIdx, auxArray, animations) => {\n    // Base case, returns if only one element in array\n    if (startIdx === endIdx) return;\n\n    // Find middle index of array, place to split before coming merge\n    const midIdx = Math.floor((startIdx + endIdx) / 2);\n\n    // recursively call function on each half of the array, to keep splitting until base case of 1 is reached. Also, notice that auxArray and mainArray are swapped from initial function call; it's complicated but basically this allows the aux array and main array to keep switching back and forth and save the values from the previous merge, which means that I don't have to create a temporary array to hold the values\n    mergeSortHelper(auxArray, startIdx, midIdx, mainArray, animations);\n    mergeSortHelper(auxArray, midIdx + 1, endIdx, mainArray, animations);\n\n    // Call the merge function to sort the values and combine back together\n    merge(mainArray, startIdx, midIdx, endIdx, auxArray, animations)\n}\n\nconst merge = (mainArray, startIdx, midIdx, endIdx, auxArray, animations) => {\n    // Copies the values of the aux array into the main array, putting the next lowest value from either array at value k\n    let i = startIdx;\n    let j = midIdx + 1;\n    let k = startIdx;\n    \n    // Pick the lowest value from either array and put it into the main array\n    while (i <= midIdx && j <= endIdx) {\n        const animation = {};\n        animation.comparison = [i, j];\n        animation.range = [startIdx, endIdx]\n        if (auxArray[i] >= auxArray[j]) {\n            animation.swap = [k, auxArray[j]]\n            mainArray[k++] = auxArray[j++]\n        } else {\n            animation.swap = [k, auxArray[i]]\n            mainArray[k++] = auxArray[i++]\n        }\n        animations.push(animation);\n    }\n\n    // While there are still values in only one of the two arrays being merged, copy them in; they are already ordered from previous sorts \n    while (j <= endIdx) {\n        animations.push({\n            comparison: [j, j],\n            swap: [k, auxArray[j]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[j++]\n\n    }\n    while (i <= midIdx) {\n        animations.push({\n            comparison: [i, i],\n            swap: [k, auxArray[i]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[i++]\n    }\n}\n\nexport const mergeSortBarChartAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 30;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const compareEl1 = chart[animation.comparison[0]];\n        const compareEl2 = chart[animation.comparison[1]];\n        const swapEl = chart[animation.swap[0]];\n        const swapHt = `${animation.swap[1] / 10}%`;\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            compareEl1.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            compareEl2.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            swapEl.animate([{ height: swapHt }, { height: swapHt }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n// Quick Sort \nexport const quickSort = (origArray) => {\n    // Copy original array so as not to mutate it \n    const array = [...origArray];\n    const animations = [];\n\n    const quickSortHelper = (array, left, right, animations) => {\n        if (left >= right) return;\n\n        // Find the center index, by sorting from the two ends and so that everything to the left of the pivot is smaller, and everything right is larger\n        const index = partition(array, left, right);\n        \n        // split the array into two halves, and call recursively on the two halves \n        quickSortHelper(array, left, index - 1, animations);\n        quickSortHelper(array, index, right, animations);\n    }\n\n    const partition = (array, left, right) => {\n        // Pivot starts from right end of subarray \n        const pivot = right;\n        right--;\n        // Keep moving pointers towards middle until two pointers cross one another\n        while (left <= right) {\n            // Find a left side element smaller than pivot, and a right side one larger, and switch them \n            while (array[left] < array[pivot]) {\n                left++\n            }\n            while (array[right] > array[pivot]) {\n                right--\n            }\n            if (left <= right) {\n                animations.push([[left, array[left]], [right, array[right]], [pivot, array[pivot]]]);\n                [array[left], array[right]] = [array[right], array[left]]\n                left++\n                right--\n            }\n        }\n        // Move the pivot into the middle \n        animations.push([[left, array[left]], [pivot, array[pivot]], [pivot, array[pivot]]]);\n        [array[left], array[pivot]] = [array[pivot], array[left]]\n        return left;\n    }\n    // Initial function call \n    quickSortHelper(array, 0, array.length - 1)\n\n    return animations\n}\n\nexport const quickSortBarChartAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 30;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        \n        const leftEl = chart[animation[0][0]];\n        const rightEl = chart[animation[1][0]];\n        const pivot = chart[animation[2][0]];\n        const leftHt = `${animation[0][1] / 10}%`;\n        const rightHt = `${animation[1][1] / 10}%`;\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            leftEl.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            leftEl.animate([{ height: leftHt }, { height: rightHt }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightEl.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            rightEl.animate([{ height: rightHt }, { height: leftHt }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            pivot.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n\n// Radix Bar Sort \nexport const barChartRadixSort = (origArr) => {\n    const arr = [...origArr] // Copy original array so as not to mutate it\n    const animations = [];\n\n    // initialize an array subarrays representing numbers 0 through 9, according to their index in parent array \n    const countBuckets = [];\n    for (let i = 0; i < 10; i++) {\n        countBuckets[i] = []\n    }\n\n    let max = 0;\n    // find length of longest number by digits, by converting it to string and measuring its length, then comparing to all other numbers \n    for (let j = 0; j < arr.length; j++) {\n        max = (arr[j].toString().length > max) ? arr[j].toString().length : max;\n    }\n\n    // cycle through array once for each digit in longest number from array \n    for (let l = 0; l < max; l++) {\n\n        while (arr.length) {\n            const stringNum = arr[0].toString()  // Convert front number in array to string\n            const d = stringNum.length - l - 1 // Starting from rightmost digit on first iteration, then moving left on next iteration\n            const digit = (stringNum[d]) ? stringNum[d] : 0 // Select either that digit, or (if too short) use 0\n            countBuckets[digit].push(arr.shift()) // Remove number from array and place into bucket array corresponding to that digit\n        }\n        let counter = 0;\n        for (let i = 0; i < 10; i++) { // Cycle through all 10 counter arrays, from lowest to highest\n            while (countBuckets[i].length) {  // Cycle through counter array until empty\n                const num = countBuckets[i].shift() // Save number in variable, so it can be added both to old array and to animation\n                arr.push(num)\n                animations.push([num, counter])\n                counter++\n            }\n        }\n    }\n    return animations\n\n}\n\nexport const radixSortBarChartAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 30;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const element = chart[animation[1]];\n        const height = `${animation[0] / 10}%`;\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            element.animate([{ backgroundColor: 'red' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration }),\n            element.animate([{ height: height }, { height: height }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n\n\n// PixelMap Animations \n\n// Pixel Map Bubble Sort\nexport const pixelMapBubbleSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j][0] > arr[j + 1][0]) {\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n                animations.push([j, j + 1])\n            }\n        }\n    }\n    return animations\n}\n\n// Bubble Sort Pixel Mpa Animation\nexport const bubbleSortPixelMapAnimation = (animations, speed) => {\n    for (let i = 0; i < animations.length; i++) {\n        const [ind1, ind2] = animations[i]\n        setTimeout(() => {\n            const parent = document.getElementsByClassName('chart');\n            const child1 = parent[0].childNodes[ind1];\n            const child2 = parent[0].childNodes[ind2];\n\n            // child1.style.backgroundColor = \"red\";\n            // child2.style.backgroundColor = \"red\";\n            for (let i = 0; i <= 2; i++) {\n                [child1.childNodes[i].style.height, child2.childNodes[i].style.height] = [child2.childNodes[i].style.height, child1.childNodes[i].style.height]\n\n            }\n            setTimeout(() => {\n                // child1.style.backgroundColor = \"rgb(51, 226, 217)\";\n                // child2.style.backgroundColor = \"rgb(51, 226, 217)\";\n            }, speed);\n        }, i * speed);\n    }\n}\n\n\n// ***Display Functions***\n\n// BarChart\nexport const barShuffle = (bars) => {\n    const barList = [];\n    for (let bar = 0; bar < bars; bar++) {\n        const barHeight = Math.floor(Math.random() * 1000);\n        barList.push(barHeight)\n    }\n    return barList;\n}\n\n\n// ColorMap\n\n\n\n\n\n// PixelMap\nconst shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\n\nexport const pixelBarShuffle = () => {\n    const pixelBarList = [];\n    const height = 200;\n    for (let pixBar = 0; pixBar < height; pixBar++) {\n        const pixelBarHeights = [height - pixBar - 1, 1, pixBar]\n        pixelBarList.push(pixelBarHeights)\n    }\n    return shuffle(pixelBarList)\n}\n\n\n// PixelPainting\n\n\n\n\n\n\n\n\n","import React, { useEffect, useState } from 'react';\nimport { Button, ButtonGroup } from 'react-bootstrap';\n\nimport Bar from './Bar';\n\nimport { barShuffle, defaultSort, defaultAnimations, bubbleSort, bubbleSortBarChartAnimation, selectionSort, selectionSortBarChartAnimation, insertionSort, insertionSortBarChartAnimation, mergeSort, mergeSortBarChartAnimation, quickSort, quickSortBarChartAnimation, barChartRadixSort, radixSortBarChartAnimation } from \"../utilities\";\n\nconst BarChart = ({ sort }) => {\n    const [ bars, ] = useState(barShuffle(100));\n    const [ animations, setAnimations ] = useState([])\n    const [ sortType, setSortType ] = useState({function: defaultSort});\n    const [ animationType, setAnimationType ] = useState({ function: defaultAnimations });\n    \n    useEffect(() => {\n        switch (sort) {\n            case \"bubble\":\n                setSortType({ function: bubbleSort})\n                setAnimationType({ function: bubbleSortBarChartAnimation })\n                break;\n            case \"selection\":\n                setSortType({ function: selectionSort})\n                setAnimationType({ function: selectionSortBarChartAnimation })\n                break;\n            case \"insertion\":\n                setSortType({ function: insertionSort})\n                setAnimationType({ function: insertionSortBarChartAnimation })\n                break;\n            case \"merge\":\n                setSortType({ function: mergeSort})\n                setAnimationType({ function: mergeSortBarChartAnimation })\n                break;\n            case \"quick\":\n                setSortType({ function: quickSort})\n                setAnimationType({ function: quickSortBarChartAnimation })\n                break;\n            case \"radix\":\n                setSortType({ function: barChartRadixSort})\n                setAnimationType({ function: radixSortBarChartAnimation })\n                break;\n            case \"default\":\n                setSortType({ function: defaultSort})\n                setAnimationType({ function: defaultAnimations })\n            break;\n            }\n        }, [sort])\n\n    useEffect(() => {\n        cancelAnimations(animations);\n        buildAnimations(bars);\n    }, [sortType])\n\n    const buildAnimations = (bars) => {\n        const barAnimations = animationType.function(sortType.function(bars));\n        setAnimations(barAnimations);\n    }\n\n    const playAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") {\n                animation.play();\n            }\n        })\n    }\n\n    const pauseAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") {\n                animation.pause();\n            }\n        })\n    }\n\n    const cancelAnimations = animations => {\n        animations.map((animation) => {\n            animation.cancel();\n        })\n    }   \n\n\n\n    return (\n            <div className=\"chart\">\n                {bars.map((barHeight, barIndex) => {\n                    return (\n                        <Bar key={barIndex} height={barHeight} />\n                    )\n                })}\n                <ButtonGroup>\n                    <Button size=\"lg\" onClick={() => playAnimations(animations)}>Play</Button>\n                    <Button size=\"lg\" onClick={() => pauseAnimations(animations)}>Pause</Button>\n                </ButtonGroup>\n            </div>\n           \n            \n    )\n}\n\nexport default BarChart;","import React from 'react';\n\nconst ColorBar = ({ color }) => {\n\n    const colorBarStyle = {\n        backgroundColor: `hsl(${color}, 100%, 50%)`\n    }\n    // console.log(color);\n    \n    return (\n        <div className=\"color-bar\" style={colorBarStyle}></div>\n    )\n}\n\nexport default ColorBar;","// ***Sort Functions***\nexport const defaultSort = () => {\n    return []\n}\n\nexport const defaultAnimations = () => {\n    return []\n}\n\n// Generate Random Colors\nexport const colorShuffle = (bars) => {\n    const colorList = [];\n    for (let color = 0; color < bars; color++) {\n        const hueValue = Math.floor(Math.random() * 359)\n\n        colorList.push(hueValue)\n    }\n    return colorList\n}\n\n\n// ColorMap Bubble Sort\nexport const colorMapBubbleSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n\n    return animations\n}\n\n\n\n// Bubble Sort Color Map Animation\nexport const colorMapBubbleSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = .5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n    animations.forEach((animation, index) => {\n        const compareEl1 = chart[animation[0][0]];\n        const compareEl2 = chart[animation[1][0]];\n        const swapColor1 = animation[0][1];\n        const swapColor2 = animation[1][1];\n\n\n        // Exchange the colors of the two elements being selected\n        barAnimations.push(\n            compareEl1.animate([{ backgroundColor: `hsl(${swapColor2}, 100%, 50%)` }, { backgroundColor: `hsl(${swapColor2}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            compareEl2.animate([{ backgroundColor: `hsl(${swapColor1}, 100%, 50%)` }, { backgroundColor: `hsl(${swapColor1}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n\n        )\n\n    })\n    return barAnimations\n}\n\n// Selection Sort \nexport const selectionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        let minIndex = i;\n        for (let j = i; j < n; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j\n            }\n            // Checks if sort has reached the end of Array, if so, records that there will be a swap between i and min\n            let swap = false;\n            if (j === n - 1) {\n                swap = true;\n            }\n            // Push the base Element, the element being checked, the current minimum, and an indication of whether a swap has occurred\n            animations.push([[i, arr[i]], [j, arr[j]], [minIndex, arr[minIndex]], swap])\n        }\n        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n    return animations\n}\n\n\nexport const colorMapSelectionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = .5;// The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const baseChild = chart[animation[0][0]];\n        const minChild = chart[animation[2][0]];\n        const baseColor = animation[0][1]\n        const minColor = animation[2][1]\n        const swap = animation[3];\n\n        // if the two elements are to be swapped, perform the swap \n        if (swap === true) {\n            barAnimations.push(\n                minChild.animate([{ backgroundColor: `hsl(${baseColor}, 100%, 50%)` }, { backgroundColor: `hsl(${baseColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChild.animate([{ backgroundColor: `hsl(${minColor}, 100%, 50%)` }, { backgroundColor: `hsl(${minColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n            )\n        }\n    })\n\n    return barAnimations\n}\n\n// Insertion Sort \nexport const insertionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n\n\n    // Move up through the array one at a time, and insert each new element into already sorted numbers to the left in its proper (ascending) position \n    for (let i = 1; i < n; i++) {\n        const key = arr[i]\n        let j = i - 1;\n        while (j >= 0 && arr[j] > arr[j + 1]) {\n            animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            j = j - 1\n        }\n    }\n\n    return animations\n}\n\n\nexport const colorMapInsertionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElLt = chart[animation[0][0]];\n        const swapElLtColor = animation[0][1];\n        const swapElRt = chart[animation[1][0]];\n        const swapElRtColor = animation[1][1];\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElLt.animate([{ backgroundColor: `hsl(${swapElRtColor}, 100%, 50%)` }, { backgroundColor: `hsl(${swapElRtColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElRt.animate([{ backgroundColor: `hsl(${swapElLtColor}, 100%, 50%)` }, { backgroundColor: `hsl(${swapElLtColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n\n// Merge Sort \nexport const mergeSort = (origArray) => {\n    // Two separate arrays, one main one and one to hold swapped values until they can be unswapped. Avoids having to create a buffer array during the sorting process\n    const mainArray = [...origArray];\n    const auxArray = [...mainArray]\n    const n = mainArray.length\n    const animations = [];\n    if (n <= 1) {\n        return mainArray\n    }\n    // Initialize first function call\n    mergeSortHelper(mainArray, 0, n - 1, auxArray, animations);\n\n    return animations;\n}\n\nconst mergeSortHelper = (mainArray, startIdx, endIdx, auxArray, animations) => {\n    // Base case, returns if only one element in array\n    if (startIdx === endIdx) return;\n\n    // Find middle index of array, place to split before coming merge\n    const midIdx = Math.floor((startIdx + endIdx) / 2);\n\n    // recursively call function on each half of the array, to keep splitting until base case of 1 is reached. Also, notice that auxArray and mainArray are swapped from initial function call; it's complicated but basically this allows the aux array and main array to keep switching back and forth and save the values from the previous merge, which means that I don't have to create a temporary array to hold the values\n    mergeSortHelper(auxArray, startIdx, midIdx, mainArray, animations);\n    mergeSortHelper(auxArray, midIdx + 1, endIdx, mainArray, animations);\n\n    // Call the merge function to sort the values and combine back together\n    merge(mainArray, startIdx, midIdx, endIdx, auxArray, animations)\n}\n\nconst merge = (mainArray, startIdx, midIdx, endIdx, auxArray, animations) => {\n    // Copies the values of the aux array into the main array, putting the next lowest value from either array at value k\n    let i = startIdx;\n    let j = midIdx + 1;\n    let k = startIdx;\n\n    // Pick the lowest value from either array and put it into the main array\n    while (i <= midIdx && j <= endIdx) {\n        const animation = {};\n        animation.comparison = [i, j];\n        animation.range = [startIdx, endIdx]\n        if (auxArray[i] >= auxArray[j]) {\n            animation.swap = [k, auxArray[j]]\n            mainArray[k++] = auxArray[j++]\n        } else {\n            animation.swap = [k, auxArray[i]]\n            mainArray[k++] = auxArray[i++]\n        }\n        animations.push(animation);\n    }\n\n    // While there are still values in only one of the two arrays being merged, copy them in; they are already ordered from previous sorts \n    while (j <= endIdx) {\n        animations.push({\n            comparison: [j, j],\n            swap: [k, auxArray[j]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[j++]\n\n    }\n    while (i <= midIdx) {\n        animations.push({\n            comparison: [i, i],\n            swap: [k, auxArray[i]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[i++]\n    }\n}\n\nexport const colorMapMergeSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapEl = chart[animation.swap[0]];\n        const swapColor = animation.swap[1];\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapEl.animate([{ backgroundColor: `hsl(${swapColor}, 100%, 50%)` }, { backgroundColor: `hsl(${swapColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n        )\n    })\n\n    return barAnimations\n}\n\n// Quick Sort \nexport const quickSort = (origArray) => {\n    // Copy original array so as not to mutate it \n    const array = [...origArray];\n    const animations = [];\n\n    const quickSortHelper = (array, left, right, animations) => {\n        if (left >= right) return;\n\n        // Find the center index, by sorting from the two ends and so that everything to the left of the pivot is smaller, and everything right is larger\n        const index = partition(array, left, right);\n\n        // split the array into two halves, and call recursively on the two halves \n        quickSortHelper(array, left, index - 1, animations);\n        quickSortHelper(array, index, right, animations);\n    }\n\n    const partition = (array, left, right) => {\n        // Pivot starts from right end of subarray \n        const pivot = right;\n        right--;\n        // Keep moving pointers towards middle until two pointers cross one another\n        while (left <= right) {\n            // Find a left side element smaller than pivot, and a right side one larger, and switch them \n            while (array[left] < array[pivot]) {\n                left++\n            }\n            while (array[right] > array[pivot]) {\n                right--\n            }\n            if (left <= right) {\n                animations.push([[left, array[left]], [right, array[right]], [pivot, array[pivot]]]);\n                [array[left], array[right]] = [array[right], array[left]]\n                left++\n                right--\n            }\n        }\n        // Move the pivot into the middle \n        animations.push([[left, array[left]], [pivot, array[pivot]], [pivot, array[pivot]]]);\n        [array[left], array[pivot]] = [array[pivot], array[left]]\n        return left;\n    }\n    // Initial function call \n    quickSortHelper(array, 0, array.length - 1)\n\n    return animations\n}\n\nexport const colorMapQuickSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const leftEl = chart[animation[0][0]];\n        const rightEl = chart[animation[1][0]];\n        const leftColor = animation[0][1];\n        const rightColor = animation[1][1];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            leftEl.animate([{ backgroundColor: `hsl(${rightColor}, 100%, 50%)` }, { backgroundColor: `hsl(${rightColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightEl.animate([{ backgroundColor: `hsl(${leftColor}, 100%, 50%)` }, { backgroundColor: `hsl(${leftColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n\n// Radix Bar Sort \nexport const radixSort = (origArr) => {\n    const arr = [...origArr] // Copy original array so as not to mutate it\n    const animations = [];\n\n    // initialize an array subarrays representing numbers 0 through 9, according to their index in parent array \n    const countBuckets = [];\n    for (let i = 0; i < 10; i++) {\n        countBuckets[i] = []\n    }\n\n    let max = 0;\n    // find length of longest number by digits, by converting it to string and measuring its length, then comparing to all other numbers \n    for (let j = 0; j < arr.length; j++) {\n        max = (arr[j].toString().length > max) ? arr[j].toString().length : max;\n    }\n\n    // cycle through array once for each digit in longest number from array \n    for (let l = 0; l < max; l++) {\n\n        while (arr.length) {\n            const stringNum = arr[0].toString()  // Convert front number in array to string\n            const d = stringNum.length - l - 1 // Starting from rightmost digit on first iteration, then moving left on next iteration\n            const digit = (stringNum[d]) ? stringNum[d] : 0 // Select either that digit, or (if too short) use 0\n            countBuckets[digit].push(arr.shift()) // Remove number from array and place into bucket array corresponding to that digit\n        }\n        let counter = 0;\n        for (let i = 0; i < 10; i++) { // Cycle through all 10 counter arrays, from lowest to highest\n            while (countBuckets[i].length) {  // Cycle through counter array until empty\n                const num = countBuckets[i].shift() // Save number in variable, so it can be added both to old array and to animation\n                arr.push(num)\n                animations.push([num, counter])\n                counter++\n            }\n        }\n    }\n    return animations\n\n}\n\nexport const colorMapRadixSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const element = chart[animation[1]];\n        const color = animation[0];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            element.animate([{ backgroundColor: `hsl(${color}, 100%, 50%)` }, { backgroundColor: `hsl(${color}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n","import React, { useState, useEffect } from 'react';\nimport { Button, ButtonGroup } from 'react-bootstrap';\n\nimport ColorBar from \"./ColorBar\";\nimport { colorShuffle, defaultSort, defaultAnimations, colorMapBubbleSort, colorMapBubbleSortAnimation, selectionSort, colorMapSelectionSortAnimation, insertionSort, colorMapInsertionSortAnimation, mergeSort, colorMapMergeSortAnimation, quickSort, colorMapQuickSortAnimation, radixSort, colorMapRadixSortAnimation } from '../utilities/colorBarFunctions';\n\nconst ColorMap = ({ sort }) => {\n    const [colors, ] = useState(colorShuffle(200))\n    const [animations, setAnimations] = useState([])\n    const [sortType, setSortType] = useState({ function: defaultSort });\n    const [animationType, setAnimationType] = useState({ function: defaultAnimations });\n\n    useEffect(() => {\n        switch (sort) {\n            case \"bubble\":\n                setSortType({ function: colorMapBubbleSort })\n                setAnimationType({ function: colorMapBubbleSortAnimation })\n                break;\n            case \"selection\":\n                setSortType({ function: selectionSort })\n                setAnimationType({ function: colorMapSelectionSortAnimation })\n                break;\n            case \"insertion\":\n                setSortType({ function: insertionSort })\n                setAnimationType({ function: colorMapInsertionSortAnimation })\n                break;\n            case \"merge\":\n                setSortType({ function: mergeSort })\n                setAnimationType({ function: colorMapMergeSortAnimation })\n                break;\n            case \"quick\":\n                setSortType({ function: quickSort })\n                setAnimationType({ function: colorMapQuickSortAnimation })\n                break;\n            case \"radix\":\n                setSortType({ function: radixSort })\n                setAnimationType({ function: colorMapRadixSortAnimation })\n                break;\n        }\n    }, [sort])\n\n    useEffect(() => {\n        cancelAnimations(animations)\n        runAnimations(colors)\n    }, [sortType])\n\n    const runAnimations = (colors) => {\n        const colorAnimations = animationType.function(sortType.function(colors))\n        setAnimations(colorAnimations)\n    }\n\n    const playAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") {\n                animation.play()\n            }\n        })\n    }\n\n    const pauseAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") {\n                animation.pause();\n            }\n        })\n    }\n\n    const cancelAnimations = animations => {\n        animations.map((animation) => {\n            animation.cancel()\n        })\n    }   \n    \n\n    return (\n        <div className=\"color-map\">\n            <div className=\"chart\">\n                {colors.map((color, colorIndex) => {\n                    return (\n                        <ColorBar key={colorIndex} color={color} />\n                    )\n                })}\n                <ButtonGroup>\n                    <Button onClick={() => playAnimations(animations)}>Play</Button>\n                    <Button onClick={() => pauseAnimations(animations)}>Pause</Button>\n                </ButtonGroup>\n            </div>\n        </div>\n    )\n}\n\nexport default ColorMap;","import React from 'react';\n\nconst PixelBar = ({ heights }) => {\n\n    const firstSegmentStyle = {\n        height: `${3*heights[0]}%`,\n        backgroundColor: '#000'\n    }\n    const secondSegmentStyle = {\n        height: `${3*heights[1]}%`,\n        backgroundColor: '#fff)'\n    }\n    const thirdSegmentStyle = {\n        height: `${3*heights[2]}%`,\n        backgroundColor: '#000'\n    }\n\n    \n    return (\n        <div className=\"pixel-bar\">\n            <div style={firstSegmentStyle}></div>\n            <div style={secondSegmentStyle}></div>\n            <div style={thirdSegmentStyle}></div>\n        </div>\n    )\n}\n\nexport default PixelBar;","// Sorting Functions\n\nexport const defaultSort = () => {\n    return []\n}\n\nexport const defaultAnimations = () => {\n    return []\n}\n\n// Generate Random Pixel Bars\nconst shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\nexport const pixelBarShuffle = () => {\n    const height = 100;\n    const pixelBarList = [];\n    for (let pixBar = 0; pixBar < height; pixBar++) {\n        const pixelBarHeights = [pixBar, 1, height - pixBar - 1]\n        pixelBarList.push(pixelBarHeights)\n    }\n    return shuffle(pixelBarList)\n}\n\n\n// ColorMap Bubble Sort\nexport const bubbleSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j][0] > arr[j + 1][0]) {\n                animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n    \n    return animations\n}\n\n\n\n// Bubble Sort Color Map Animation\nexport const pixelMapBubbleSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = .5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n    animations.forEach((animation, index) => {\n        const compareEl1Bottom = chart[animation[0][0]].childNodes[0];\n        const compareEl1Top = chart[animation[0][0]].childNodes[2];\n        const compareEl2Bottom = chart[animation[1][0]].childNodes[0];\n        const compareEl2Top = chart[animation[1][0]].childNodes[2];\n\n        const swapHt1Top = animation[0][1][0];\n        const swapHt1Bottom = animation[0][1][2];\n\n        const swapHt2Top = animation[1][1][0];\n        const swapHt2Bottom = animation[1][1][2];\n\n        \n\n        // Exchange the colors of the two elements being selected\n        barAnimations.push(\n            compareEl1Bottom.animate([{ height: `${3 * swapHt2Bottom}%` }, { height: `${3 * swapHt2Bottom}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            compareEl1Top.animate([{ height: `${3 * swapHt2Top}%` }, { height: `${3 * swapHt2Top}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }), \n            compareEl2Bottom.animate([{ height: `${3 * swapHt1Bottom}%` }, { height: `${3 * swapHt1Bottom}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            compareEl2Top.animate([{ height: `${3 * swapHt1Top}%` }, { height: `${3 * swapHt1Top}%` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n\n    })\n    return barAnimations\n}\n\n// Selection Sort \nexport const pixelMapSelectionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        let minIndex = i;\n        for (let j = i; j < n; j++) {\n            if (arr[j][0] < arr[minIndex][0]) {\n                minIndex = j\n            }\n            // Checks if sort has reached the end of Array, if so, records that there will be a swap between i and min\n            let swap = false;\n            if (j === n - 1) {\n                swap = true;\n            }\n            // Push the base Element, the element being checked, the current minimum, and an indication of whether a swap has occurred\n            animations.push([[i, arr[i]], [j, arr[j]], [minIndex, arr[minIndex]], swap])\n        }\n        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n    \n    return animations\n}\n\n\nexport const pixelMapSelectionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = .5;// The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const baseChildTop = chart[animation[0][0]].childNodes[0];\n        const baseChildBottom = chart[animation[0][0]].childNodes[2];\n        const minChildTop = chart[animation[2][0]].childNodes[0];\n        const minChildBottom = chart[animation[2][0]].childNodes[2];\n        const baseTopHeight = animation[0][1][2];\n        const baseBottomHeight = animation[0][1][0];\n        const minTopHeight = animation[2][1][2];\n        const minBottomHeight = animation[2][1][0];\n        const swap = animation[3];\n        \n        // if the two elements are to be swapped, perform the swap \n        if (swap === true) {\n            barAnimations.push(\n                minChildTop.animate([{ height: `${3 * baseTopHeight}%` }, { height: `${3 * baseTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChildTop.animate([{ height: `${3 * minTopHeight}%` }, { height: `${3 * minTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                minChildBottom.animate([{ height: `${3 * baseBottomHeight}%` }, { height: `${3 * baseBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChildBottom.animate([{ height: `${3 * minBottomHeight}%` }, { height: `${3 * minBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n            )\n        }\n    })\n\n    return barAnimations\n}\n\n// Insertion Sort \nexport const pixelMapInsertionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n\n\n    // Move up through the array one at a time, and insert each new element into already sorted numbers to the left in its proper (ascending) position \n    for (let i = 1; i < n; i++) {\n        const key = arr[i]\n        let j = i - 1;\n        while (j >= 0 && arr[j][0] > arr[j + 1][0]) {\n            animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            j = j - 1\n        }\n    }\n\n    return animations\n}\n\n\nexport const pixelMapInsertionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElLtTop = chart[animation[0][0]].childNodes[0];\n        const swapElLtBottom = chart[animation[0][0]].childNodes[2];\n        const swapElLtTopHeight = animation[0][1][2];\n        const swapElLtBottomHeight = animation[0][1][0];\n        const swapElRtTop = chart[animation[1][0]].childNodes[0];\n        const swapElRtBottom = chart[animation[1][0]].childNodes[2];\n        const swapElRtTopHeight = animation[1][1][2];\n        const swapElRtBottomHeight = animation[1][1][0];\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElLtTop.animate([{ height: `${3 * swapElRtTopHeight}%` }, { height: `${3 * swapElRtTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElLtBottom.animate([{ height: `${3 * swapElRtBottomHeight}%` }, { height: `${3 * swapElRtBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElRtTop.animate([{ height: `${3 * swapElLtTopHeight}%` }, { height: `${3 * swapElLtTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElRtBottom.animate([{ height: `${3 * swapElLtBottomHeight}%` }, { height: `${3 * swapElLtBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n        )\n    })\n\n    return barAnimations\n}\n\n\n// Merge Sort \nexport const pixelMapMergeSort = (origArray) => {\n    // Two separate arrays, one main one and one to hold swapped values until they can be unswapped. Avoids having to create a buffer array during the sorting process\n    const mainArray = [...origArray];\n    const auxArray = [...mainArray]\n    const n = mainArray.length\n    const animations = [];\n    if (n <= 1) {\n        return mainArray\n    }\n    // Initialize first function call\n    mergeSortHelper(mainArray, 0, n - 1, auxArray, animations);\n    \n    return animations;\n}\n\nconst mergeSortHelper = (mainArray, startIdx, endIdx, auxArray, animations) => {\n    // Base case, returns if only one element in array\n    if (startIdx === endIdx) return;\n\n    // Find middle index of array, place to split before coming merge\n    const midIdx = Math.floor((startIdx + endIdx) / 2);\n\n    // recursively call function on each half of the array, to keep splitting until base case of 1 is reached. Also, notice that auxArray and mainArray are swapped from initial function call; it's complicated but basically this allows the aux array and main array to keep switching back and forth and save the values from the previous merge, which means that I don't have to create a temporary array to hold the values\n    mergeSortHelper(auxArray, startIdx, midIdx, mainArray, animations);\n    mergeSortHelper(auxArray, midIdx + 1, endIdx, mainArray, animations);\n\n    // Call the merge function to sort the values and combine back together\n    merge(mainArray, startIdx, midIdx, endIdx, auxArray, animations)\n}\n\nconst merge = (mainArray, startIdx, midIdx, endIdx, auxArray, animations) => {\n    // Copies the values of the aux array into the main array, putting the next lowest value from either array at value k\n    let i = startIdx;\n    let j = midIdx + 1;\n    let k = startIdx;\n\n    // Pick the lowest value from either array and put it into the main array\n    while (i <= midIdx && j <= endIdx) {\n        const animation = {};\n        animation.comparison = [i, j];\n        animation.range = [startIdx, endIdx]\n        if (auxArray[i][0] >= auxArray[j][0]) {\n            animation.swap = [k, auxArray[j]]\n            mainArray[k++] = auxArray[j++]\n        } else {\n            animation.swap = [k, auxArray[i]]\n            mainArray[k++] = auxArray[i++]\n        }\n        animations.push(animation);\n    }\n\n    // While there are still values in only one of the two arrays being merged, copy them in; they are already ordered from previous sorts \n    while (j <= endIdx) {\n        animations.push({\n            comparison: [j, j],\n            swap: [k, auxArray[j]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[j++]\n\n    }\n    while (i <= midIdx) {\n        animations.push({\n            comparison: [i, i],\n            swap: [k, auxArray[i]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[i++]\n    }\n}\n\nexport const pixelMapMergeSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElTop = chart[animation.swap[0]].childNodes[0];\n        const swapElBottom = chart[animation.swap[0]].childNodes[2];\n\n        const swapTopHeight = animation.swap[1][2];\n        const swapBottomHeight = animation.swap[1][0];\n\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElTop.animate([{ height: `${3 * swapTopHeight}%` }, { height: `${3 * swapTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElBottom.animate([{ height: `${3 * swapBottomHeight}%` }, { height: `${3 * swapBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n        )\n    })\n\n    return barAnimations\n}\n\n// Quick Sort \nexport const pixelMapQuickSort = (origArray) => {\n    // Copy original array so as not to mutate it \n    const array = [...origArray];\n    const animations = [];\n\n    const quickSortHelper = (array, left, right, animations) => {\n        if (left >= right) return;\n\n        // Find the center index, by sorting from the two ends and so that everything to the left of the pivot is smaller, and everything right is larger\n        const index = partition(array, left, right);\n\n        // split the array into two halves, and call recursively on the two halves \n        quickSortHelper(array, left, index - 1, animations);\n        quickSortHelper(array, index, right, animations);\n    }\n\n    const partition = (array, left, right) => {\n        // Pivot starts from right end of subarray \n        const pivot = right;\n        right--;\n        // Keep moving pointers towards middle until two pointers cross one another\n        while (left <= right) {\n            // Find a left side element smaller than pivot, and a right side one larger, and switch them \n            while (array[left][2] < array[pivot][2]) {\n                left++\n            }\n            while (array[right][2] > array[pivot][2]) {\n                right--\n            }\n            if (left <= right) {\n                animations.push([[left, array[left]], [right, array[right]], [pivot, array[pivot]]]);\n                [array[left], array[right]] = [array[right], array[left]]\n                left++\n                right--\n            }\n        }\n        // Move the pivot into the middle \n        animations.push([[left, array[left]], [pivot, array[pivot]], [pivot, array[pivot]]]);\n        [array[left], array[pivot]] = [array[pivot], array[left]]\n        return left;\n    }\n    // Initial function call \n    quickSortHelper(array, 0, array.length - 1)\n    \n    return animations\n}\n\nexport const pixelMapQuickSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const leftElTop = chart[animation[0][0]].childNodes[0];\n        const leftElBottom = chart[animation[0][0]].childNodes[2];\n        const rightElTop = chart[animation[1][0]].childNodes[0];\n        const rightElBottom = chart[animation[1][0]].childNodes[2];\n        const leftTopHeight = animation[0][1][0];\n        const leftBottomHeight = animation[0][1][2];\n        const rightTopHeight = animation[1][1][0];\n        const rightBottomHeight = animation[1][1][2];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            leftElTop.animate([{ height: `${3 * rightTopHeight}%` }, { height: `${3 * rightTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            leftElBottom.animate([{ height: `${3 * rightBottomHeight}%` }, { height: `${3 * rightBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightElTop.animate([{ height: `${3 * leftTopHeight}%` }, { height: `${3 * leftTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightElBottom.animate([{ height: `${3 * leftBottomHeight}%` }, { height: `${3 * leftBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n\n// Radix Bar Sort \nexport const pixelMapRadixSort = (origArr) => {\n    const arr = [...origArr] // Copy original array so as not to mutate it\n    const animations = [];\n\n    // initialize an array subarrays representing numbers 0 through 9, according to their index in parent array \n    const countBuckets = [];\n    for (let i = 0; i < 10; i++) {\n        countBuckets[i] = []\n    }\n\n    let max = 0;\n    // find length of longest number by digits, by converting it to string and measuring its length, then comparing to all other numbers \n    for (let j = 0; j < arr.length; j++) {\n        max = (arr[j].toString().length > max) ? arr[j].toString().length : max;\n    }\n\n    // cycle through array once for each digit in longest number from array \n    for (let l = 0; l < max; l++) {\n\n        while (arr.length) {\n            const stringNum = arr[0][0].toString()  // Convert front number in array to string\n            const d = stringNum.length - l - 1 // Starting from rightmost digit on first iteration, then moving left on next iteration\n            const digit = (stringNum[d]) ? stringNum[d] : 0 // Select either that digit, or (if too short) use 0\n            countBuckets[digit].push(arr.shift()) // Remove number from array and place into bucket array corresponding to that digit\n        }\n        let counter = 0;\n        for (let i = 0; i < 10; i++) { // Cycle through all 10 counter arrays, from lowest to highest\n            while (countBuckets[i].length) {  // Cycle through counter array until empty\n                const numArr = countBuckets[i].shift() // Save number in variable, so it can be added both to old array and to animation\n                arr.push(numArr)\n                animations.push([numArr, counter])\n                counter++\n            }\n        }\n    }\n    \n    return animations\n\n}\n\nexport const pixelMapRadixSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const elementTop = chart[animation[1]].childNodes[0];\n        const elementBottom = chart[animation[1]].childNodes[2];\n        const heightTop = animation[0][2];\n        const heightBottom = animation[0][0];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            elementTop.animate([{ height: `${3 * heightTop}%` }, { height: `${3 * heightTop}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            elementBottom.animate([{ height: `${3 * heightBottom}%` }, { height: `${3 * heightBottom}%` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n","import React, { useState, useEffect } from 'react';\nimport {Button, ButtonGroup} from 'react-bootstrap';\n\nimport PixelBar from \"./PixelBar\";\nimport { pixelBarShuffle, defaultSort, defaultAnimations, bubbleSort, pixelMapBubbleSortAnimation, pixelMapSelectionSort, pixelMapSelectionSortAnimation, pixelMapInsertionSort, pixelMapInsertionSortAnimation, pixelMapMergeSort, pixelMapMergeSortAnimation, pixelMapQuickSort, pixelMapQuickSortAnimation, pixelMapRadixSort, pixelMapRadixSortAnimation } from \"../utilities/pixelMapFunctions\";\n\nconst PixelMap = ({ sort }) => {\n    const [pixelBars, ] = useState(pixelBarShuffle())\n    const [animations, setAnimations] = useState([])\n    const [sortType, setSortType] = useState({ function: defaultSort });\n    const [animationType, setAnimationType] = useState({ function: defaultAnimations });\n    \n    useEffect(() => {\n        switch (sort) {\n            case \"bubble\":\n                setSortType({ function: bubbleSort })\n                setAnimationType({ function: pixelMapBubbleSortAnimation })\n                break;\n            case \"selection\":\n                setSortType({ function: pixelMapSelectionSort })\n                setAnimationType({ function: pixelMapSelectionSortAnimation })\n                break;\n            case \"insertion\":\n                setSortType({ function: pixelMapInsertionSort })\n                setAnimationType({ function: pixelMapInsertionSortAnimation })\n                break;\n            case \"merge\":\n                setSortType({ function: pixelMapMergeSort })\n                setAnimationType({ function: pixelMapMergeSortAnimation })\n                break;\n            case \"quick\":\n                setSortType({ function: pixelMapQuickSort })\n                setAnimationType({ function: pixelMapQuickSortAnimation })\n                break;\n            case \"radix\":\n                setSortType({ function: pixelMapRadixSort })\n                setAnimationType({ function: pixelMapRadixSortAnimation })\n                break;\n        }\n    }, [sort])\n\n    useEffect(() => {\n        cancelAnimations(animations)\n        runAnimations(pixelBars)\n        \n    }, [sortType])\n\n\n\n\n    const runAnimations = (pixelBars) => {\n        const barAnimations = animationType.function(sortType.function(pixelBars))\n        setAnimations(barAnimations)\n    }\n\n    const playAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") {\n                animation.play()\n            }\n        })\n    }\n\n    const pauseAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") {\n                animation.pause();\n            }\n        })\n    }\n\n    const cancelAnimations = animations => {\n        animations.map((animation) => {\n            animation.cancel()\n        })\n    }   \n    \n\n    return (\n        <div>\n            <ButtonGroup>\n                <Button onClick={() => playAnimations(animations)}>Play</Button>\n                <Button onClick={() => pauseAnimations(animations)}>Pause</Button>\n            </ButtonGroup>\n            <div className=\"pixel-map\">\n                <div className=\"chart\">\n                    {pixelBars.map((barHeights, barIndex) => {\n                        return (\n                            <PixelBar key={barIndex} heights={barHeights} />\n                        )\n                    })}\n                </div>\n            </div>\n    </div>\n    )\n}\n\nexport default PixelMap;","import React, {useState} from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link } from 'react-router-dom';\nimport { Fade, Nav, Dropdown, ButtonGroup, Button } from 'react-bootstrap';\n\nimport ButtonWrapper from './ButtonWrapper';\nimport BarChart from './BarChart';\nimport ColorMap from './ColorMap';\nimport PixelMap from './PixelMap';\nimport { defaultAnimations } from './utilities';\n// import PixelPainting from './PixelPainting';\n\nconst Sorting = () => {  \n    \n    const [ sort, setSort ] = useState(\"default\");\n    const [ dropdownText, setDropdownText ] = useState(\"Choose Sorting Algorithm\");\n    const [ showDropdown, setShowDropdown ] = useState(false);\n    const [ showButton, setShowButton ] = useState(false);\n\n    const handleChartTypeClick = () => {\n        setSort(\"default\");\n        setDropdownText(\"Choose Sorting Algorithm\");\n        setShowDropdown(true);\n    }\n\n    const handleSortTypeClick = (type) => {\n        setSort(type);\n        setShowDropdown(true);\n        setDropdownText(`${type.charAt(0).toUpperCase() + type.slice(1)} Sort Algorithm`);\n    }\n\n\n\n\n    const FadeVariety = () => {\n        if (showDropdown) {\n            return (\n                <Dropdown>\n                    <Dropdown.Toggle variant=\"success\" id=\"dropdown-basic\">\n                        {dropdownText}\n                    </Dropdown.Toggle>\n\n                    <Dropdown.Menu>\n                        <Dropdown.Item onClick={() => handleSortTypeClick(\"bubble\")}>Bubble</Dropdown.Item>\n                        <Dropdown.Item onClick={() => handleSortTypeClick(\"selection\")}>Selection</Dropdown.Item>\n                        <Dropdown.Item onClick={() => handleSortTypeClick(\"insertion\")}>Insertion</Dropdown.Item>\n                        <Dropdown.Item onClick={() => handleSortTypeClick(\"merge\")}>Merge</Dropdown.Item>\n                        <Dropdown.Item onClick={() => handleSortTypeClick(\"quick\")}>Quick</Dropdown.Item>\n                        <Dropdown.Item onClick={() => handleSortTypeClick(\"radix\")}>Radix</Dropdown.Item>\n                    </Dropdown.Menu>\n                    \n                </Dropdown>\n            )\n        } else {\n            return <div></div>\n        }\n    }\n\n\n\n    return (\n\n        <Router>\n            <Nav className=\"nav-bar\">\n                <Nav.Item>\n                    <Nav.Link>\n                        <Link to=\"/barchart\" onClick={() => handleChartTypeClick()}>Bar Chart</Link>\n                    </Nav.Link>\n                </Nav.Item>\n\n                <Nav.Item>\n                    <Nav.Link>\n                        <Link to=\"/colormap\" onClick={() => handleChartTypeClick()}>Color Map</Link>\n                    </Nav.Link>\n                </Nav.Item>\n\n                <Nav.Item>\n                    <Nav.Link>\n                        <Link to=\"/pixelmap\" onClick={() => handleChartTypeClick()}>Pixel Map</Link>\n                    </Nav.Link>\n                </Nav.Item>\n\n                <Fade in={showDropdown}>\n                    <FadeVariety/>\n                </Fade>\n            </Nav>\n\n            <Switch>\n                <Route path=\"/barchart\">\n                    <BarChart sort={sort} showButton={showButton}/>\n                </Route>\n                <Route path=\"/colormap\">\n                    <ColorMap sort={sort} />\n                </Route>\n                <Route path=\"/pixelmap\">\n                    <PixelMap sort={sort} />\n                </Route>\n            </Switch>\n        </Router>\n\n    )\n}\n\nexport default Sorting;\n\n// // All\n// Top bar? What does it say\n// // Sorting\n// Buttons ugly, use bootstrap\n// Reset should be a totally different layout each timers\n// // Maze\n// Mazes should generate when button press\n// Mazes should solve when button press\n// Black board should generate on load\n// Solving again should reset to uncolored maze\n// Can't adjust maze size\n// Draw maze more slowly? Maybe a bar\n// Bars need to be labelled\n// Need a back button\n// Buttons ugly, use bootstrap\n// Center the thing on the page","// Draw initial Grid\nexport const initializeGrid = (canvas, cellSize, canvasDimensions) => {\n\n    const ctx = canvas.current.getContext('2d');\n    const [width, height] = [canvasDimensions.width, canvasDimensions.height]\n\n    // Initialize Background\n    ctx.canvas.width = width;\n    ctx.canvas.height = height;\n\n    // Initialize Grid as Clear\n    const initialGrid = clearCanvas(canvas, cellSize)\n    \n    // Find x and y coordinates of canvas\n    const [xCoordinate, yCoordinate] = [canvas.current.getBoundingClientRect().x, canvas.current.getBoundingClientRect().y]\n\n    return [initialGrid, xCoordinate, yCoordinate]\n\n\n\n}\n\nexport const clearCanvas = (canvas, cellSize) => {\n    const ctx = canvas.current.getContext('2d');\n    const [width, height] = [ctx.canvas.width, ctx.canvas.height]\n    \n    // Clear Background\n    ctx.clearRect(0, 0, width, height);\n\n    // Construct Grid of Cells\n    const [cols, rows] = [width / cellSize, height / cellSize];\n    \n    const clearGrid = [];\n    // Builds a rows*cols nested array full of walls\n    for (let row = 0; row < rows; row++) {\n        clearGrid.push([])\n        for (let col = 0; col < cols; col++) {\n            clearGrid[row].push(\"path\")\n        }\n    }\n    return clearGrid\n}\n\nexport const fillCanvas = (canvas, cellSize) => {\n    const ctx = canvas.current.getContext('2d');\n    const [width, height] = [ctx.canvas.width, ctx.canvas.height]\n\n    // Fill Background\n    ctx.fillStyle = \"#444\";\n    ctx.fillRect(0, 0, width, height);\n\n    // Construct Grid of Cells\n    const [cols, rows] = [width / cellSize, height / cellSize]\n    const fillGrid = [];\n    // Builds a rows*cols nested array full of walls\n    for (let row = 0; row < rows; row++) {\n        fillGrid.push([])\n        for (let col = 0; col < cols; col++) {\n            fillGrid[row].push(\"wall\")\n        }\n    }\n    return fillGrid\n}\n\n// Generate initial maze\nexport const generateMaze = (grid, algorithm) => {\n\n    // Number of total columns and total rows\n\n    let mazeGrid = JSON.parse(JSON.stringify(grid)); // Deep copy grid so as not to mutate\n    const [rows, cols] = [mazeGrid.length, mazeGrid[0].length]\n\n    // Animate drawing the entrance and exit\n    const [entrance, exit, start] = [[0, 1], [mazeGrid.length - 1, mazeGrid[0].length - 2], [1, 1]]\n    let drawingAnimations = [entrance, exit];\n\n    // Add entrance and exit to state, and to grid\n    mazeGrid[entrance[0]][entrance[1]] = \"path\";\n    mazeGrid[exit[0]][exit[1]] = \"path\";\n\n    // Calls with start as current and previous node; this is to allow for previous node to be used in recursive call\n    let mazeFinished;\n\n    let mazeAlgorithm = ellersMazeAlgorithm\n    switch (algorithm) {\n        case \"eller's\":\n            mazeAlgorithm = ellersMazeAlgorithm\n            break;\n        case \"depthFirst\":\n            mazeAlgorithm = depthFirstMazeAlgorithm\n            break;\n    }\n\n    [mazeGrid, drawingAnimations, mazeFinished] = mazeAlgorithm(start, start, mazeGrid, drawingAnimations)\n    \n    // Add a set number of loops to the maze\n    // const loops = 200;\n    // [mazeGrid, drawingAnimations] = loopMaker(mazeGrid, drawingAnimations, loops);\n\n    const [nodeAnimations, trash] = nodeFinder(mazeGrid, entrance, exit)\n\n    const mazeAnimations = { drawingAnimations: drawingAnimations, nodeAnimations: nodeAnimations }\n\n    return [mazeGrid, mazeAnimations, mazeFinished]\n}\n\nconst shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\nconst ellersMazeAlgorithm = (startNode, prevNode, origMazeGrid, animations) => {\n\n    const mazeGrid = JSON.parse(JSON.stringify(origMazeGrid)) // Deep copy so as not to mutate original array\n\n    let setNoCounter = 1; // To keep track of set names, so there's no repeats\n    for (let i = 1; i < mazeGrid[1].length - 1; i += 2) {\n        mazeGrid[1][i] = setNoCounter; // Initialize the cells of the first row to each exist in their own set.\n        animations.push([1,i])\n        setNoCounter++;\n    }\n\n    for (let j = 1; j < mazeGrid.length - 2; j += 2) {  // Repeat until the last row is reached\n        \n        for (let i = 1; i < mazeGrid[j].length - 1; i += 2) {// Randomly join adjacent cells, but only if they are not in the same set.\n            if (mazeGrid[j][i+2] !== undefined && mazeGrid[j][i] !== mazeGrid[j][i + 2]) {\n                if (Math.random() < .5) { // Some of the cells joined together, so left side and right of wall must match\n                    mazeGrid[j][i + 1] = mazeGrid[j][i];\n                    mazeGrid[j][i + 2] = mazeGrid[j][i];\n                    animations.push([j, i+1])\n                }\n            }\n        }\n        \n        let placeHolder = 1;\n        while (placeHolder < mazeGrid[j].length ) {// For each set, randomly create vertical connections downward to the next row\n            \n            const setNo = mazeGrid[j][placeHolder] // Number stored in grid for current set\n            let setCounter = 1;\n            while (mazeGrid[j][placeHolder + setCounter * 2] === setNo) { // Counts how many in a row have the same setNo\n                setCounter += 1\n            }\n            \n            // For each set, randomly create a random number (1+) of vertical connections downward to the next row.\n            const extensionNo = 1 + Math.floor(Math.random() * setCounter) * .5;\n            let extensionCounter = 0;\n            while (extensionCounter < extensionNo) {  // Keeps cycling until correct number of columns are created\n                const extensionColumn = Math.floor(Math.random() * setCounter) * 2;\n                if (mazeGrid[j + 1][placeHolder + extensionColumn] === \"wall\") {\n                    mazeGrid[j + 1][placeHolder + extensionColumn] = setNo;\n                    animations.push([j + 1, placeHolder + extensionColumn]);\n                    mazeGrid[j + 2][placeHolder + extensionColumn] = setNo;\n                    animations.push([j + 2, placeHolder + extensionColumn]);\n                    extensionCounter ++\n                }\n            } // Consecutive columns are linked together in next section\n\n            \n\n            placeHolder += setCounter*2; // Moves to the next set\n        }\n        \n        for (let l = 1; l < mazeGrid[j].length - 1; l += 2) { \n            if (mazeGrid[j + 2][l] === \"wall\") {// Flesh out the next row by putting any remaining cells into their own sets.\n                mazeGrid[j + 2][l] = setNoCounter;\n                animations.push([j + 2, l])\n                setNoCounter++\n            } \n        }\n    }\n    for (let i = 1; i < mazeGrid[0].length - 2; i+=2) { //For the last row, join all adjacent cells that do not share a set\n        if (mazeGrid[mazeGrid.length - 2][i] !== mazeGrid[mazeGrid.length - 2][i + 2]) {\n            mazeGrid[mazeGrid.length - 2][i + 1] = mazeGrid[mazeGrid.length - 2][i];\n            animations.push([mazeGrid.length - 2, i + 1]);\n            mazeGrid[mazeGrid.length - 2][i + 2] = mazeGrid[mazeGrid.length - 2][i];\n            animations.push([mazeGrid.length - 2, i + 2]);\n        }\n    }\n\n    const pathMazeGrid = []\n    for (let i = 0; i < mazeGrid.length; i++) {\n        const row = [];\n        for (let j = 0; j < mazeGrid[i].length; j++) {\n            if (mazeGrid[i][j] !== \"wall\") {\n                row.push(\"path\")\n            } else {\n                row.push(\"wall\")\n            }\n        }\n        pathMazeGrid.push(row)\n    }\n    \n\n    \n    return [pathMazeGrid, animations, true]\n    \n}\n\nconst depthFirstMazeAlgorithm = (startNode, prevNode, mazeGrid, animations) => {\n    // Draws maze using recursive depth-first algorithm\n    const node = startNode;\n\n    const [row, col] = node;\n\n    mazeGrid[row][col] = \"path\";\n    const [prevRow, prevCol] = prevNode\n    mazeGrid[prevRow][prevCol] = \"path\";\n    let deadEnd = false;\n\n    let newAnimations = [...animations, prevNode, node] // Add current node to path animation\n    const directionArray = shuffle([...Array(4).keys()]); // Create a random array of directions to choose from\n    for (let i = 0; i < 4; i++) {  // Choose the next direction to go in, or return dead end\n        const direction = directionArray[i]\n        switch (direction) {\n            case 0: // Up: if potential path column above is not edge or filled\n                if (((row - 2) >= 0) && (mazeGrid[row - 2][col] === \"wall\")) {\n                    const [midNode, newNode] = [[row - 1, col], [row - 2, col]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n            case 1: // Right: if two squares to the right is not over edge or filled\n                if (((col + 2) < mazeGrid[row].length) && (mazeGrid[row][col + 2] === \"wall\")) {\n                    const [midNode, newNode] = [[row, col + 1], [row, col + 2]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n            case 2: // Down: if potential path column below is not edge or filled\n\n                if (((row + 2) < mazeGrid.length) && (mazeGrid[row + 2][col] === \"wall\")) {\n                    const [midNode, newNode] = [[row + 1, col], [row + 2, col]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n            case 3: // Left: if two squares to the left is not over edge or filled\n                if (((col - 2) >= 0) && (mazeGrid[row][col - 2] === \"wall\")) {\n                    const [midNode, newNode] = [[row, col - 1], [row, col - 2]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n        }\n    }\n    deadEnd = true\n    return [mazeGrid, newAnimations, deadEnd]\n}\n\nconst loopMaker = (mazeGrid, mazeAnimations, loopsRequired) => {\n    let loopsMade = 0;\n    while (loopsMade < loopsRequired) {\n        // Not selecting the bottom 20 % of the maze makes loops more likely to form\n        // Only selects numbers between 1 and 80% of mazeGrid length\n        const randRow = Math.floor(Math.random() * (mazeGrid.length * .8 - 1)) + 1\n        // Select any column except for first and last\n        const randCol = Math.floor(Math.random() * (mazeGrid[0].length - 2)) + 1\n        if ( // Forms loops better by only choosing walls sandwiched between two other walls, but not 3 ways corners\n            mazeGrid[randRow][randCol] === \"wall\"\n            && (\n                (mazeGrid[randRow + 1][randCol] === \"wall\" && mazeGrid[randRow - 1][randCol] === \"wall\" && mazeGrid[randRow][randCol + 1] !== \"wall\" && mazeGrid[randRow][randCol - 1] !== \"wall\") ||\n                (mazeGrid[randRow][randCol + 1] === \"wall\" && mazeGrid[randRow][randCol - 1] === \"wall\" && mazeGrid[randRow + 1][randCol] !== \"wall\" && mazeGrid[randRow - 1][randCol] !== \"wall\")\n            )\n        ) {\n            mazeGrid[randRow][randCol] = \"path\"\n            mazeAnimations.push([randRow, randCol])\n            loopsMade++\n        }\n    }\n\n    return [mazeGrid, mazeAnimations]\n}\n\nexport const nodeFinder = (mazeGrid, entrance, exit) => { // Finds nodes, points at which the maze either turns or forks, for use in building graphs\n    const nodeAnimations = [];\n    const nodeList = []; // List of nodes with the location and directions of nearest nodes\n\n    // Add the start of the maze to the animations\n    nodeAnimations.push(entrance)\n\n    nodeList.push([...entrance, [2]])\n\n    for (let row = 1; row < mazeGrid.length - 1; row++) { // Cycles through rows and columns, searching for nodes in each odd row/col\n        for (let col = 1; col < mazeGrid[0].length - 1; col++) {\n            const directions = [];\n            for (let direction = 0; direction < 4; direction++) {\n\n                switch (direction) {\n                    case 0:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row - 1][col] === \"path\") { // Up: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 1:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col + 1] === \"path\") { // Right: if potential path column right is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 2:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row + 1][col] === \"path\") { // Down: if potential path column down is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 3:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col - 1] === \"path\") { // Left: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                }\n            }\n            if (directions.length === 1) { // If dead end, corner, or intersection\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 2 && (directions[0] - directions[1]) % 2 !== 0) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 3 || directions.length === 4) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            }\n\n        }\n    }\n    // Add the end of the maze to the animations\n    nodeAnimations.push(exit)\n    nodeList.push([...exit, [0]])\n\n    const nodeMazeGrid = JSON.parse(JSON.stringify(mazeGrid))    // Deep copy the maze grid\n    nodeList.forEach(node => nodeMazeGrid[node[0]][node[1]] = \"node\")\n\n    const nodeWeights = weightFinder(nodeMazeGrid, nodeList)\n\n    return [nodeAnimations, nodeWeights]\n}\n\nconst weightFinder = (nodeMazeGrid, nodeList) => {\n    const nodeWeights = {};\n    nodeList.forEach(node => {\n        const [row, col] = [node[0], node[1]];\n        const nodeDirections = []\n        const directions = node[2]\n        directions.forEach(direction => {\n            let i = 1;\n\n\n            switch (direction) {\n                case 0: // Up\n                    while (row - i >= 0 && nodeMazeGrid[row - i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 1: // Right\n                    while (col + i < nodeMazeGrid[row].length && nodeMazeGrid[row][col + i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 2: // Down\n                    while (row + i < nodeMazeGrid.length && nodeMazeGrid[row + i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 3: // Left\n                    while (col - i >= 0 && nodeMazeGrid[row][col - i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n            }\n        })\n        nodeWeights[`${row},${col}`] = nodeDirections\n    })\n    return nodeWeights;\n}\n","export const nodeFinder = (mazeGrid, entrance, exit) => { // Finds nodes, points at which the maze either turns or forks, for use in building graphs\n    const nodeAnimations = [];\n    const nodeList = []; // List of nodes with the location and directions of nearest nodes\n\n    // Add the start of the maze to the animations\n    nodeAnimations.push(entrance)\n\n    nodeList.push([...entrance, [2]])\n\n    for (let row = 1; row < mazeGrid.length - 1; row++) { // Cycles through rows and columns, searching for nodes in each odd row/col\n        for (let col = 1; col < mazeGrid[0].length - 1; col++) {\n            const directions = [];\n            for (let direction = 0; direction < 4; direction++) {\n\n                switch (direction) {\n                    case 0:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row - 1][col] === \"path\") { // Up: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 1:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col + 1] === \"path\") { // Right: if potential path column right is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 2:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row + 1][col] === \"path\") { // Down: if potential path column down is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 3:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col - 1] === \"path\") { // Left: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                }\n            }\n            if (directions.length === 1) { // If dead end, corner, or intersection\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 2 && (directions[0] - directions[1]) % 2 !== 0) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 3 || directions.length === 4) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            }\n\n        }\n    }\n    // Add the end of the maze to the animations\n    nodeAnimations.push(exit)\n    nodeList.push([...exit, [0]])\n\n    const nodeMazeGrid = JSON.parse(JSON.stringify(mazeGrid))    // Deep copy the maze grid\n    nodeList.forEach(node => nodeMazeGrid[node[0]][node[1]] = \"node\")\n\n    const nodeWeights = weightFinder(nodeMazeGrid, nodeList)\n\n    return [nodeAnimations, nodeWeights]\n}\n\nconst weightFinder = (nodeMazeGrid, nodeList) => { // Finds weights for building an edge graph of the maze\n    const nodeWeights = {};\n    nodeList.forEach(node => {\n        const [row, col] = [node[0], node[1]];\n        const nodeDirections = []\n        const directions = node[2]\n        directions.forEach(direction => {\n            let i = 1;\n\n\n            switch (direction) {\n                case 0: // Up\n                    while (row - i >= 0 && nodeMazeGrid[row - i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 1: // Right\n                    while (col + i < nodeMazeGrid[row].length && nodeMazeGrid[row][col + i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 2: // Down\n                    while (row + i < nodeMazeGrid.length && nodeMazeGrid[row + i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 3: // Left\n                    while (col - i >= 0 && nodeMazeGrid[row][col - i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n            }\n        })\n        nodeWeights[`${row},${col}`] = nodeDirections\n    })\n    return nodeWeights;\n}\n\nconst shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\n\n// Maze-solving algorithms:\n\nexport const solveMaze = (grid, defaults, algorithm) => {\n    const newGrid = JSON.parse(JSON.stringify(grid)); // Deep copy of grid\n    const animations = { solvingAnimations: [], backtrackingAnimations: [] };\n\n    let solvingAlgorithm = dijkstrasSolvingAlgorithm\n    switch (algorithm) {\n        case \"depthFirst\":\n            solvingAlgorithm = depthFirstSearchSolvingAlgorithm;\n            break;\n        case \"breadthFirst\":\n            solvingAlgorithm = breadthFirstSearchSolvingAlgorithm\n            break;\n        case \"dijkstra's\":\n            solvingAlgorithm = dijkstrasSolvingAlgorithm\n            break;\n        case \"a-star\":\n            solvingAlgorithm = aStarSolvingAlgorithm\n            break;\n    }\n\n    solvingAlgorithm(defaults.start, defaults.enter, defaults.exit, newGrid, animations)\n    return animations\n}\n\nconst depthFirstSearchSolvingAlgorithm = (startNode, prevNode, endNode, newGrid, animations) => {\n    const node = startNode;\n\n    if ((node[0] === endNode[0]) && (node[1] === endNode[1])) {\n        animations.backtrackingAnimations.push(node)\n        animations.backtrackingAnimations.push(prevNode)\n        return true\n    }\n\n    let mazeEndFound = false;\n    const [row, col] = node;\n    newGrid[row][col] = \"checked\";\n    animations.solvingAnimations.push(node)\n\n    const directionArray = shuffle([...Array(4).keys()]);\n    for (let i = 0; i < 4; i++) {\n\n        const direction = directionArray[i]\n\n        switch (direction) {\n\n            case 0: // Up: checks if 2 squares up is not over edge and there is a path toward that direction\n                if ((row - 1 >= 0) && (newGrid[row - 1][col] === \"path\")) {\n                    const newNode = [row - 1, col];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n\n                }\n                break;\n            case 1: // Right: checks if 2 squares right is not over edge and there is a path toward that direction\n                if ((col + 1 < newGrid[row].length) && (newGrid[row][col + 1] === \"path\")) {\n                    const newNode = [row, col + 1];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n                }\n                break;\n            case 2: // Down: checks if 2 squares down is not over edge and there is a path toward that direction\n                if ((row + 1 < newGrid.length) && (newGrid[row + 1][col] === \"path\")) {\n                    const newNode = [row + 1, col];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n                }\n                break;\n            case 3: // Left: checks if 2 squares left is not over edge and there is a path toward that direction\n                if ((col - 1 >= 0) && (newGrid[row][col - 1] === \"path\")) {\n                    const newNode = [row, col - 1];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n                }\n                break;\n\n        }\n        if (mazeEndFound) {\n            animations.backtrackingAnimations.push(prevNode)\n            return mazeEndFound\n        }\n\n    }\n    return mazeEndFound\n\n}\n\nconst breadthFirstSearchSolvingAlgorithm = (startNode, prevNode, endNode, newGrid, animations) => {\n\n    const frontierQueue = [];\n    const backtrackDictionary = {};\n    frontierQueue.push(prevNode);\n    let checking = true;\n\n\n    const breadthFirstRecursion = (frontierQueue, endNode, newGrid, animations, backtrackDictionary) => {\n        const node = frontierQueue.shift();\n\n        if (node[0] === endNode[0] && node[1] === endNode[1]) return false\n\n        animations.solvingAnimations.push(node);\n\n        const [row, col] = [node[0], node[1]];\n        newGrid[row][col] = \"checked\";\n\n        for (let i = 0; i < 4; i++) {\n            const direction = i;\n\n            switch (direction) {\n\n                case 0: // Up: checks if 2 squares up is not over edge and there is a path toward that direction\n                    if ((row - 1 >= 0) && (newGrid[row - 1][col] === \"path\")) {\n                        const newNode = [row - 1, col];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n                case 1: // Right: checks if 2 squares right is not over edge and there is a path toward that direction\n                    if ((col + 1 < newGrid[row].length) && (newGrid[row][col + 1] === \"path\")) {\n                        const newNode = [row, col + 1];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n                case 2: // Down: checks if 2 squares down is not over edge and there is a path toward that direction\n                    if ((row + 1 < newGrid.length) && (newGrid[row + 1][col] === \"path\")) {\n                        const newNode = [row + 1, col];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n                case 3: // Left: checks if 2 squares left is not over edge and there is a path toward that direction\n                    if ((col - 1 >= 0) && (newGrid[row][col - 1] === \"path\")) {\n                        const newNode = [row, col - 1];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n            }\n        }\n        return (frontierQueue.length > 0)\n    }\n\n    while (checking) {\n        checking = breadthFirstRecursion(frontierQueue, endNode, newGrid, animations, backtrackDictionary);\n    }\n\n    let btNode = endNode;\n    animations.backtrackingAnimations.push(btNode);\n    while (!((btNode[0] === startNode[0]) && (btNode[1] === startNode[1]))) {\n        const dictionaryString = `${btNode[0]},${btNode[1]}`;\n        btNode = backtrackDictionary[dictionaryString]\n        animations.backtrackingAnimations.push(btNode);\n    }\n\n}\n\nconst nodeAndWeightFinder = (mazeGrid, baseNode) => { // Finds nodes, points at which the maze either turns or forks, and their corresponding weights to the base node\n    const nodeAndWeightList = []; // List of nodes with the location and directions of nearest nodes \n    const [row, col] = baseNode;\n    \n    for (let direction = 0; direction < 4; direction++) {\n        \n        let counter = 1;\n        let node;\n        switch (direction) {\n            case 0:\n                if (baseNode[0] - counter >= 0 && mazeGrid[baseNode[0] - counter][baseNode[1]] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0] - counter, baseNode[1]])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n            case 1:\n                if (baseNode[1] + counter < mazeGrid[0].length && mazeGrid[baseNode[0]][baseNode[1] + counter] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0], baseNode[1] + counter])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n            case 2:\n                if (baseNode[0] + counter < mazeGrid.length && mazeGrid[baseNode[0] + counter][baseNode[1]] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0] + counter, baseNode[1]])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n            case 3:\n                if (baseNode[1] - counter >= 0 && mazeGrid[baseNode[0]][baseNode[1] - counter] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0], baseNode[1] - counter])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n        }\n    }\n    \n    return nodeAndWeightList\n}\n\nconst isANode = (mazeGrid, node) => { // Checks if selected location is a node or not\n    // Scans four directions and \n    const [row, col] = node;\n    \n    const directions = [];\n    if (row > 0 && mazeGrid[row - 1][col] === \"path\") { // Up\n        directions.push(0)\n    } \n    if (col < mazeGrid[0].length - 1 && mazeGrid[row][col + 1] === \"path\") { // Right\n        directions.push(1)\n    } \n    if (row < mazeGrid.length - 1 && mazeGrid[row + 1][col] === \"path\") { // Down\n        directions.push(2)\n    } \n    if (col > 0 && mazeGrid[row][col - 1] === \"path\") { // Left\n        directions.push(3)\n    }\n    \n    if (directions.length === 1 || directions.length > 2 || (directions[0] - directions[1]) % 2 !== 0) { \n        // Is either a dead end or a t-junction/4-way or a corner \n        return true\n    }\n\n    return false\n}\n\n\nconst dijkstrasSolvingAlgorithm = (startNode, enterNode, exitNode, mazeGrid, animations, heuristic = false) => {\n    const lowestUnvisitedNode = (distances, visitedNodes) => {\n        let min = [null, Infinity];\n        Object.entries(distances).forEach((distance) => {\n            const currentDistanceStr = distance[0];\n            if (!visitedNodes[currentDistanceStr] && distances[currentDistanceStr] < min[1]) {\n                min = [currentDistanceStr, distance[1]];\n            }\n        })\n\n        return (min[0] === null) ? null : min[0].split(\",\");\n    }\n\n    // Initialize distances dictionary for start and end nodes\n    const distances = {};\n    distances[`${enterNode[0]},${enterNode[1]}`] = 0;\n    distances[`${exitNode[0]},${exitNode[1]}`] = Infinity;\n\n    // Initialize parent nodes dictionary\n    const parentNodes = {};\n    parentNodes[`${exitNode[0]},${exitNode[1]}`] = null;\n\n    // Initialize arrays for visited and unvisited nodes\n    const visitedNodes = {};\n    let unvisitedNodes = nodeAndWeightFinder(mazeGrid, enterNode)\n    \n    let currentNode = enterNode;\n    animations.solvingAnimations.push([enterNode])\n    while (currentNode !== null && (currentNode[0] !== exitNode[0] && currentNode[1] !== exitNode[1])) { // Exits if out of nodes or at end\n        console.log(\"loop\")\n        // Converts back from string to number\n        const [row, col] = [Number(currentNode[0]), Number(currentNode[1])];\n        animations.solvingAnimations.push([row, col])\n\n        const currentNodeStr = `${row},${col}` // String for node currently looking at, for lookup in dictionary\n        const currentDistance = distances[currentNodeStr]; // Distance of current node from start\n        unvisitedNodes = nodeAndWeightFinder(mazeGrid, [row, col]) // Find weights of all attached nodes, meaning distances from current node\n        unvisitedNodes.forEach((edge) => { // Cycle through all nearest nodes\n            const [direction, edgeDistance] = [edge[0], edge[1]] // Direction and distance/weight to that direction\n            let childNode, childNodeStr, totalWeight;\n            let hWeight = 0; // Additional heuristic weight, for use in A*\n            const distanceFromStart = currentDistance + edgeDistance\n\n            switch (direction) {\n                case 0: //Up\n                    // Make new node and node string\n                    childNode = [row - edgeDistance, col];  \n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0; \n                    totalWeight = distanceFromStart + hWeight\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                case 1: //Right\n                    // Make new node and node string\n                    childNode = [row, col + edgeDistance];\n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0;\n                    totalWeight = distanceFromStart + hWeight;\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                case 2: //Down\n                    // Make new node and node string\n                    childNode = [row + edgeDistance, col];\n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0;\n                    totalWeight = distanceFromStart + hWeight;\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                case 3: //Left\n                    // Make new node and node string\n                    childNode = [row, col - edgeDistance];\n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0;\n                    totalWeight = distanceFromStart + hWeight;\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        })\n\n        visitedNodes[currentNodeStr] = unvisitedNodes;\n        currentNode = lowestUnvisitedNode(distances, visitedNodes)\n    }\n\n    if (currentNode === null || (currentNode[0] === exitNode[0] && currentNode[1] === exitNode[1])) {\n        let backtrackNode = exitNode;\n        animations.backtrackingAnimations.push(backtrackNode)\n\n        while (backtrackNode[0] !== enterNode[0] && backtrackNode[1] !== enterNode[1]) {\n            const newNodeStrArray = parentNodes[`${backtrackNode[0]},${backtrackNode[1]}`].split(\",\")\n            backtrackNode = [Number(newNodeStrArray[0]), newNodeStrArray[1]]\n            animations.backtrackingAnimations.push(backtrackNode)\n\n        }\n    }\n}\n\nconst aStarSolvingAlgorithm = (startNode, enterNode, exitNode, mazeGrid, animations) => {\n    dijkstrasSolvingAlgorithm(startNode, enterNode, exitNode, mazeGrid, animations, true)\n}","// Animations\n\nexport const animateMazeDrawing = (mazeAnimations, canvas, cellSize) => {\n    const ctx = canvas.current.getContext('2d');\n\n    let counter = 0;\n    let stepId;\n    function drawPath() {\n        if (mazeAnimations.drawingAnimations.length !== 0) {\n\n            for (let i = 0; i < 725; i++) {\n                if (counter < mazeAnimations.drawingAnimations.length) {\n                    const animation = mazeAnimations.drawingAnimations[counter];\n                    const [row, col] = animation;\n                    ctx.clearRect(col * cellSize, row * cellSize, cellSize, cellSize);\n                    counter++\n                }\n            }\n\n            stepId = window.requestAnimationFrame(drawPath);\n            \n\n        }\n    }\n    const play = () => {\n        window.requestAnimationFrame(drawPath)\n    }\n\n    const stop = () => {\n        cancelAnimationFrame(stepId)\n        return stepId\n    }\n\n    play()\n\n}\n\n    // if (mazeAnimations.nodeAnimations.length !== 0) {\n    //     mazeAnimations.nodeAnimations.forEach((animation, index) => {\n    //         setTimeout(() => {\n    //             const [row, col] = animation;\n    //             ctx.fillStyle = \"#ff0000\"\n    //             ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n    //         }, drawSpeed * mazeAnimations.drawingAnimations.length + drawSpeed * index); // Set a delay based on the time to finish the drawing animation, before drawing the nodes\n    //     })\n    // }\n\n\nexport const animateMazeSolving = (solvingAnimations, canvas, cellSize, drawSpeed) => {\n    const ctx = canvas.current.getContext('2d');\n\n    if (solvingAnimations !== []) {\n\n        solvingAnimations.forEach((animation, index) => {\n            setTimeout(() => {\n                ctx.fillStyle = \"#ff0000\"\n                const [row, col] = animation;\n                ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n            }, drawSpeed * index);\n        })\n\n    }\n}\n\nexport const animateMazeSolvingBacktrack = (backtrackingAnimations, canvas, cellSize, drawSpeed, delay) => {\n    const ctx = canvas.current.getContext('2d');\n\n    if (backtrackingAnimations !== []) {\n\n        backtrackingAnimations.forEach((animation, index) => {\n            setTimeout(() => {\n                ctx.fillStyle = \"#fcf000\"\n                const [row, col] = animation;\n                ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n            }, delay + drawSpeed * index);\n        })\n\n    }\n}","import React, { useState, useEffect, useRef } from 'react';\nimport { initializeGrid, generateMaze, clearCanvas, fillCanvas } from './PathfindingFunctions/mazeGeneratingFunctions.js';\nimport { solveMaze, nodeFinder } from './PathfindingFunctions/mazeSolvingFunctions.js';\nimport { animateMazeDrawing, animateMazeSolving, animateMazeSolvingBacktrack } from './PathfindingFunctions/mazeAnimatingFunctions.js';\nimport { Dropdown, Button, ButtonGroup } from 'react-bootstrap';\n\n\nconst Pathfinding = () => {\n    const canvas = useRef(null);\n    const [cellSize, setCellSize] = useState(10) // Fix this so that it's set with number of cells, not sizee !!!!\n    const [canvasDimensions, setCanvasDimensions] = useState({width: cellSize*51, height: cellSize*51, x: 0, y: 0}) //FIX SO THAT SET PROGRAMMATICALLY\n    const [grid, setGrid] = useState([])\n    const [mazeAnimations, setMazeAnimations] = useState({ drawingAnimations: [], nodeAnimations: [] })\n    const [solvingAnimations, setSolvingAnimations] = useState([])\n    const [drawSpeed, setDrawSpeed] = useState(0)\n    const [mazeGenAlgo, setMazeGenAlgo] = useState(\"eller's\")\n    const [mazeSolveAlgo, setMazeSolveAlgo] = useState(\"depthFirst\")\n\n    useEffect(() => {\n        const [initialGrid, x, y] = initializeGrid(canvas, cellSize, canvasDimensions)\n        console.log(window.innerHeight);\n        \n        setGrid(initialGrid)\n        setCanvasDimensions({\n            ...canvasDimensions,\n            x,\n            y\n        })\n        const fillGrid = fillCanvas(canvas, cellSize)\n        setGrid(fillGrid)\n\n    }, [])\n\n    \n    \n\n    // Get all algorithms to work on the non-maze board\n    // Once finished, fix up website and prepare for deployment\n\n    // Possible add-ons\n        // Pixelpainting descrambler\n        // Other maze-building algos - Hunt & kill, sidewinder, prims, kruskal, ellers\n        // Other algorithms - \n            // Pathfinding - best first search\n            // Sorting Heap Sort\n        // More animations - \n            //Pathfinding - show red backtrack and removal for backtracking building algo, current node highlighted in green, path in rainbow colors, show nodes of node graph and connnxns, make a binary search tree and animate it being built\n            // Sorting - \n        // More functionality \n            //Pathfinding - can go forwards and reverse, adjust number of loops, adjust size, adjust speed, reset maze solve or build, make it possible to skip animations, random wall generation, A* draws the optimal path, Dijkstra draws the optimal path?\n\n    \n\n    const [mazeGenerating, setMazeGenerating] = useState(false)\n\n    useEffect(() => {\n        \n        if(mazeGenerating) {\n            const fillGrid = fillCanvas(canvas, cellSize)\n\n            const [mazeGrid, animations, mazeFinished] = generateMaze(fillGrid, mazeGenAlgo)\n\n            setMazeAnimations(animations)\n            setGrid(mazeGrid)\n            if (mazeFinished) {\n                setMazeGenerating(false)\n            }\n\n        }\n    }, [mazeGenerating])\n\n\n\n    const [backtrackingAnimations, setBacktrackingAnimations] = useState([])\n    \n\n    const [mazeSolving, setMazeSolving] = useState(false)\n    useEffect(() => {\n        if (mazeSolving) {\n            const defaults = { enter: [0, 1], exit: [grid.length - 1, grid[0].length - 2], start: [1, 1] };\n            const animations = solveMaze(grid, defaults, mazeSolveAlgo)\n            \n            setSolvingAnimations(animations.solvingAnimations)\n            setBacktrackingAnimations(animations.backtrackingAnimations)\n            setMazeSolving(false)\n        }\n        \n    }, [mazeSolving, grid])\n\n\n    \n\n    useEffect(() => {\n        const test = animateMazeDrawing(mazeAnimations, canvas, cellSize, drawSpeed);\n        console.log(test);\n        \n    }, [mazeAnimations]);\n\n\n    \n\n    useEffect(() => {\n        animateMazeSolving(solvingAnimations, canvas, cellSize, drawSpeed)\n    }, [ solvingAnimations]);\n\n    \n\n    useEffect(() => {\n        const delay = solvingAnimations.length * drawSpeed;\n        animateMazeSolvingBacktrack(backtrackingAnimations, canvas, cellSize, drawSpeed, delay)\n    }, [backtrackingAnimations]);\n    \n    const handleOnClick = (e) => {\n        \n        const [row, col] = [Math.floor((e.clientY - canvasDimensions.y) / cellSize), Math.floor((e.clientX - canvasDimensions.x + .5) / cellSize)];\n        \n        const newGrid = [...grid];\n\n        const ctx = canvas.current.getContext('2d');\n        if (grid[row][col] !== \"wall\") {\n            ctx.fillStyle = \"#444\";\n            ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n        } else {\n            ctx.clearRect(col * cellSize, row * cellSize, cellSize, cellSize);\n        }\n\n        newGrid[row][col] = (newGrid[row][col] === \"wall\") ? \"wall\" : \"path\"\n        setGrid(newGrid)\n    };\n\n\n    const [mouseDown, setMouseDown] = useState(false)\n    const [fillType, setFillType] = useState(\"wall\")\n    const handleMouseDown = (e) => {\n        setMouseDown(true)\n        console.log(e);\n        const [row, col] = [Math.floor((e.clientY - canvasDimensions.y) / cellSize), Math.floor((e.clientX - canvasDimensions.x + .5) / cellSize)];\n        setFillType((grid[row][col] === \"wall\") ? \"path\" : \"wall\")\n    }\n\n    const handleMouseUp = (e) => {\n        setMouseDown(false)\n    }\n\n    const handleMouseOut = (e) => {\n        setMouseDown(false)\n    }\n\n    const handleMouseMove = (e) => {\n        if (mouseDown) {\n            const [row, col] = [Math.floor((e.clientY - canvasDimensions.y) / cellSize), Math.floor((e.clientX - canvasDimensions.x + .5) / cellSize)];\n\n            const newGrid = [...grid];\n\n            const ctx = canvas.current.getContext('2d');\n            if (fillType === \"wall\") {\n                ctx.fillStyle = \"#444\";\n                ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n                newGrid[row][col] = \"wall\";\n            } else {\n                ctx.clearRect(col * cellSize, row * cellSize, cellSize, cellSize);\n                newGrid[row][col] = \"path\";\n            }\n\n            setGrid(newGrid)\n        }\n    }\n\n    const handleClearCanvas = () => {\n        const clearGrid = clearCanvas(canvas, cellSize)\n        setGrid(clearGrid)\n    }\n\n    const handleFillCanvas = () => {\n        const fillGrid = fillCanvas(canvas, cellSize)\n        setGrid(fillGrid)\n    }\n\n    const [ mazeGenAlgoTitle, setMazeGenAlgoTitle ] = useState(\"Select Generation Algorithm\");\n    const handleMazeGenSelect = (algorithm, title) => {\n        setMazeGenAlgo(algorithm);\n        setMazeGenAlgoTitle(title);\n    }\n\n    const [ mazeSolveAlgoTitle, setMazeSolveAlgoTitle ] = useState(\"Select Solving Algorithm\");\n    const handleMazeSolveSelect = (algorithm, title) => {\n        setMazeSolveAlgo(algorithm);\n        setMazeSolveAlgoTitle(title);\n    }\n    \n    return (\n        <div>\n            <div className=\"nav-bar\">\n                <div className=\"gen-algo-bar\">\n                    <Dropdown>\n                        <Dropdown.Toggle variant=\"success\" id=\"dropdown-basic\">\n                            {mazeGenAlgoTitle}\n                        </Dropdown.Toggle>\n\n                        <Dropdown.Menu>\n                            <Dropdown.Item onClick={() => handleMazeGenSelect(\"eller's\", \"Elller's Algorithm\")} href=\"#/action-1\">Eller's Algorithm</Dropdown.Item>\n                            <Dropdown.Item onClick={() => handleMazeGenSelect(\"depthFirst\", \"Recursive Backtracking\")} href=\"#/action-2\">Recursive Backtracking</Dropdown.Item>\n                        </Dropdown.Menu>\n                    </Dropdown>\n\n                    <Dropdown>\n                        <Dropdown.Toggle variant=\"success\" id=\"dropdown-basic\">\n                            {mazeSolveAlgoTitle}\n                        </Dropdown.Toggle>\n\n                        <Dropdown.Menu>\n                            <Dropdown.Item onClick={() => handleMazeSolveSelect(\"depthFirst\", \"Depth-First Search\")}>Depth-First Search</Dropdown.Item>\n                            <Dropdown.Item onClick={() => handleMazeSolveSelect(\"breadthFirst\", \"Breadth-First Search\")}>Breadth-First Search</Dropdown.Item>\n                            <Dropdown.Item onClick={() => handleMazeSolveSelect(\"dijkstra's\", \"Djikstra's Algorithm\")}>Dijkstra's Algorithm</Dropdown.Item>\n                            <Dropdown.Item onClick={() => handleMazeSolveSelect(\"a-star\", \"A* Search Algorithm\")}>A* Search Algorith</Dropdown.Item>\n                        </Dropdown.Menu>\n                    </Dropdown>\n                </div>\n                <div className=\"sliders-bar\">\n                    <input onChange=\"\" type=\"range\" min=\"1\" max=\"100\" value=\"50\" class=\"slider\" id=\"myRange\"></input>\n                </div>\n            </div>\n            <div id=\"canvas\">\n                <ButtonGroup>\n                    <Button onClick={handleClearCanvas}>Clear</Button>\n                    <Button onClick={handleFillCanvas}>Fill</Button>\n                </ButtonGroup>\n                \n                <canvas onClick={handleOnClick} onMouseDown={handleMouseDown} onMouseUp={handleMouseUp} onMouseOut={handleMouseOut} onMouseMove={handleMouseMove} ref={canvas}></canvas>\n                <Button onClick={() => setMazeGenerating(true)}>Generate Maze</Button>\n                <Button onClick={() => setMazeSolving(true)}>Solve Maze</Button>\n                <Button onClick ={() => animateMazeDrawing.play()}>Play</Button>\n            </div>\n        </div>\n    )\n}\n\nexport default Pathfinding;\n","import React from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link } from 'react-router-dom';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport Nav from 'react-bootstrap/Nav';\nimport './app.css';\n\nimport Sorting from './Sorting';\nimport Pathfinding from './Pathfinding'\n\nconst App = () => {\n    return (\n        <div className=\"page\">\n             <Router>\n                <Nav activeKey=\"/main\" >\n                    <Nav.Item>\n                        <Nav.Link>\n                            <Link to=\"/\">Main</Link>\n                        </Nav.Link>\n                    </Nav.Item>\n                    <Nav.Item>\n                        <Nav.Link>\n                            <Link to=\"/sorting\">Sorting</Link>\n                        </Nav.Link>\n                    </Nav.Item>\n                    <Nav.Item>\n                        <Nav.Link>\n                            <Link to=\"/pathfinding\">Pathfinding</Link>\n                        </Nav.Link>\n                    </Nav.Item>\n                </Nav>\n\n                <Switch>\n                    <Route path=\"/sorting\">\n                        <Sorting />\n                    </Route>\n                    <Route path=\"/pathfinding\">\n                        <Pathfinding />\n                    </Route>\n                </Switch>\n            </Router>\n        </div>\n    )\n};\n\nexport default App;\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport { barChartRadixSort } from './Sorting/utilities';\n\nReactDOM.render(\n    <App/> , document.getElementById('root')\n);\n\n"],"sourceRoot":""}