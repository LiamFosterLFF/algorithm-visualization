{"version":3,"sources":["Pathfinding/PathfindingFunctions/mazeGeneratingFunctions.js","Pathfinding/PathfindingFunctions/mazeSolvingFunctions.js","Pathfinding/PathfindingFunctions/mazeAnimatingFunctions.js","Pathfinding/index.js","App.js","index.js"],"names":["clearCanvas","canvas","cellSize","ctx","current","getContext","width","height","clearRect","cols","rows","clearGrid","row","push","col","fillCanvas","fillStyle","fillRect","fillGrid","ellersMazeAlgorithm","startNode","prevNode","origMazeGrid","animations","mazeGrid","JSON","parse","stringify","setNoCounter","i","length","j","undefined","Math","random","placeHolder","setNo","setCounter","extensionNo","floor","extensionCounter","extensionColumn","l","pathMazeGrid","depthFirstMazeAlgorithm","node","prevRow","prevCol","newAnimations","directionArray","array","shuffle","Array","keys","nodeFinder","entrance","exit","nodeAnimations","nodeList","directions","direction","nodeMazeGrid","forEach","weightFinder","nodeWeights","nodeDirections","depthFirstSearchSolvingAlgorithm","endNode","newGrid","backtrackingAnimations","mazeEndFound","solvingAnimations","newNode","breadthFirstSearchSolvingAlgorithm","frontierQueue","backtrackDictionary","checking","breadthFirstRecursion","shift","btNode","nodeAndWeightFinder","baseNode","nodeAndWeightList","counter","isANode","dijkstrasSolvingAlgorithm","enterNode","exitNode","heuristic","lowestUnvisitedNode","distances","visitedNodes","min","Infinity","Object","entries","distance","currentDistanceStr","split","parentNodes","unvisitedNodes","currentNode","console","log","Number","currentNodeStr","currentDistance","edge","childNode","childNodeStr","totalWeight","edgeDistance","distanceFromStart","backtrackNode","newNodeStrArray","aStarSolvingAlgorithm","animateMazeDrawing","mazeAnimations","drawPath","drawingAnimations","animation","window","requestAnimationFrame","Pathfinding","useRef","useState","x","y","canvasDimensions","setCanvasDimensions","grid","setGrid","setMazeAnimations","setSolvingAnimations","drawSpeed","mazeGenAlgo","setMazeGenAlgo","mazeSolveAlgo","setMazeSolveAlgo","useEffect","initialGrid","getBoundingClientRect","initializeGrid","innerHeight","mazeGenerating","setMazeGenerating","algorithm","mazeFinished","start","mazeAlgorithm","generateMaze","setBacktrackingAnimations","mazeSolving","setMazeSolving","defaults","enter","solvingAlgorithm","solveMaze","test","index","setTimeout","animateMazeSolving","delay","animateMazeSolvingBacktrack","mouseDown","setMouseDown","fillType","setFillType","className","onClick","onChange","type","max","value","class","id","e","clientY","clientX","onMouseDown","onMouseUp","onMouseOut","onMouseMove","ref","play","App","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.70a7462e.chunk.js","sourcesContent":["// Draw initial Grid\nexport const initializeGrid = (canvas, cellSize, canvasDimensions) => {\n\n    const ctx = canvas.current.getContext('2d');\n    const [width, height] = [canvasDimensions.width, canvasDimensions.height]\n\n    // Initialize Background\n    ctx.canvas.width = width;\n    ctx.canvas.height = height;\n\n    // Initialize Grid as Clear\n    const initialGrid = clearCanvas(canvas, cellSize)\n    \n    // Find x and y coordinates of canvas\n    const [xCoordinate, yCoordinate] = [canvas.current.getBoundingClientRect().x, canvas.current.getBoundingClientRect().y]\n\n    return [initialGrid, xCoordinate, yCoordinate]\n\n\n\n}\n\nexport const clearCanvas = (canvas, cellSize) => {\n    const ctx = canvas.current.getContext('2d');\n    const [width, height] = [ctx.canvas.width, ctx.canvas.height]\n    \n    // Clear Background\n    ctx.clearRect(0, 0, width, height);\n\n    // Construct Grid of Cells\n    const [cols, rows] = [width / cellSize, height / cellSize];\n    \n    const clearGrid = [];\n    // Builds a rows*cols nested array full of walls\n    for (let row = 0; row < rows; row++) {\n        clearGrid.push([])\n        for (let col = 0; col < cols; col++) {\n            clearGrid[row].push(\"path\")\n        }\n    }\n    return clearGrid\n}\n\nexport const fillCanvas = (canvas, cellSize) => {\n    const ctx = canvas.current.getContext('2d');\n    const [width, height] = [ctx.canvas.width, ctx.canvas.height]\n\n    // Fill Background\n    ctx.fillStyle = \"#444\";\n    ctx.fillRect(0, 0, width, height);\n\n    // Construct Grid of Cells\n    const [cols, rows] = [width / cellSize, height / cellSize]\n    const fillGrid = [];\n    // Builds a rows*cols nested array full of walls\n    for (let row = 0; row < rows; row++) {\n        fillGrid.push([])\n        for (let col = 0; col < cols; col++) {\n            fillGrid[row].push(\"wall\")\n        }\n    }\n    return fillGrid\n}\n\n// Generate initial maze\nexport const generateMaze = (grid, algorithm) => {\n\n    // Number of total columns and total rows\n\n    let mazeGrid = JSON.parse(JSON.stringify(grid)); // Deep copy grid so as not to mutate\n    const [rows, cols] = [mazeGrid.length, mazeGrid[0].length]\n\n    // Animate drawing the entrance and exit\n    const [entrance, exit, start] = [[0, 1], [mazeGrid.length - 1, mazeGrid[0].length - 2], [1, 1]]\n    let drawingAnimations = [entrance, exit];\n\n    // Add entrance and exit to state, and to grid\n    mazeGrid[entrance[0]][entrance[1]] = \"path\";\n    mazeGrid[exit[0]][exit[1]] = \"path\";\n\n    // Calls with start as current and previous node; this is to allow for previous node to be used in recursive call\n    let mazeFinished;\n\n    let mazeAlgorithm = ellersMazeAlgorithm\n    switch (algorithm) {\n        case \"eller's\":\n            mazeAlgorithm = ellersMazeAlgorithm\n            break;\n        case \"depthFirst\":\n            mazeAlgorithm = depthFirstMazeAlgorithm\n            break;\n    }\n\n    [mazeGrid, drawingAnimations, mazeFinished] = mazeAlgorithm(start, start, mazeGrid, drawingAnimations)\n    \n    // Add a set number of loops to the maze\n    // const loops = 200;\n    // [mazeGrid, drawingAnimations] = loopMaker(mazeGrid, drawingAnimations, loops);\n\n    const [nodeAnimations, trash] = nodeFinder(mazeGrid, entrance, exit)\n\n    const mazeAnimations = { drawingAnimations: drawingAnimations, nodeAnimations: nodeAnimations }\n\n    return [mazeGrid, mazeAnimations, mazeFinished]\n}\n\nconst shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\nconst ellersMazeAlgorithm = (startNode, prevNode, origMazeGrid, animations) => {\n\n    const mazeGrid = JSON.parse(JSON.stringify(origMazeGrid)) // Deep copy so as not to mutate original array\n\n    let setNoCounter = 1; // To keep track of set names, so there's no repeats\n    for (let i = 1; i < mazeGrid[1].length - 1; i += 2) {\n        mazeGrid[1][i] = setNoCounter; // Initialize the cells of the first row to each exist in their own set.\n        animations.push([1,i])\n        setNoCounter++;\n    }\n\n    for (let j = 1; j < mazeGrid.length - 2; j += 2) {  // Repeat until the last row is reached\n        \n        for (let i = 1; i < mazeGrid[j].length - 1; i += 2) {// Randomly join adjacent cells, but only if they are not in the same set.\n            if (mazeGrid[j][i+2] !== undefined && mazeGrid[j][i] !== mazeGrid[j][i + 2]) {\n                if (Math.random() < .5) { // Some of the cells joined together, so left side and right of wall must match\n                    mazeGrid[j][i + 1] = mazeGrid[j][i];\n                    mazeGrid[j][i + 2] = mazeGrid[j][i];\n                    animations.push([j, i+1])\n                }\n            }\n        }\n        \n        let placeHolder = 1;\n        while (placeHolder < mazeGrid[j].length ) {// For each set, randomly create vertical connections downward to the next row\n            \n            const setNo = mazeGrid[j][placeHolder] // Number stored in grid for current set\n            let setCounter = 1;\n            while (mazeGrid[j][placeHolder + setCounter * 2] === setNo) { // Counts how many in a row have the same setNo\n                setCounter += 1\n            }\n            \n            // For each set, randomly create a random number (1+) of vertical connections downward to the next row.\n            const extensionNo = 1 + Math.floor(Math.random() * setCounter) * .5;\n            let extensionCounter = 0;\n            while (extensionCounter < extensionNo) {  // Keeps cycling until correct number of columns are created\n                const extensionColumn = Math.floor(Math.random() * setCounter) * 2;\n                if (mazeGrid[j + 1][placeHolder + extensionColumn] === \"wall\") {\n                    mazeGrid[j + 1][placeHolder + extensionColumn] = setNo;\n                    animations.push([j + 1, placeHolder + extensionColumn]);\n                    mazeGrid[j + 2][placeHolder + extensionColumn] = setNo;\n                    animations.push([j + 2, placeHolder + extensionColumn]);\n                    extensionCounter ++\n                }\n            } // Consecutive columns are linked together in next section\n\n            \n\n            placeHolder += setCounter*2; // Moves to the next set\n        }\n        \n        for (let l = 1; l < mazeGrid[j].length - 1; l += 2) { \n            if (mazeGrid[j + 2][l] === \"wall\") {// Flesh out the next row by putting any remaining cells into their own sets.\n                mazeGrid[j + 2][l] = setNoCounter;\n                animations.push([j + 2, l])\n                setNoCounter++\n            } \n        }\n    }\n    for (let i = 1; i < mazeGrid[0].length - 2; i+=2) { //For the last row, join all adjacent cells that do not share a set\n        if (mazeGrid[mazeGrid.length - 2][i] !== mazeGrid[mazeGrid.length - 2][i + 2]) {\n            mazeGrid[mazeGrid.length - 2][i + 1] = mazeGrid[mazeGrid.length - 2][i];\n            animations.push([mazeGrid.length - 2, i + 1]);\n            mazeGrid[mazeGrid.length - 2][i + 2] = mazeGrid[mazeGrid.length - 2][i];\n            animations.push([mazeGrid.length - 2, i + 2]);\n        }\n    }\n\n    const pathMazeGrid = []\n    for (let i = 0; i < mazeGrid.length; i++) {\n        const row = [];\n        for (let j = 0; j < mazeGrid[i].length; j++) {\n            if (mazeGrid[i][j] !== \"wall\") {\n                row.push(\"path\")\n            } else {\n                row.push(\"wall\")\n            }\n        }\n        pathMazeGrid.push(row)\n    }\n    \n\n    \n    return [pathMazeGrid, animations, true]\n    \n}\n\nconst depthFirstMazeAlgorithm = (startNode, prevNode, mazeGrid, animations) => {\n    // Draws maze using recursive depth-first algorithm\n    const node = startNode;\n\n    const [row, col] = node;\n\n    mazeGrid[row][col] = \"path\";\n    const [prevRow, prevCol] = prevNode\n    mazeGrid[prevRow][prevCol] = \"path\";\n    let deadEnd = false;\n\n    let newAnimations = [...animations, prevNode, node] // Add current node to path animation\n    const directionArray = shuffle([...Array(4).keys()]); // Create a random array of directions to choose from\n    for (let i = 0; i < 4; i++) {  // Choose the next direction to go in, or return dead end\n        const direction = directionArray[i]\n        switch (direction) {\n            case 0: // Up: if potential path column above is not edge or filled\n                if (((row - 2) >= 0) && (mazeGrid[row - 2][col] === \"wall\")) {\n                    const [midNode, newNode] = [[row - 1, col], [row - 2, col]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n            case 1: // Right: if two squares to the right is not over edge or filled\n                if (((col + 2) < mazeGrid[row].length) && (mazeGrid[row][col + 2] === \"wall\")) {\n                    const [midNode, newNode] = [[row, col + 1], [row, col + 2]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n            case 2: // Down: if potential path column below is not edge or filled\n\n                if (((row + 2) < mazeGrid.length) && (mazeGrid[row + 2][col] === \"wall\")) {\n                    const [midNode, newNode] = [[row + 1, col], [row + 2, col]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n            case 3: // Left: if two squares to the left is not over edge or filled\n                if (((col - 2) >= 0) && (mazeGrid[row][col - 2] === \"wall\")) {\n                    const [midNode, newNode] = [[row, col - 1], [row, col - 2]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n        }\n    }\n    deadEnd = true\n    return [mazeGrid, newAnimations, deadEnd]\n}\n\nconst loopMaker = (mazeGrid, mazeAnimations, loopsRequired) => {\n    let loopsMade = 0;\n    while (loopsMade < loopsRequired) {\n        // Not selecting the bottom 20 % of the maze makes loops more likely to form\n        // Only selects numbers between 1 and 80% of mazeGrid length\n        const randRow = Math.floor(Math.random() * (mazeGrid.length * .8 - 1)) + 1\n        // Select any column except for first and last\n        const randCol = Math.floor(Math.random() * (mazeGrid[0].length - 2)) + 1\n        if ( // Forms loops better by only choosing walls sandwiched between two other walls, but not 3 ways corners\n            mazeGrid[randRow][randCol] === \"wall\"\n            && (\n                (mazeGrid[randRow + 1][randCol] === \"wall\" && mazeGrid[randRow - 1][randCol] === \"wall\" && mazeGrid[randRow][randCol + 1] !== \"wall\" && mazeGrid[randRow][randCol - 1] !== \"wall\") ||\n                (mazeGrid[randRow][randCol + 1] === \"wall\" && mazeGrid[randRow][randCol - 1] === \"wall\" && mazeGrid[randRow + 1][randCol] !== \"wall\" && mazeGrid[randRow - 1][randCol] !== \"wall\")\n            )\n        ) {\n            mazeGrid[randRow][randCol] = \"path\"\n            mazeAnimations.push([randRow, randCol])\n            loopsMade++\n        }\n    }\n\n    return [mazeGrid, mazeAnimations]\n}\n\nexport const nodeFinder = (mazeGrid, entrance, exit) => { // Finds nodes, points at which the maze either turns or forks, for use in building graphs\n    const nodeAnimations = [];\n    const nodeList = []; // List of nodes with the location and directions of nearest nodes\n\n    // Add the start of the maze to the animations\n    nodeAnimations.push(entrance)\n\n    nodeList.push([...entrance, [2]])\n\n    for (let row = 1; row < mazeGrid.length - 1; row++) { // Cycles through rows and columns, searching for nodes in each odd row/col\n        for (let col = 1; col < mazeGrid[0].length - 1; col++) {\n            const directions = [];\n            for (let direction = 0; direction < 4; direction++) {\n\n                switch (direction) {\n                    case 0:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row - 1][col] === \"path\") { // Up: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 1:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col + 1] === \"path\") { // Right: if potential path column right is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 2:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row + 1][col] === \"path\") { // Down: if potential path column down is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 3:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col - 1] === \"path\") { // Left: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                }\n            }\n            if (directions.length === 1) { // If dead end, corner, or intersection\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 2 && (directions[0] - directions[1]) % 2 !== 0) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 3 || directions.length === 4) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            }\n\n        }\n    }\n    // Add the end of the maze to the animations\n    nodeAnimations.push(exit)\n    nodeList.push([...exit, [0]])\n\n    const nodeMazeGrid = JSON.parse(JSON.stringify(mazeGrid))    // Deep copy the maze grid\n    nodeList.forEach(node => nodeMazeGrid[node[0]][node[1]] = \"node\")\n\n    const nodeWeights = weightFinder(nodeMazeGrid, nodeList)\n\n    return [nodeAnimations, nodeWeights]\n}\n\nconst weightFinder = (nodeMazeGrid, nodeList) => {\n    const nodeWeights = {};\n    nodeList.forEach(node => {\n        const [row, col] = [node[0], node[1]];\n        const nodeDirections = []\n        const directions = node[2]\n        directions.forEach(direction => {\n            let i = 1;\n\n\n            switch (direction) {\n                case 0: // Up\n                    while (row - i >= 0 && nodeMazeGrid[row - i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 1: // Right\n                    while (col + i < nodeMazeGrid[row].length && nodeMazeGrid[row][col + i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 2: // Down\n                    while (row + i < nodeMazeGrid.length && nodeMazeGrid[row + i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 3: // Left\n                    while (col - i >= 0 && nodeMazeGrid[row][col - i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n            }\n        })\n        nodeWeights[`${row},${col}`] = nodeDirections\n    })\n    return nodeWeights;\n}\n","export const nodeFinder = (mazeGrid, entrance, exit) => { // Finds nodes, points at which the maze either turns or forks, for use in building graphs\n    const nodeAnimations = [];\n    const nodeList = []; // List of nodes with the location and directions of nearest nodes\n\n    // Add the start of the maze to the animations\n    nodeAnimations.push(entrance)\n\n    nodeList.push([...entrance, [2]])\n\n    for (let row = 1; row < mazeGrid.length - 1; row++) { // Cycles through rows and columns, searching for nodes in each odd row/col\n        for (let col = 1; col < mazeGrid[0].length - 1; col++) {\n            const directions = [];\n            for (let direction = 0; direction < 4; direction++) {\n\n                switch (direction) {\n                    case 0:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row - 1][col] === \"path\") { // Up: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 1:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col + 1] === \"path\") { // Right: if potential path column right is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 2:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row + 1][col] === \"path\") { // Down: if potential path column down is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 3:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col - 1] === \"path\") { // Left: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                }\n            }\n            if (directions.length === 1) { // If dead end, corner, or intersection\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 2 && (directions[0] - directions[1]) % 2 !== 0) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 3 || directions.length === 4) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            }\n\n        }\n    }\n    // Add the end of the maze to the animations\n    nodeAnimations.push(exit)\n    nodeList.push([...exit, [0]])\n\n    const nodeMazeGrid = JSON.parse(JSON.stringify(mazeGrid))    // Deep copy the maze grid\n    nodeList.forEach(node => nodeMazeGrid[node[0]][node[1]] = \"node\")\n\n    const nodeWeights = weightFinder(nodeMazeGrid, nodeList)\n\n    return [nodeAnimations, nodeWeights]\n}\n\nconst weightFinder = (nodeMazeGrid, nodeList) => { // Finds weights for building an edge graph of the maze\n    const nodeWeights = {};\n    nodeList.forEach(node => {\n        const [row, col] = [node[0], node[1]];\n        const nodeDirections = []\n        const directions = node[2]\n        directions.forEach(direction => {\n            let i = 1;\n\n\n            switch (direction) {\n                case 0: // Up\n                    while (row - i >= 0 && nodeMazeGrid[row - i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 1: // Right\n                    while (col + i < nodeMazeGrid[row].length && nodeMazeGrid[row][col + i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 2: // Down\n                    while (row + i < nodeMazeGrid.length && nodeMazeGrid[row + i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 3: // Left\n                    while (col - i >= 0 && nodeMazeGrid[row][col - i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n            }\n        })\n        nodeWeights[`${row},${col}`] = nodeDirections\n    })\n    return nodeWeights;\n}\n\nconst shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\n\n// Maze-solving algorithms:\n\nexport const solveMaze = (grid, defaults, algorithm) => {\n    const newGrid = JSON.parse(JSON.stringify(grid)); // Deep copy of grid\n    const animations = { solvingAnimations: [], backtrackingAnimations: [] };\n\n    let solvingAlgorithm = dijkstrasSolvingAlgorithm\n    switch (algorithm) {\n        case \"depthFirst\":\n            solvingAlgorithm = depthFirstSearchSolvingAlgorithm;\n            break;\n        case \"breadthFirst\":\n            solvingAlgorithm = breadthFirstSearchSolvingAlgorithm\n            break;\n        case \"dijkstra's\":\n            solvingAlgorithm = dijkstrasSolvingAlgorithm\n            break;\n        case \"a-star\":\n            solvingAlgorithm = aStarSolvingAlgorithm\n            break;\n    }\n\n    solvingAlgorithm(defaults.start, defaults.enter, defaults.exit, newGrid, animations)\n    return animations\n}\n\nconst depthFirstSearchSolvingAlgorithm = (startNode, prevNode, endNode, newGrid, animations) => {\n    const node = startNode;\n\n    if ((node[0] === endNode[0]) && (node[1] === endNode[1])) {\n        animations.backtrackingAnimations.push(node)\n        animations.backtrackingAnimations.push(prevNode)\n        return true\n    }\n\n    let mazeEndFound = false;\n    const [row, col] = node;\n    newGrid[row][col] = \"checked\";\n    animations.solvingAnimations.push(node)\n\n    const directionArray = shuffle([...Array(4).keys()]);\n    for (let i = 0; i < 4; i++) {\n\n        const direction = directionArray[i]\n\n        switch (direction) {\n\n            case 0: // Up: checks if 2 squares up is not over edge and there is a path toward that direction\n                if ((row - 1 >= 0) && (newGrid[row - 1][col] === \"path\")) {\n                    const newNode = [row - 1, col];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n\n                }\n                break;\n            case 1: // Right: checks if 2 squares right is not over edge and there is a path toward that direction\n                if ((col + 1 < newGrid[row].length) && (newGrid[row][col + 1] === \"path\")) {\n                    const newNode = [row, col + 1];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n                }\n                break;\n            case 2: // Down: checks if 2 squares down is not over edge and there is a path toward that direction\n                if ((row + 1 < newGrid.length) && (newGrid[row + 1][col] === \"path\")) {\n                    const newNode = [row + 1, col];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n                }\n                break;\n            case 3: // Left: checks if 2 squares left is not over edge and there is a path toward that direction\n                if ((col - 1 >= 0) && (newGrid[row][col - 1] === \"path\")) {\n                    const newNode = [row, col - 1];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n                }\n                break;\n\n        }\n        if (mazeEndFound) {\n            animations.backtrackingAnimations.push(prevNode)\n            return mazeEndFound\n        }\n\n    }\n    return mazeEndFound\n\n}\n\nconst breadthFirstSearchSolvingAlgorithm = (startNode, prevNode, endNode, newGrid, animations) => {\n\n    const frontierQueue = [];\n    const backtrackDictionary = {};\n    frontierQueue.push(prevNode);\n    let checking = true;\n\n\n    const breadthFirstRecursion = (frontierQueue, endNode, newGrid, animations, backtrackDictionary) => {\n        const node = frontierQueue.shift();\n\n        if (node[0] === endNode[0] && node[1] === endNode[1]) return false\n\n        animations.solvingAnimations.push(node);\n\n        const [row, col] = [node[0], node[1]];\n        newGrid[row][col] = \"checked\";\n\n        for (let i = 0; i < 4; i++) {\n            const direction = i;\n\n            switch (direction) {\n\n                case 0: // Up: checks if 2 squares up is not over edge and there is a path toward that direction\n                    if ((row - 1 >= 0) && (newGrid[row - 1][col] === \"path\")) {\n                        const newNode = [row - 1, col];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n                case 1: // Right: checks if 2 squares right is not over edge and there is a path toward that direction\n                    if ((col + 1 < newGrid[row].length) && (newGrid[row][col + 1] === \"path\")) {\n                        const newNode = [row, col + 1];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n                case 2: // Down: checks if 2 squares down is not over edge and there is a path toward that direction\n                    if ((row + 1 < newGrid.length) && (newGrid[row + 1][col] === \"path\")) {\n                        const newNode = [row + 1, col];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n                case 3: // Left: checks if 2 squares left is not over edge and there is a path toward that direction\n                    if ((col - 1 >= 0) && (newGrid[row][col - 1] === \"path\")) {\n                        const newNode = [row, col - 1];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n            }\n        }\n        return (frontierQueue.length > 0)\n    }\n\n    while (checking) {\n        checking = breadthFirstRecursion(frontierQueue, endNode, newGrid, animations, backtrackDictionary);\n    }\n\n    let btNode = endNode;\n    animations.backtrackingAnimations.push(btNode);\n    while (!((btNode[0] === startNode[0]) && (btNode[1] === startNode[1]))) {\n        const dictionaryString = `${btNode[0]},${btNode[1]}`;\n        btNode = backtrackDictionary[dictionaryString]\n        animations.backtrackingAnimations.push(btNode);\n    }\n\n}\n\nconst nodeAndWeightFinder = (mazeGrid, baseNode) => { // Finds nodes, points at which the maze either turns or forks, and their corresponding weights to the base node\n    const nodeAndWeightList = []; // List of nodes with the location and directions of nearest nodes \n    const [row, col] = baseNode;\n    \n    for (let direction = 0; direction < 4; direction++) {\n        \n        let counter = 1;\n        let node;\n        switch (direction) {\n            case 0:\n                if (baseNode[0] - counter >= 0 && mazeGrid[baseNode[0] - counter][baseNode[1]] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0] - counter, baseNode[1]])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n            case 1:\n                if (baseNode[1] + counter < mazeGrid[0].length && mazeGrid[baseNode[0]][baseNode[1] + counter] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0], baseNode[1] + counter])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n            case 2:\n                if (baseNode[0] + counter < mazeGrid.length && mazeGrid[baseNode[0] + counter][baseNode[1]] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0] + counter, baseNode[1]])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n            case 3:\n                if (baseNode[1] - counter >= 0 && mazeGrid[baseNode[0]][baseNode[1] - counter] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0], baseNode[1] - counter])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n        }\n    }\n    \n    return nodeAndWeightList\n}\n\nconst isANode = (mazeGrid, node) => { // Checks if selected location is a node or not\n    // Scans four directions and \n    const [row, col] = node;\n    \n    const directions = [];\n    if (row > 0 && mazeGrid[row - 1][col] === \"path\") { // Up\n        directions.push(0)\n    } \n    if (col < mazeGrid[0].length - 1 && mazeGrid[row][col + 1] === \"path\") { // Right\n        directions.push(1)\n    } \n    if (row < mazeGrid.length - 1 && mazeGrid[row + 1][col] === \"path\") { // Down\n        directions.push(2)\n    } \n    if (col > 0 && mazeGrid[row][col - 1] === \"path\") { // Left\n        directions.push(3)\n    }\n    \n    if (directions.length === 1 || directions.length > 2 || (directions[0] - directions[1]) % 2 !== 0) { \n        // Is either a dead end or a t-junction/4-way or a corner \n        return true\n    }\n\n    return false\n}\n\n\nconst dijkstrasSolvingAlgorithm = (startNode, enterNode, exitNode, mazeGrid, animations, heuristic = false) => {\n    const lowestUnvisitedNode = (distances, visitedNodes) => {\n        let min = [null, Infinity];\n        Object.entries(distances).forEach((distance) => {\n            const currentDistanceStr = distance[0];\n            if (!visitedNodes[currentDistanceStr] && distances[currentDistanceStr] < min[1]) {\n                min = [currentDistanceStr, distance[1]];\n            }\n        })\n\n        return (min[0] === null) ? null : min[0].split(\",\");\n    }\n\n    // Initialize distances dictionary for start and end nodes\n    const distances = {};\n    distances[`${enterNode[0]},${enterNode[1]}`] = 0;\n    distances[`${exitNode[0]},${exitNode[1]}`] = Infinity;\n\n    // Initialize parent nodes dictionary\n    const parentNodes = {};\n    parentNodes[`${exitNode[0]},${exitNode[1]}`] = null;\n\n    // Initialize arrays for visited and unvisited nodes\n    const visitedNodes = {};\n    let unvisitedNodes = nodeAndWeightFinder(mazeGrid, enterNode)\n    \n    let currentNode = enterNode;\n    animations.solvingAnimations.push([enterNode])\n    while (currentNode !== null && (currentNode[0] !== exitNode[0] && currentNode[1] !== exitNode[1])) { // Exits if out of nodes or at end\n        console.log(\"loop\")\n        // Converts back from string to number\n        const [row, col] = [Number(currentNode[0]), Number(currentNode[1])];\n        animations.solvingAnimations.push([row, col])\n\n        const currentNodeStr = `${row},${col}` // String for node currently looking at, for lookup in dictionary\n        const currentDistance = distances[currentNodeStr]; // Distance of current node from start\n        unvisitedNodes = nodeAndWeightFinder(mazeGrid, [row, col]) // Find weights of all attached nodes, meaning distances from current node\n        unvisitedNodes.forEach((edge) => { // Cycle through all nearest nodes\n            const [direction, edgeDistance] = [edge[0], edge[1]] // Direction and distance/weight to that direction\n            let childNode, childNodeStr, totalWeight;\n            let hWeight = 0; // Additional heuristic weight, for use in A*\n            const distanceFromStart = currentDistance + edgeDistance\n\n            switch (direction) {\n                case 0: //Up\n                    // Make new node and node string\n                    childNode = [row - edgeDistance, col];  \n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0; \n                    totalWeight = distanceFromStart + hWeight\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                case 1: //Right\n                    // Make new node and node string\n                    childNode = [row, col + edgeDistance];\n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0;\n                    totalWeight = distanceFromStart + hWeight;\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                case 2: //Down\n                    // Make new node and node string\n                    childNode = [row + edgeDistance, col];\n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0;\n                    totalWeight = distanceFromStart + hWeight;\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                case 3: //Left\n                    // Make new node and node string\n                    childNode = [row, col - edgeDistance];\n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0;\n                    totalWeight = distanceFromStart + hWeight;\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        })\n\n        visitedNodes[currentNodeStr] = unvisitedNodes;\n        currentNode = lowestUnvisitedNode(distances, visitedNodes)\n    }\n\n    if (currentNode === null || (currentNode[0] === exitNode[0] && currentNode[1] === exitNode[1])) {\n        let backtrackNode = exitNode;\n        animations.backtrackingAnimations.push(backtrackNode)\n\n        while (backtrackNode[0] !== enterNode[0] && backtrackNode[1] !== enterNode[1]) {\n            const newNodeStrArray = parentNodes[`${backtrackNode[0]},${backtrackNode[1]}`].split(\",\")\n            backtrackNode = [Number(newNodeStrArray[0]), newNodeStrArray[1]]\n            animations.backtrackingAnimations.push(backtrackNode)\n\n        }\n    }\n}\n\nconst aStarSolvingAlgorithm = (startNode, enterNode, exitNode, mazeGrid, animations) => {\n    dijkstrasSolvingAlgorithm(startNode, enterNode, exitNode, mazeGrid, animations, true)\n}","// Animations\n\nexport const animateMazeDrawing = (mazeAnimations, canvas, cellSize) => {\n    const ctx = canvas.current.getContext('2d');\n\n    let counter = 0;\n    let stepId;\n    function drawPath() {\n        if (mazeAnimations.drawingAnimations.length !== 0) {\n\n            for (let i = 0; i < 725; i++) {\n                if (counter < mazeAnimations.drawingAnimations.length) {\n                    const animation = mazeAnimations.drawingAnimations[counter];\n                    const [row, col] = animation;\n                    ctx.clearRect(col * cellSize, row * cellSize, cellSize, cellSize);\n                    counter++\n                }\n            }\n\n            stepId = window.requestAnimationFrame(drawPath);\n            \n\n        }\n    }\n    const play = () => {\n        window.requestAnimationFrame(drawPath)\n    }\n\n    const stop = () => {\n        cancelAnimationFrame(stepId)\n        return stepId\n    }\n\n    play()\n\n}\n\n    // if (mazeAnimations.nodeAnimations.length !== 0) {\n    //     mazeAnimations.nodeAnimations.forEach((animation, index) => {\n    //         setTimeout(() => {\n    //             const [row, col] = animation;\n    //             ctx.fillStyle = \"#ff0000\"\n    //             ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n    //         }, drawSpeed * mazeAnimations.drawingAnimations.length + drawSpeed * index); // Set a delay based on the time to finish the drawing animation, before drawing the nodes\n    //     })\n    // }\n\n\nexport const animateMazeSolving = (solvingAnimations, canvas, cellSize, drawSpeed) => {\n    const ctx = canvas.current.getContext('2d');\n\n    if (solvingAnimations !== []) {\n\n        solvingAnimations.forEach((animation, index) => {\n            setTimeout(() => {\n                ctx.fillStyle = \"#ff0000\"\n                const [row, col] = animation;\n                ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n            }, drawSpeed * index);\n        })\n\n    }\n}\n\nexport const animateMazeSolvingBacktrack = (backtrackingAnimations, canvas, cellSize, drawSpeed, delay) => {\n    const ctx = canvas.current.getContext('2d');\n\n    if (backtrackingAnimations !== []) {\n\n        backtrackingAnimations.forEach((animation, index) => {\n            setTimeout(() => {\n                ctx.fillStyle = \"#fcf000\"\n                const [row, col] = animation;\n                ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n            }, delay + drawSpeed * index);\n        })\n\n    }\n}","import React, { useState, useEffect, useRef } from 'react';\nimport { initializeGrid, generateMaze, clearCanvas, fillCanvas } from './PathfindingFunctions/mazeGeneratingFunctions.js';\nimport { solveMaze, nodeFinder } from './PathfindingFunctions/mazeSolvingFunctions.js';\nimport { animateMazeDrawing, animateMazeSolving, animateMazeSolvingBacktrack } from './PathfindingFunctions/mazeAnimatingFunctions.js';\n\n\nconst Pathfinding = () => {\n    const canvas = useRef(null);\n    const [cellSize, setCellSize] = useState(10) // Fix this so that it's set with number of cells, not sizee !!!!\n    const [canvasDimensions, setCanvasDimensions] = useState({width: cellSize*51, height: cellSize*51, x: 0, y: 0}) //FIX SO THAT SET PROGRAMMATICALLY\n    const [grid, setGrid] = useState([])\n    const [mazeAnimations, setMazeAnimations] = useState({ drawingAnimations: [], nodeAnimations: [] })\n    const [solvingAnimations, setSolvingAnimations] = useState([])\n    const [drawSpeed, setDrawSpeed] = useState(0)\n    const [mazeGenAlgo, setMazeGenAlgo] = useState(\"eller's\")\n    const [mazeSolveAlgo, setMazeSolveAlgo] = useState(\"depthFirst\")\n\n    useEffect(() => {\n        const [initialGrid, x, y] = initializeGrid(canvas, cellSize, canvasDimensions)\n        console.log(window.innerHeight);\n        \n        setGrid(initialGrid)\n        setCanvasDimensions({\n            ...canvasDimensions,\n            x,\n            y\n        })\n\n    }, [])\n\n    \n    \n\n    // Get all algorithms to work on the non-maze board\n    // Once finished, fix up website and prepare for deployment\n\n    // Possible add-ons\n        // Pixelpainting descrambler\n        // Other maze-building algos - Hunt & kill, sidewinder, prims, kruskal, ellers\n        // Other algorithms - \n            // Pathfinding - best first search\n            // Sorting Heap Sort\n        // More animations - \n            //Pathfinding - show red backtrack and removal for backtracking building algo, current node highlighted in green, path in rainbow colors, show nodes of node graph and connnxns, make a binary search tree and animate it being built\n            // Sorting - \n        // More functionality \n            //Pathfinding - can go forwards and reverse, adjust number of loops, adjust size, adjust speed, reset maze solve or build, make it possible to skip animations, random wall generation, A* draws the optimal path, Dijkstra draws the optimal path?\n\n    \n\n    const [mazeGenerating, setMazeGenerating] = useState(false)\n\n    useEffect(() => {\n        \n        if(mazeGenerating) {\n            const fillGrid = fillCanvas(canvas, cellSize)\n\n            const [mazeGrid, animations, mazeFinished] = generateMaze(fillGrid, mazeGenAlgo)\n\n            setMazeAnimations(animations)\n            setGrid(mazeGrid)\n            if (mazeFinished) {\n                setMazeGenerating(false)\n            }\n\n        }\n    }, [mazeGenerating])\n\n\n\n    const [backtrackingAnimations, setBacktrackingAnimations] = useState([])\n    \n\n    const [mazeSolving, setMazeSolving] = useState(false)\n    useEffect(() => {\n        if (mazeSolving) {\n            const defaults = { enter: [0, 1], exit: [grid.length - 1, grid[0].length - 2], start: [1, 1] };\n            const animations = solveMaze(grid, defaults, mazeSolveAlgo)\n            console.log(\"maze done\");\n            \n            setSolvingAnimations(animations.solvingAnimations)\n            setBacktrackingAnimations(animations.backtrackingAnimations)\n            setMazeSolving(false)\n        }\n        \n    }, [mazeSolving, grid])\n\n\n    \n\n    useEffect(() => {\n        const test = animateMazeDrawing(mazeAnimations, canvas, cellSize, drawSpeed);\n        console.log(test);\n        \n    }, [mazeAnimations]);\n\n\n    \n\n    useEffect(() => {\n        animateMazeSolving(solvingAnimations, canvas, cellSize, drawSpeed)\n    }, [ solvingAnimations]);\n\n    \n\n    useEffect(() => {\n        const delay = solvingAnimations.length * drawSpeed;\n        animateMazeSolvingBacktrack(backtrackingAnimations, canvas, cellSize, drawSpeed, delay)\n    }, [backtrackingAnimations]);\n    \n    const handleOnClick = (e) => {\n        \n        const [row, col] = [Math.floor((e.clientY - canvasDimensions.y) / cellSize), Math.floor((e.clientX - canvasDimensions.x + .5) / cellSize)];\n        \n        const newGrid = [...grid];\n\n        const ctx = canvas.current.getContext('2d');\n        if (grid[row][col] !== \"wall\") {\n            ctx.fillStyle = \"#444\";\n            ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n        } else {\n            ctx.clearRect(col * cellSize, row * cellSize, cellSize, cellSize);\n        }\n\n        newGrid[row][col] = (newGrid[row][col] === \"wall\") ? \"wall\" : \"path\"\n        setGrid(newGrid)\n    };\n\n\n    const [mouseDown, setMouseDown] = useState(false)\n    const [fillType, setFillType] = useState(\"wall\")\n    const handleMouseDown = (e) => {\n        setMouseDown(true)\n        console.log(e);\n        const [row, col] = [Math.floor((e.clientY - canvasDimensions.y) / cellSize), Math.floor((e.clientX - canvasDimensions.x + .5) / cellSize)];\n        setFillType((grid[row][col] === \"wall\") ? \"path\" : \"wall\")\n    }\n\n    const handleMouseUp = (e) => {\n        setMouseDown(false)\n    }\n\n    const handleMouseOut = (e) => {\n        setMouseDown(false)\n    }\n\n    const handleMouseMove = (e) => {\n        if (mouseDown) {\n            const [row, col] = [Math.floor((e.clientY - canvasDimensions.y) / cellSize), Math.floor((e.clientX - canvasDimensions.x + .5) / cellSize)];\n\n            const newGrid = [...grid];\n\n            const ctx = canvas.current.getContext('2d');\n            if (fillType === \"wall\") {\n                ctx.fillStyle = \"#444\";\n                ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n                newGrid[row][col] = \"wall\";\n            } else {\n                ctx.clearRect(col * cellSize, row * cellSize, cellSize, cellSize);\n                newGrid[row][col] = \"path\";\n            }\n\n            setGrid(newGrid)\n        }\n    }\n\n    const handleClearCanvas = () => {\n        const clearGrid = clearCanvas(canvas, cellSize)\n        setGrid(clearGrid)\n    }\n\n    const handleFillCanvas = () => {\n        const fillGrid = fillCanvas(canvas, cellSize)\n        setGrid(fillGrid)\n    }\n\n    \n    return (\n        <div>\n            <div className=\"nav-bar\">\n                <div className=\"gen-algo-bar\">\n                    <button onClick={() => setMazeGenAlgo(\"eller's\")}>Eller's</button>\n                    <button onClick={() => setMazeGenAlgo(\"depthFirst\")}>Depth First</button>\n                </div>\n                <div className=\"gen-algo-bar\">\n                    <button onClick={() => setMazeSolveAlgo(\"depthFirst\")}>Depth First</button>\n                    <button onClick={() => setMazeSolveAlgo(\"breadthFirst\")}>Breadth First</button>\n                    <button onClick={() => setMazeSolveAlgo(\"dijkstra's\")}>Dijkstra's</button>\n                    <button onClick={() => setMazeSolveAlgo(\"a-star\")}>A-star</button>\n                </div>\n                <div className=\"sliders-bar\">\n                    <input onChange=\"\" type=\"range\" min=\"1\" max=\"100\" value=\"50\" class=\"slider\" id=\"myRange\"></input>\n                </div>\n            </div>\n            <div id=\"canvas\">\n                <button onClick={handleClearCanvas}>Clear</button>\n                <button onClick={handleFillCanvas}>Fill</button>\n                <canvas onClick={handleOnClick} onMouseDown={handleMouseDown} onMouseUp={handleMouseUp} onMouseOut={handleMouseOut} onMouseMove={handleMouseMove} ref={canvas}></canvas>\n                <button onClick={() => setMazeGenerating(true)}>Generate Maze</button>\n                <button onClick={() => setMazeSolving(true)}>Solve Maze</button>\n                <button onClick ={() => animateMazeDrawing.play()}>Play</button>\n            </div>\n        </div>\n    )\n}\n\nexport default Pathfinding;\n","import React from 'react';\n\nimport './app.css';\n\nimport Sorting from './Sorting';\nimport Pathfinding from './Pathfinding'\n\nconst App = () => {\n    return (\n        <div className=\"page\">\n            {/* <Sorting/> */}\n            <Pathfinding />\n        </div>\n    )\n};\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n    <App/> , document.getElementById('root')\n);\n\n"],"sourceRoot":""}