{"version":3,"sources":["Sorting/BarChart/Bar.js","Sorting/utilities/index.js","Sorting/BarChart/index.js","Sorting/ColorMap/ColorBar.js","Sorting/utilities/colorBarFunctions.js","Sorting/ColorMap/index.js","Sorting/PixelMap/PixelBar.js","Sorting/utilities/pixelMapFunctions.js","Sorting/PixelMap/index.js","Sorting/index.js","Pathfinding/PathfindingFunctions/mazeGeneratingFunctions.js","Pathfinding/PathfindingFunctions/mazeSolvingFunctions.js","Pathfinding/PathfindingFunctions/mazeAnimatingFunctions.js","Pathfinding/index.js","App.js","index.js"],"names":["Bar","height","barStyle","className","style","defaultSort","defaultAnimations","bubbleSort","origArr","arr","animations","n","length","i","j","push","bubbleSortBarChartAnimation","chart","document","getElementsByClassName","barAnimations","forEach","animation","index","bar1","bar2","ht1","ht2","animation1","animate","backgroundColor","duration","delay","animation2","fill","animation3","animation4","selectionSort","minIndex","swap","selectionSortBarChartAnimation","console","log","baseChild","checkingChild","minChild","baseHeight","minHeight","insertionSort","insertionSortBarChartAnimation","swapElLt","swapElLtHt","swapElRt","swapElRtHt","mergeSort","origArray","mainArray","auxArray","mergeSortHelper","startIdx","endIdx","midIdx","Math","floor","merge","k","comparison","range","mergeSortBarChartAnimation","compareEl1","compareEl2","swapEl","swapHt","quickSort","array","partition","left","right","pivot","quickSortHelper","quickSortBarChartAnimation","leftEl","rightEl","leftHt","rightHt","barChartRadixSort","countBuckets","max","toString","l","stringNum","d","shift","counter","num","radixSortBarChartAnimation","element","BarChart","sort","useState","bars","barList","bar","barHeight","random","barShuffle","setAnimations","function","sortType","setSortType","animationType","setAnimationType","useEffect","cancelAnimations","buildAnimations","map","cancel","barIndex","key","onClick","playState","play","playAnimations","pause","pauseAnimations","ColorBar","color","colorBarStyle","colorMapBubbleSort","colorMapBubbleSortAnimation","swapColor1","swapColor2","colorMapSelectionSortAnimation","baseColor","minColor","colorMapInsertionSortAnimation","swapElLtColor","swapElRtColor","colorMapMergeSortAnimation","swapColor","colorMapQuickSortAnimation","leftColor","rightColor","radixSort","colorMapRadixSortAnimation","ColorMap","colorList","hueValue","colorShuffle","colors","runAnimations","colorAnimations","colorIndex","PixelBar","heights","firstSegmentStyle","secondSegmentStyle","thirdSegmentStyle","pixelBarShuffle","pixelBarList","pixBar","pixelBarHeights","shuffle","pixelMapBubbleSortAnimation","compareEl1Bottom","childNodes","compareEl1Top","compareEl2Bottom","compareEl2Top","swapHt1Top","swapHt1Bottom","swapHt2Top","swapHt2Bottom","pixelMapSelectionSort","pixelMapSelectionSortAnimation","baseChildTop","baseChildBottom","minChildTop","minChildBottom","baseTopHeight","baseBottomHeight","minTopHeight","minBottomHeight","pixelMapInsertionSort","pixelMapInsertionSortAnimation","swapElLtTop","swapElLtBottom","swapElLtTopHeight","swapElLtBottomHeight","swapElRtTop","swapElRtBottom","swapElRtTopHeight","swapElRtBottomHeight","pixelMapMergeSort","pixelMapMergeSortAnimation","swapElTop","swapElBottom","swapTopHeight","swapBottomHeight","pixelMapQuickSort","pixelMapQuickSortAnimation","leftElTop","leftElBottom","rightElTop","rightElBottom","leftTopHeight","leftBottomHeight","rightTopHeight","rightBottomHeight","pixelMapRadixSort","numArr","pixelMapRadixSortAnimation","elementTop","elementBottom","heightTop","heightBottom","PixelMap","pixelBars","barHeights","Sorting","setSort","Nav","Item","Link","to","path","clearCanvas","canvas","cellSize","ctx","current","getContext","width","clearRect","cols","rows","clearGrid","row","col","fillCanvas","fillStyle","fillRect","fillGrid","ellersMazeAlgorithm","startNode","prevNode","origMazeGrid","mazeGrid","JSON","parse","stringify","setNoCounter","undefined","placeHolder","setNo","setCounter","extensionNo","extensionCounter","extensionColumn","pathMazeGrid","depthFirstMazeAlgorithm","node","prevRow","prevCol","newAnimations","directionArray","Array","keys","nodeFinder","entrance","exit","nodeAnimations","nodeList","directions","direction","nodeMazeGrid","weightFinder","nodeWeights","nodeDirections","depthFirstSearchSolvingAlgorithm","endNode","newGrid","backtrackingAnimations","mazeEndFound","solvingAnimations","newNode","breadthFirstSearchSolvingAlgorithm","frontierQueue","backtrackDictionary","checking","breadthFirstRecursion","btNode","nodeAndWeightFinder","baseNode","nodeAndWeightList","isANode","dijkstrasSolvingAlgorithm","enterNode","exitNode","heuristic","lowestUnvisitedNode","distances","visitedNodes","min","Infinity","Object","entries","distance","currentDistanceStr","split","parentNodes","unvisitedNodes","currentNode","Number","currentNodeStr","currentDistance","edge","childNode","childNodeStr","totalWeight","edgeDistance","distanceFromStart","backtrackNode","newNodeStrArray","aStarSolvingAlgorithm","animateMazeDrawing","mazeAnimations","drawPath","drawingAnimations","window","requestAnimationFrame","Pathfinding","useRef","x","y","canvasDimensions","setCanvasDimensions","grid","setGrid","setMazeAnimations","setSolvingAnimations","drawSpeed","mazeGenAlgo","setMazeGenAlgo","mazeSolveAlgo","setMazeSolveAlgo","initialGrid","getBoundingClientRect","initializeGrid","innerHeight","mazeGenerating","setMazeGenerating","algorithm","mazeFinished","start","mazeAlgorithm","generateMaze","setBacktrackingAnimations","mazeSolving","setMazeSolving","defaults","enter","solvingAlgorithm","solveMaze","test","setTimeout","animateMazeSolving","animateMazeSolvingBacktrack","mouseDown","setMouseDown","fillType","setFillType","onChange","type","value","class","id","e","clientY","clientX","onMouseDown","onMouseUp","onMouseOut","onMouseMove","ref","App","activeKey","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.03f3bc94.chunk.js","sourcesContent":["import React from 'react';\n\nconst Bar = ({ height }) => {\n    \n    const barHeightinPercent = height/10;\n    const barStyle = {\n        height: `${barHeightinPercent}%`\n    }\n    \n    return (\n        <div className=\"bar\" style={barStyle}></div>\n    )\n}\n\nexport default Bar;","import $ from 'jquery';\n\n// ***Sort Functions***\n\nexport const defaultSort = () => {\n    return []\n}\n\nexport const defaultAnimations = () => {\n    return []\n}\n\n// Bubble Sort\nexport const bubbleSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n                animations.push([[j, arr[j+1]], [j + 1, arr[j]]])\n            }\n        }\n        \n    }\n    return animations\n}\n\nexport const bubbleSortBarChartAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const bar1 = chart[animation[0][0]];\n        const bar2 = chart[animation[1][0]];\n        const ht1 = `${animation[0][1] / 10}%`\n        const ht2 = `${animation[1][1] / 10}%`\n        \n\n        // Highlight the two elements to be swapped, and swap their heights\n        // Default as paused so they don't start automatically every time\n        const animation1 = bar1.animate([{backgroundColor: 'rgb(51, 226, 217)'}, {backgroundColor: 'red'}], {duration: duration, delay: index * duration});\n        const animation2 = bar1.animate([{ height: ht2 }, { height: ht2 }], { fill: \"forwards\", duration: duration, delay: index * duration });\n        const animation3 = bar2.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration });\n        const animation4 = bar2.animate([{ height: ht1 }, { height: ht1 }], { fill: \"forwards\", duration: duration, delay: index * duration });\n\n        // Save animations for reuse\n        barAnimations.push(\n            animation1, animation2, animation3, animation4\n        )\n    })\n\n    return barAnimations\n}\n\n// Selection Sort \nexport const selectionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        let minIndex = i;\n        for (let j = i; j < n; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j\n            }\n            // Checks if sort has reached the end of Array, if so, records that there will be a swap between i and min\n            let swap = false;\n            if (j === n - 1) {\n                swap = true;\n            }\n            // Push the base Element, the element being checked, the current minimum, and an indication of whether a swap has occurred\n            animations.push([[i, arr[i]], [j, arr[j]], [minIndex, arr[minIndex]], swap])\n        }\n        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n    return animations\n}\n\n\nexport const selectionSortBarChartAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 3;// The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n    console.log(('a'));\n    \n    animations.forEach((animation, index) => {\n        const baseChild = chart[animation[0][0]];\n        const checkingChild = chart[animation[1][0]];\n        const minChild = chart[animation[2][0]];\n        const baseHeight = `${animation[0][1] / 10}%`\n        const minHeight = `${animation[2][1] / 10}%`\n        const swap = animation[3];\n\n        // Highlight the base of the section being checked, and the current element being compared against the minimum, in bubbleSort, while the min is highlighted in red\n        barAnimations.push(\n            baseChild.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'blue' }], { duration: duration, delay: index * duration }),\n            checkingChild.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'blue' }], { duration: duration, delay: index * duration }),\n            minChild.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration }),\n        )\n        // if the two elements are to be swapped, perform the swap \n        if (swap === true) {\n            barAnimations.push(\n                minChild.animate([{ height: baseHeight }, { height: baseHeight }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChild.animate([{ height: minHeight }, { height: minHeight }], { fill: \"forwards\", duration: duration, delay: index * duration })\n            )\n        }\n    })\n\n    return barAnimations\n}\n\n// Insertion Sort \nexport const insertionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n\n\n    // Move up through the array one at a time, and insert each new element into already sorted numbers to the left in its proper (ascending) position \n    for (let i = 1; i < n; i++) {\n        const key = arr[i]\n        let j = i - 1;\n        while (j >= 0 && arr[j] > arr[j+1]) {\n            animations.push([[j, arr[j]], [j+1, arr[j+1]]]);\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            j = j - 1\n        }\n    }\n    \n    return animations\n}\n\n\nexport const insertionSortBarChartAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElLt = chart[animation[0][0]];\n        const swapElLtHt = `${animation[0][1] / 10}%`;\n        const swapElRt = chart[animation[1][0]];\n        const swapElRtHt = `${animation[1][1] / 10}%`;\n        \n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElRt.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            swapElRt.animate([{ height: swapElLtHt }, { height: swapElLtHt }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElLt.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            swapElLt.animate([{ height: swapElRtHt }, { height: swapElRtHt }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n    \n    return barAnimations\n}\n\n\n// Merge Sort \nexport const mergeSort = (origArray) => {\n    // Two separate arrays, one main one and one to hold swapped values until they can be unswapped. Avoids having to create a buffer array during the sorting process\n    const mainArray = [...origArray];\n    const auxArray = [...mainArray]\n    const n = mainArray.length\n    const animations = [];\n    if (n <= 1) {\n        return mainArray\n    }\n    // Initialize first function call\n    mergeSortHelper(mainArray, 0, n - 1, auxArray, animations);\n    // console.log(\"main\", mainArray, \"aux\", auxArray);;\n\n    return animations;\n}\n\nconst mergeSortHelper = (mainArray, startIdx, endIdx, auxArray, animations) => {\n    // Base case, returns if only one element in array\n    if (startIdx === endIdx) return;\n\n    // Find middle index of array, place to split before coming merge\n    const midIdx = Math.floor((startIdx + endIdx) / 2);\n\n    // recursively call function on each half of the array, to keep splitting until base case of 1 is reached. Also, notice that auxArray and mainArray are swapped from initial function call; it's complicated but basically this allows the aux array and main array to keep switching back and forth and save the values from the previous merge, which means that I don't have to create a temporary array to hold the values\n    mergeSortHelper(auxArray, startIdx, midIdx, mainArray, animations);\n    mergeSortHelper(auxArray, midIdx + 1, endIdx, mainArray, animations);\n\n    // Call the merge function to sort the values and combine back together\n    merge(mainArray, startIdx, midIdx, endIdx, auxArray, animations)\n}\n\nconst merge = (mainArray, startIdx, midIdx, endIdx, auxArray, animations) => {\n    // Copies the values of the aux array into the main array, putting the next lowest value from either array at value k\n    let i = startIdx;\n    let j = midIdx + 1;\n    let k = startIdx;\n    \n    // Pick the lowest value from either array and put it into the main array\n    while (i <= midIdx && j <= endIdx) {\n        const animation = {};\n        animation.comparison = [i, j];\n        animation.range = [startIdx, endIdx]\n        if (auxArray[i] >= auxArray[j]) {\n            animation.swap = [k, auxArray[j]]\n            mainArray[k++] = auxArray[j++]\n        } else {\n            animation.swap = [k, auxArray[i]]\n            mainArray[k++] = auxArray[i++]\n        }\n        animations.push(animation);\n    }\n\n    // While there are still values in only one of the two arrays being merged, copy them in; they are already ordered from previous sorts \n    while (j <= endIdx) {\n        animations.push({\n            comparison: [j, j],\n            swap: [k, auxArray[j]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[j++]\n\n    }\n    while (i <= midIdx) {\n        animations.push({\n            comparison: [i, i],\n            swap: [k, auxArray[i]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[i++]\n    }\n}\n\nexport const mergeSortBarChartAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 30;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const compareEl1 = chart[animation.comparison[0]];\n        const compareEl2 = chart[animation.comparison[1]];\n        const swapEl = chart[animation.swap[0]];\n        const swapHt = `${animation.swap[1] / 10}%`;\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            compareEl1.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            compareEl2.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            swapEl.animate([{ height: swapHt }, { height: swapHt }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n// Quick Sort \nexport const quickSort = (origArray) => {\n    // Copy original array so as not to mutate it \n    const array = [...origArray];\n    const animations = [];\n\n    const quickSortHelper = (array, left, right, animations) => {\n        if (left >= right) return;\n\n        // Find the center index, by sorting from the two ends and so that everything to the left of the pivot is smaller, and everything right is larger\n        const index = partition(array, left, right);\n        \n        // split the array into two halves, and call recursively on the two halves \n        quickSortHelper(array, left, index - 1, animations);\n        quickSortHelper(array, index, right, animations);\n    }\n\n    const partition = (array, left, right) => {\n        // Pivot starts from right end of subarray \n        const pivot = right;\n        right--;\n        // Keep moving pointers towards middle until two pointers cross one another\n        while (left <= right) {\n            // Find a left side element smaller than pivot, and a right side one larger, and switch them \n            while (array[left] < array[pivot]) {\n                left++\n            }\n            while (array[right] > array[pivot]) {\n                right--\n            }\n            if (left <= right) {\n                animations.push([[left, array[left]], [right, array[right]], [pivot, array[pivot]]]);\n                [array[left], array[right]] = [array[right], array[left]]\n                left++\n                right--\n            }\n        }\n        // Move the pivot into the middle \n        animations.push([[left, array[left]], [pivot, array[pivot]], [pivot, array[pivot]]]);\n        [array[left], array[pivot]] = [array[pivot], array[left]]\n        return left;\n    }\n    // Initial function call \n    quickSortHelper(array, 0, array.length - 1)\n\n    return animations\n}\n\nexport const quickSortBarChartAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 30;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        \n        const leftEl = chart[animation[0][0]];\n        const rightEl = chart[animation[1][0]];\n        const pivot = chart[animation[2][0]];\n        const leftHt = `${animation[0][1] / 10}%`;\n        const rightHt = `${animation[1][1] / 10}%`;\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            leftEl.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            leftEl.animate([{ height: leftHt }, { height: rightHt }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightEl.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            rightEl.animate([{ height: rightHt }, { height: leftHt }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            pivot.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n\n// Radix Bar Sort \nexport const barChartRadixSort = (origArr) => {\n    const arr = [...origArr] // Copy original array so as not to mutate it\n    const animations = [];\n\n    // initialize an array subarrays representing numbers 0 through 9, according to their index in parent array \n    const countBuckets = [];\n    for (let i = 0; i < 10; i++) {\n        countBuckets[i] = []\n    }\n\n    let max = 0;\n    // find length of longest number by digits, by converting it to string and measuring its length, then comparing to all other numbers \n    for (let j = 0; j < arr.length; j++) {\n        max = (arr[j].toString().length > max) ? arr[j].toString().length : max;\n    }\n\n    // cycle through array once for each digit in longest number from array \n    for (let l = 0; l < max; l++) {\n\n        while (arr.length) {\n            const stringNum = arr[0].toString()  // Convert front number in array to string\n            const d = stringNum.length - l - 1 // Starting from rightmost digit on first iteration, then moving left on next iteration\n            const digit = (stringNum[d]) ? stringNum[d] : 0 // Select either that digit, or (if too short) use 0\n            countBuckets[digit].push(arr.shift()) // Remove number from array and place into bucket array corresponding to that digit\n        }\n        let counter = 0;\n        for (let i = 0; i < 10; i++) { // Cycle through all 10 counter arrays, from lowest to highest\n            while (countBuckets[i].length) {  // Cycle through counter array until empty\n                const num = countBuckets[i].shift() // Save number in variable, so it can be added both to old array and to animation\n                arr.push(num)\n                animations.push([num, counter])\n                counter++\n            }\n        }\n    }\n    return animations\n\n}\n\nexport const radixSortBarChartAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 30;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const element = chart[animation[1]];\n        const height = `${animation[0] / 10}%`;\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            element.animate([{ backgroundColor: 'red' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration }),\n            element.animate([{ height: height }, { height: height }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n\n\n// PixelMap Animations \n\n// Pixel Map Bubble Sort\nexport const pixelMapBubbleSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j][0] > arr[j + 1][0]) {\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n                animations.push([j, j + 1])\n            }\n        }\n    }\n    return animations\n}\n\n// Bubble Sort Pixel Mpa Animation\nexport const bubbleSortPixelMapAnimation = (animations, speed) => {\n    for (let i = 0; i < animations.length; i++) {\n        const [ind1, ind2] = animations[i]\n        setTimeout(() => {\n            const parent = document.getElementsByClassName('chart');\n            const child1 = parent[0].childNodes[ind1];\n            const child2 = parent[0].childNodes[ind2];\n            // console.log(child1);\n\n            // child1.style.backgroundColor = \"red\";\n            // child2.style.backgroundColor = \"red\";\n            for (let i = 0; i <= 2; i++) {\n                [child1.childNodes[i].style.height, child2.childNodes[i].style.height] = [child2.childNodes[i].style.height, child1.childNodes[i].style.height]\n\n            }\n            setTimeout(() => {\n                // child1.style.backgroundColor = \"rgb(51, 226, 217)\";\n                // child2.style.backgroundColor = \"rgb(51, 226, 217)\";\n            }, speed);\n        }, i * speed);\n    }\n}\n\n\n// ***Display Functions***\n\n// BarChart\nexport const barShuffle = (bars) => {\n    const barList = [];\n    for (let bar = 0; bar < bars; bar++) {\n        const barHeight = Math.floor(Math.random() * 1000);\n        barList.push(barHeight)\n    }\n    return barList;\n}\n\n\n// ColorMap\n\n\n\n\n\n// PixelMap\nconst shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\n\nexport const pixelBarShuffle = () => {\n    const pixelBarList = [];\n    const height = 200;\n    for (let pixBar = 0; pixBar < height; pixBar++) {\n        const pixelBarHeights = [height - pixBar - 1, 1, pixBar]\n        pixelBarList.push(pixelBarHeights)\n    }\n    return shuffle(pixelBarList)\n}\n\n\n// PixelPainting\n\n\n\n\n\n\n\n\n","import React, { useEffect, useState } from 'react';\n\nimport Bar from './Bar';\n\nimport { barShuffle, defaultSort, defaultAnimations, bubbleSort, bubbleSortBarChartAnimation, selectionSort, selectionSortBarChartAnimation, insertionSort, insertionSortBarChartAnimation, mergeSort, mergeSortBarChartAnimation, quickSort, quickSortBarChartAnimation, barChartRadixSort, radixSortBarChartAnimation } from \"../utilities\";\n\nconst BarChart = ({ sort }) => {\n    const [ bars, ] = useState(barShuffle(100));\n    const [ animations, setAnimations ] = useState([])\n    const [ sortType, setSortType ] = useState({function: defaultSort});\n    const [ animationType, setAnimationType ] = useState({ function: defaultAnimations });\n    \n    useEffect(() => {\n        switch (sort) {\n            case \"bubble\":\n                setSortType({ function: bubbleSort})\n                setAnimationType({ function: bubbleSortBarChartAnimation })\n                break;\n            case \"selection\":\n                setSortType({ function: selectionSort})\n                setAnimationType({ function: selectionSortBarChartAnimation })\n                break;\n            case \"insertion\":\n                setSortType({ function: insertionSort})\n                setAnimationType({ function: insertionSortBarChartAnimation })\n                break;\n            case \"merge\":\n                setSortType({ function: mergeSort})\n                setAnimationType({ function: mergeSortBarChartAnimation })\n                break;\n            case \"quick\":\n                setSortType({ function: quickSort})\n                setAnimationType({ function: quickSortBarChartAnimation })\n                break;\n            case \"radix\":\n                setSortType({ function: barChartRadixSort})\n                setAnimationType({ function: radixSortBarChartAnimation })\n                break;\n            case \"default\":\n                setSortType({ function: defaultSort})\n                setAnimationType({ function: defaultAnimations })\n            break;\n            }\n        }, [sort])\n\n    useEffect(() => {\n        cancelAnimations(animations);\n        buildAnimations(bars);\n        console.log(\"On one\");\n    }, [sortType])\n\n    const buildAnimations = (bars) => {\n        const barAnimations = animationType.function(sortType.function(bars));\n        setAnimations(barAnimations);\n    }\n\n    const playAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") {\n                animation.play();\n            }\n        })\n    }\n\n    const pauseAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") {\n                animation.pause();\n            }\n        })\n    }\n\n    const cancelAnimations = animations => {\n        animations.map((animation) => {\n            animation.cancel();\n        })\n    }   \n\n\n    return (\n            <div className=\"chart\">\n                {bars.map((barHeight, barIndex) => {\n                    return (\n                        <Bar key={barIndex} height={barHeight} />\n                    )\n                })}\n                <div className=\"buttons-bar\">\n                    <button onClick={() => playAnimations(animations)}>Play</button>\n                    <button onClick={() => pauseAnimations(animations)}>Pause</button>\n                </div>\n            </div>\n\n    )\n}\n\nexport default BarChart;","import React from 'react';\n\nconst ColorBar = ({ color }) => {\n\n    const colorBarStyle = {\n        backgroundColor: `hsl(${color}, 100%, 50%)`\n    }\n    // console.log(color);\n    \n    return (\n        <div className=\"color-bar\" style={colorBarStyle}></div>\n    )\n}\n\nexport default ColorBar;","// ***Sort Functions***\nexport const defaultSort = () => {\n    return []\n}\n\nexport const defaultAnimations = () => {\n    return []\n}\n\n// Generate Random Colors\nexport const colorShuffle = (bars) => {\n    const colorList = [];\n    for (let color = 0; color < bars; color++) {\n        const hueValue = Math.floor(Math.random() * 359)\n\n        colorList.push(hueValue)\n    }\n    return colorList\n}\n\n\n// ColorMap Bubble Sort\nexport const colorMapBubbleSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n\n    return animations\n}\n\n\n\n// Bubble Sort Color Map Animation\nexport const colorMapBubbleSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = .5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n    animations.forEach((animation, index) => {\n        const compareEl1 = chart[animation[0][0]];\n        const compareEl2 = chart[animation[1][0]];\n        const swapColor1 = animation[0][1];\n        const swapColor2 = animation[1][1];\n\n\n        // Exchange the colors of the two elements being selected\n        barAnimations.push(\n            compareEl1.animate([{ backgroundColor: `hsl(${swapColor2}, 100%, 50%)` }, { backgroundColor: `hsl(${swapColor2}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            compareEl2.animate([{ backgroundColor: `hsl(${swapColor1}, 100%, 50%)` }, { backgroundColor: `hsl(${swapColor1}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n\n        )\n\n    })\n    return barAnimations\n}\n\n// Selection Sort \nexport const selectionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        let minIndex = i;\n        for (let j = i; j < n; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j\n            }\n            // Checks if sort has reached the end of Array, if so, records that there will be a swap between i and min\n            let swap = false;\n            if (j === n - 1) {\n                swap = true;\n            }\n            // Push the base Element, the element being checked, the current minimum, and an indication of whether a swap has occurred\n            animations.push([[i, arr[i]], [j, arr[j]], [minIndex, arr[minIndex]], swap])\n        }\n        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n    return animations\n}\n\n\nexport const colorMapSelectionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = .5;// The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const baseChild = chart[animation[0][0]];\n        const minChild = chart[animation[2][0]];\n        const baseColor = animation[0][1]\n        const minColor = animation[2][1]\n        const swap = animation[3];\n\n        // if the two elements are to be swapped, perform the swap \n        if (swap === true) {\n            barAnimations.push(\n                minChild.animate([{ backgroundColor: `hsl(${baseColor}, 100%, 50%)` }, { backgroundColor: `hsl(${baseColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChild.animate([{ backgroundColor: `hsl(${minColor}, 100%, 50%)` }, { backgroundColor: `hsl(${minColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n            )\n        }\n    })\n\n    return barAnimations\n}\n\n// Insertion Sort \nexport const insertionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n\n\n    // Move up through the array one at a time, and insert each new element into already sorted numbers to the left in its proper (ascending) position \n    for (let i = 1; i < n; i++) {\n        const key = arr[i]\n        let j = i - 1;\n        while (j >= 0 && arr[j] > arr[j + 1]) {\n            animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            j = j - 1\n        }\n    }\n\n    return animations\n}\n\n\nexport const colorMapInsertionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElLt = chart[animation[0][0]];\n        const swapElLtColor = animation[0][1];\n        const swapElRt = chart[animation[1][0]];\n        const swapElRtColor = animation[1][1];\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElLt.animate([{ backgroundColor: `hsl(${swapElRtColor}, 100%, 50%)` }, { backgroundColor: `hsl(${swapElRtColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElRt.animate([{ backgroundColor: `hsl(${swapElLtColor}, 100%, 50%)` }, { backgroundColor: `hsl(${swapElLtColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n\n// Merge Sort \nexport const mergeSort = (origArray) => {\n    // Two separate arrays, one main one and one to hold swapped values until they can be unswapped. Avoids having to create a buffer array during the sorting process\n    const mainArray = [...origArray];\n    const auxArray = [...mainArray]\n    const n = mainArray.length\n    const animations = [];\n    if (n <= 1) {\n        return mainArray\n    }\n    // Initialize first function call\n    mergeSortHelper(mainArray, 0, n - 1, auxArray, animations);\n    // console.log(\"main\", mainArray, \"aux\", auxArray);;\n\n    return animations;\n}\n\nconst mergeSortHelper = (mainArray, startIdx, endIdx, auxArray, animations) => {\n    // Base case, returns if only one element in array\n    if (startIdx === endIdx) return;\n\n    // Find middle index of array, place to split before coming merge\n    const midIdx = Math.floor((startIdx + endIdx) / 2);\n\n    // recursively call function on each half of the array, to keep splitting until base case of 1 is reached. Also, notice that auxArray and mainArray are swapped from initial function call; it's complicated but basically this allows the aux array and main array to keep switching back and forth and save the values from the previous merge, which means that I don't have to create a temporary array to hold the values\n    mergeSortHelper(auxArray, startIdx, midIdx, mainArray, animations);\n    mergeSortHelper(auxArray, midIdx + 1, endIdx, mainArray, animations);\n\n    // Call the merge function to sort the values and combine back together\n    merge(mainArray, startIdx, midIdx, endIdx, auxArray, animations)\n}\n\nconst merge = (mainArray, startIdx, midIdx, endIdx, auxArray, animations) => {\n    // Copies the values of the aux array into the main array, putting the next lowest value from either array at value k\n    let i = startIdx;\n    let j = midIdx + 1;\n    let k = startIdx;\n\n    // Pick the lowest value from either array and put it into the main array\n    while (i <= midIdx && j <= endIdx) {\n        const animation = {};\n        animation.comparison = [i, j];\n        animation.range = [startIdx, endIdx]\n        if (auxArray[i] >= auxArray[j]) {\n            animation.swap = [k, auxArray[j]]\n            mainArray[k++] = auxArray[j++]\n        } else {\n            animation.swap = [k, auxArray[i]]\n            mainArray[k++] = auxArray[i++]\n        }\n        animations.push(animation);\n    }\n\n    // While there are still values in only one of the two arrays being merged, copy them in; they are already ordered from previous sorts \n    while (j <= endIdx) {\n        animations.push({\n            comparison: [j, j],\n            swap: [k, auxArray[j]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[j++]\n\n    }\n    while (i <= midIdx) {\n        animations.push({\n            comparison: [i, i],\n            swap: [k, auxArray[i]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[i++]\n    }\n}\n\nexport const colorMapMergeSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapEl = chart[animation.swap[0]];\n        const swapColor = animation.swap[1];\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapEl.animate([{ backgroundColor: `hsl(${swapColor}, 100%, 50%)` }, { backgroundColor: `hsl(${swapColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n        )\n    })\n\n    return barAnimations\n}\n\n// Quick Sort \nexport const quickSort = (origArray) => {\n    // Copy original array so as not to mutate it \n    const array = [...origArray];\n    const animations = [];\n\n    const quickSortHelper = (array, left, right, animations) => {\n        if (left >= right) return;\n\n        // Find the center index, by sorting from the two ends and so that everything to the left of the pivot is smaller, and everything right is larger\n        const index = partition(array, left, right);\n\n        // split the array into two halves, and call recursively on the two halves \n        quickSortHelper(array, left, index - 1, animations);\n        quickSortHelper(array, index, right, animations);\n    }\n\n    const partition = (array, left, right) => {\n        // Pivot starts from right end of subarray \n        const pivot = right;\n        right--;\n        // Keep moving pointers towards middle until two pointers cross one another\n        while (left <= right) {\n            // Find a left side element smaller than pivot, and a right side one larger, and switch them \n            while (array[left] < array[pivot]) {\n                left++\n            }\n            while (array[right] > array[pivot]) {\n                right--\n            }\n            if (left <= right) {\n                animations.push([[left, array[left]], [right, array[right]], [pivot, array[pivot]]]);\n                [array[left], array[right]] = [array[right], array[left]]\n                left++\n                right--\n            }\n        }\n        // Move the pivot into the middle \n        animations.push([[left, array[left]], [pivot, array[pivot]], [pivot, array[pivot]]]);\n        [array[left], array[pivot]] = [array[pivot], array[left]]\n        return left;\n    }\n    // Initial function call \n    quickSortHelper(array, 0, array.length - 1)\n\n    return animations\n}\n\nexport const colorMapQuickSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const leftEl = chart[animation[0][0]];\n        const rightEl = chart[animation[1][0]];\n        const leftColor = animation[0][1];\n        const rightColor = animation[1][1];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            leftEl.animate([{ backgroundColor: `hsl(${rightColor}, 100%, 50%)` }, { backgroundColor: `hsl(${rightColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightEl.animate([{ backgroundColor: `hsl(${leftColor}, 100%, 50%)` }, { backgroundColor: `hsl(${leftColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n\n// Radix Bar Sort \nexport const radixSort = (origArr) => {\n    const arr = [...origArr] // Copy original array so as not to mutate it\n    const animations = [];\n\n    // initialize an array subarrays representing numbers 0 through 9, according to their index in parent array \n    const countBuckets = [];\n    for (let i = 0; i < 10; i++) {\n        countBuckets[i] = []\n    }\n\n    let max = 0;\n    // find length of longest number by digits, by converting it to string and measuring its length, then comparing to all other numbers \n    for (let j = 0; j < arr.length; j++) {\n        max = (arr[j].toString().length > max) ? arr[j].toString().length : max;\n    }\n\n    // cycle through array once for each digit in longest number from array \n    for (let l = 0; l < max; l++) {\n\n        while (arr.length) {\n            const stringNum = arr[0].toString()  // Convert front number in array to string\n            const d = stringNum.length - l - 1 // Starting from rightmost digit on first iteration, then moving left on next iteration\n            const digit = (stringNum[d]) ? stringNum[d] : 0 // Select either that digit, or (if too short) use 0\n            countBuckets[digit].push(arr.shift()) // Remove number from array and place into bucket array corresponding to that digit\n        }\n        let counter = 0;\n        for (let i = 0; i < 10; i++) { // Cycle through all 10 counter arrays, from lowest to highest\n            while (countBuckets[i].length) {  // Cycle through counter array until empty\n                const num = countBuckets[i].shift() // Save number in variable, so it can be added both to old array and to animation\n                arr.push(num)\n                animations.push([num, counter])\n                counter++\n            }\n        }\n    }\n    return animations\n\n}\n\nexport const colorMapRadixSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const element = chart[animation[1]];\n        const color = animation[0];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            element.animate([{ backgroundColor: `hsl(${color}, 100%, 50%)` }, { backgroundColor: `hsl(${color}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n","import React, { useState, useEffect } from 'react';\nimport ColorBar from \"./ColorBar\";\nimport { colorShuffle, defaultSort, defaultAnimations, colorMapBubbleSort, colorMapBubbleSortAnimation, selectionSort, colorMapSelectionSortAnimation, insertionSort, colorMapInsertionSortAnimation, mergeSort, colorMapMergeSortAnimation, quickSort, colorMapQuickSortAnimation, radixSort, colorMapRadixSortAnimation } from '../utilities/colorBarFunctions';\n\nconst ColorMap = ({ sort }) => {\n    const [colors, ] = useState(colorShuffle(200))\n    const [animations, setAnimations] = useState([])\n    const [sortType, setSortType] = useState({ function: defaultSort });\n    const [animationType, setAnimationType] = useState({ function: defaultAnimations });\n\n    useEffect(() => {\n        switch (sort) {\n            case \"bubble\":\n                setSortType({ function: colorMapBubbleSort })\n                setAnimationType({ function: colorMapBubbleSortAnimation })\n                break;\n            case \"selection\":\n                setSortType({ function: selectionSort })\n                setAnimationType({ function: colorMapSelectionSortAnimation })\n                break;\n            case \"insertion\":\n                setSortType({ function: insertionSort })\n                setAnimationType({ function: colorMapInsertionSortAnimation })\n                break;\n            case \"merge\":\n                setSortType({ function: mergeSort })\n                setAnimationType({ function: colorMapMergeSortAnimation })\n                break;\n            case \"quick\":\n                setSortType({ function: quickSort })\n                setAnimationType({ function: colorMapQuickSortAnimation })\n                break;\n            case \"radix\":\n                setSortType({ function: radixSort })\n                setAnimationType({ function: colorMapRadixSortAnimation })\n                break;\n        }\n    }, [sort])\n\n    useEffect(() => {\n        cancelAnimations(animations)\n        runAnimations(colors)\n    }, [sortType])\n\n    const runAnimations = (colors) => {\n        const colorAnimations = animationType.function(sortType.function(colors))\n        setAnimations(colorAnimations)\n    }\n\n    const playAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") {\n                animation.play()\n            }\n        })\n    }\n\n    const pauseAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") {\n                animation.pause();\n            }\n        })\n    }\n\n    const cancelAnimations = animations => {\n        animations.map((animation) => {\n            animation.cancel()\n        })\n    }   \n    \n\n    return (\n        <div className=\"color-map\">\n            <div className=\"chart\">\n                {colors.map((color, colorIndex) => {\n                    return (\n                        <ColorBar key={colorIndex} color={color} />\n                    )\n                })}\n                <div className=\"buttons-bar\">\n                    <button onClick={() => playAnimations(animations)}>Play</button>\n                    <button onClick={() => pauseAnimations(animations)}>Pause</button>\n                </div>\n            </div>\n        </div>\n    )\n}\n\nexport default ColorMap;","import React from 'react';\n\nconst PixelBar = ({ heights }) => {\n\n    const firstSegmentStyle = {\n        height: `${3*heights[0]}px`,\n        backgroundColor: '#000'\n    }\n    const secondSegmentStyle = {\n        height: `${3*heights[1]}px`,\n        backgroundColor: '#fff)'\n    }\n    const thirdSegmentStyle = {\n        height: `${3*heights[2]}px`,\n        backgroundColor: '#000'\n    }\n\n    \n    return (\n        <div className=\"pixel-bar\">\n            <div style={firstSegmentStyle}></div>\n            <div style={secondSegmentStyle}></div>\n            <div style={thirdSegmentStyle}></div>\n        </div>\n    )\n}\n\nexport default PixelBar;","// Sorting Functions\n\nexport const defaultSort = () => {\n    return []\n}\n\nexport const defaultAnimations = () => {\n    return []\n}\n\n// Generate Random Pixel Bars\nconst shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\nexport const pixelBarShuffle = () => {\n    const height = 200;\n    const pixelBarList = [];\n    for (let pixBar = 0; pixBar < height; pixBar++) {\n        const pixelBarHeights = [pixBar, 1, height - pixBar - 1]\n        pixelBarList.push(pixelBarHeights)\n    }\n    return shuffle(pixelBarList)\n}\n\n\n// ColorMap Bubble Sort\nexport const bubbleSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j][0] > arr[j + 1][0]) {\n                animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n    \n    return animations\n}\n\n\n\n// Bubble Sort Color Map Animation\nexport const pixelMapBubbleSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = .5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n    animations.forEach((animation, index) => {\n        const compareEl1Bottom = chart[animation[0][0]].childNodes[0];\n        const compareEl1Top = chart[animation[0][0]].childNodes[2];\n        const compareEl2Bottom = chart[animation[1][0]].childNodes[0];\n        const compareEl2Top = chart[animation[1][0]].childNodes[2];\n\n        const swapHt1Top = animation[0][1][0];\n        const swapHt1Bottom = animation[0][1][2];\n\n        const swapHt2Top = animation[1][1][0];\n        const swapHt2Bottom = animation[1][1][2];\n\n        \n\n        // Exchange the colors of the two elements being selected\n        barAnimations.push(\n            compareEl1Bottom.animate([{ height: `${3 * swapHt2Bottom}px` }, { height: `${3 * swapHt2Bottom}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            compareEl1Top.animate([{ height: `${3 * swapHt2Top}px` }, { height: `${3 * swapHt2Top}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }), \n            compareEl2Bottom.animate([{ height: `${3 * swapHt1Bottom}px` }, { height: `${3 * swapHt1Bottom}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            compareEl2Top.animate([{ height: `${3 * swapHt1Top}px` }, { height: `${3 * swapHt1Top}px` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n\n    })\n    return barAnimations\n}\n\n// Selection Sort \nexport const pixelMapSelectionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        let minIndex = i;\n        for (let j = i; j < n; j++) {\n            if (arr[j][0] < arr[minIndex][0]) {\n                minIndex = j\n            }\n            // Checks if sort has reached the end of Array, if so, records that there will be a swap between i and min\n            let swap = false;\n            if (j === n - 1) {\n                swap = true;\n            }\n            // Push the base Element, the element being checked, the current minimum, and an indication of whether a swap has occurred\n            animations.push([[i, arr[i]], [j, arr[j]], [minIndex, arr[minIndex]], swap])\n        }\n        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n    \n    return animations\n}\n\n\nexport const pixelMapSelectionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = .5;// The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const baseChildTop = chart[animation[0][0]].childNodes[0];\n        const baseChildBottom = chart[animation[0][0]].childNodes[2];\n        const minChildTop = chart[animation[2][0]].childNodes[0];\n        const minChildBottom = chart[animation[2][0]].childNodes[2];\n        const baseTopHeight = animation[0][1][2];\n        const baseBottomHeight = animation[0][1][0];\n        const minTopHeight = animation[2][1][2];\n        const minBottomHeight = animation[2][1][0];\n        const swap = animation[3];\n        \n        // if the two elements are to be swapped, perform the swap \n        if (swap === true) {\n            barAnimations.push(\n                minChildTop.animate([{ height: `${3 * baseTopHeight}px` }, { height: `${3 * baseTopHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChildTop.animate([{ height: `${3 * minTopHeight}px` }, { height: `${3 * minTopHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                minChildBottom.animate([{ height: `${3 * baseBottomHeight}px` }, { height: `${3 * baseBottomHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChildBottom.animate([{ height: `${3 * minBottomHeight}px` }, { height: `${3 * minBottomHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n            )\n        }\n    })\n\n    return barAnimations\n}\n\n// Insertion Sort \nexport const pixelMapInsertionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n\n\n    // Move up through the array one at a time, and insert each new element into already sorted numbers to the left in its proper (ascending) position \n    for (let i = 1; i < n; i++) {\n        const key = arr[i]\n        let j = i - 1;\n        while (j >= 0 && arr[j][0] > arr[j + 1][0]) {\n            animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            j = j - 1\n        }\n    }\n\n    return animations\n}\n\n\nexport const pixelMapInsertionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElLtTop = chart[animation[0][0]].childNodes[0];\n        const swapElLtBottom = chart[animation[0][0]].childNodes[2];\n        const swapElLtTopHeight = animation[0][1][2];\n        const swapElLtBottomHeight = animation[0][1][0];\n        const swapElRtTop = chart[animation[1][0]].childNodes[0];\n        const swapElRtBottom = chart[animation[1][0]].childNodes[2];\n        const swapElRtTopHeight = animation[1][1][2];\n        const swapElRtBottomHeight = animation[1][1][0];\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElLtTop.animate([{ height: `${3 * swapElRtTopHeight}px` }, { height: `${3 * swapElRtTopHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElLtBottom.animate([{ height: `${3 * swapElRtBottomHeight}px` }, { height: `${3 * swapElRtBottomHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElRtTop.animate([{ height: `${3 * swapElLtTopHeight}px` }, { height: `${3 * swapElLtTopHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElRtBottom.animate([{ height: `${3 * swapElLtBottomHeight}px` }, { height: `${3 * swapElLtBottomHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n        )\n    })\n\n    return barAnimations\n}\n\n\n// Merge Sort \nexport const pixelMapMergeSort = (origArray) => {\n    // Two separate arrays, one main one and one to hold swapped values until they can be unswapped. Avoids having to create a buffer array during the sorting process\n    const mainArray = [...origArray];\n    const auxArray = [...mainArray]\n    const n = mainArray.length\n    const animations = [];\n    if (n <= 1) {\n        return mainArray\n    }\n    // Initialize first function call\n    mergeSortHelper(mainArray, 0, n - 1, auxArray, animations);\n    // console.log(\"main\", mainArray, \"aux\", auxArray);;\n    \n    return animations;\n}\n\nconst mergeSortHelper = (mainArray, startIdx, endIdx, auxArray, animations) => {\n    // Base case, returns if only one element in array\n    if (startIdx === endIdx) return;\n\n    // Find middle index of array, place to split before coming merge\n    const midIdx = Math.floor((startIdx + endIdx) / 2);\n\n    // recursively call function on each half of the array, to keep splitting until base case of 1 is reached. Also, notice that auxArray and mainArray are swapped from initial function call; it's complicated but basically this allows the aux array and main array to keep switching back and forth and save the values from the previous merge, which means that I don't have to create a temporary array to hold the values\n    mergeSortHelper(auxArray, startIdx, midIdx, mainArray, animations);\n    mergeSortHelper(auxArray, midIdx + 1, endIdx, mainArray, animations);\n\n    // Call the merge function to sort the values and combine back together\n    merge(mainArray, startIdx, midIdx, endIdx, auxArray, animations)\n}\n\nconst merge = (mainArray, startIdx, midIdx, endIdx, auxArray, animations) => {\n    // Copies the values of the aux array into the main array, putting the next lowest value from either array at value k\n    let i = startIdx;\n    let j = midIdx + 1;\n    let k = startIdx;\n\n    // Pick the lowest value from either array and put it into the main array\n    while (i <= midIdx && j <= endIdx) {\n        const animation = {};\n        animation.comparison = [i, j];\n        animation.range = [startIdx, endIdx]\n        if (auxArray[i][0] >= auxArray[j][0]) {\n            animation.swap = [k, auxArray[j]]\n            mainArray[k++] = auxArray[j++]\n        } else {\n            animation.swap = [k, auxArray[i]]\n            mainArray[k++] = auxArray[i++]\n        }\n        animations.push(animation);\n    }\n\n    // While there are still values in only one of the two arrays being merged, copy them in; they are already ordered from previous sorts \n    while (j <= endIdx) {\n        animations.push({\n            comparison: [j, j],\n            swap: [k, auxArray[j]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[j++]\n\n    }\n    while (i <= midIdx) {\n        animations.push({\n            comparison: [i, i],\n            swap: [k, auxArray[i]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[i++]\n    }\n}\n\nexport const pixelMapMergeSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElTop = chart[animation.swap[0]].childNodes[0];\n        const swapElBottom = chart[animation.swap[0]].childNodes[2];\n\n        const swapTopHeight = animation.swap[1][2];\n        const swapBottomHeight = animation.swap[1][0];\n\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElTop.animate([{ height: `${3 * swapTopHeight}px` }, { height: `${3 * swapTopHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElBottom.animate([{ height: `${3 * swapBottomHeight}px` }, { height: `${3 * swapBottomHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n        )\n    })\n\n    return barAnimations\n}\n\n// Quick Sort \nexport const pixelMapQuickSort = (origArray) => {\n    // Copy original array so as not to mutate it \n    const array = [...origArray];\n    const animations = [];\n\n    const quickSortHelper = (array, left, right, animations) => {\n        if (left >= right) return;\n\n        // Find the center index, by sorting from the two ends and so that everything to the left of the pivot is smaller, and everything right is larger\n        const index = partition(array, left, right);\n\n        // split the array into two halves, and call recursively on the two halves \n        quickSortHelper(array, left, index - 1, animations);\n        quickSortHelper(array, index, right, animations);\n    }\n\n    const partition = (array, left, right) => {\n        // Pivot starts from right end of subarray \n        const pivot = right;\n        right--;\n        // Keep moving pointers towards middle until two pointers cross one another\n        while (left <= right) {\n            // Find a left side element smaller than pivot, and a right side one larger, and switch them \n            while (array[left][2] < array[pivot][2]) {\n                left++\n            }\n            while (array[right][2] > array[pivot][2]) {\n                right--\n            }\n            if (left <= right) {\n                animations.push([[left, array[left]], [right, array[right]], [pivot, array[pivot]]]);\n                [array[left], array[right]] = [array[right], array[left]]\n                left++\n                right--\n            }\n        }\n        // Move the pivot into the middle \n        animations.push([[left, array[left]], [pivot, array[pivot]], [pivot, array[pivot]]]);\n        [array[left], array[pivot]] = [array[pivot], array[left]]\n        return left;\n    }\n    // Initial function call \n    quickSortHelper(array, 0, array.length - 1)\n    \n    return animations\n}\n\nexport const pixelMapQuickSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const leftElTop = chart[animation[0][0]].childNodes[0];\n        const leftElBottom = chart[animation[0][0]].childNodes[2];\n        const rightElTop = chart[animation[1][0]].childNodes[0];\n        const rightElBottom = chart[animation[1][0]].childNodes[2];\n        const leftTopHeight = animation[0][1][0];\n        const leftBottomHeight = animation[0][1][2];\n        const rightTopHeight = animation[1][1][0];\n        const rightBottomHeight = animation[1][1][2];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            leftElTop.animate([{ height: `${3 * rightTopHeight}px` }, { height: `${3 * rightTopHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            leftElBottom.animate([{ height: `${3 * rightBottomHeight}px` }, { height: `${3 * rightBottomHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightElTop.animate([{ height: `${3 * leftTopHeight}px` }, { height: `${3 * leftTopHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightElBottom.animate([{ height: `${3 * leftBottomHeight}px` }, { height: `${3 * leftBottomHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n\n// Radix Bar Sort \nexport const pixelMapRadixSort = (origArr) => {\n    const arr = [...origArr] // Copy original array so as not to mutate it\n    const animations = [];\n\n    // initialize an array subarrays representing numbers 0 through 9, according to their index in parent array \n    const countBuckets = [];\n    for (let i = 0; i < 10; i++) {\n        countBuckets[i] = []\n    }\n\n    let max = 0;\n    // find length of longest number by digits, by converting it to string and measuring its length, then comparing to all other numbers \n    for (let j = 0; j < arr.length; j++) {\n        max = (arr[j].toString().length > max) ? arr[j].toString().length : max;\n    }\n\n    // cycle through array once for each digit in longest number from array \n    for (let l = 0; l < max; l++) {\n\n        while (arr.length) {\n            const stringNum = arr[0][0].toString()  // Convert front number in array to string\n            const d = stringNum.length - l - 1 // Starting from rightmost digit on first iteration, then moving left on next iteration\n            const digit = (stringNum[d]) ? stringNum[d] : 0 // Select either that digit, or (if too short) use 0\n            countBuckets[digit].push(arr.shift()) // Remove number from array and place into bucket array corresponding to that digit\n        }\n        let counter = 0;\n        for (let i = 0; i < 10; i++) { // Cycle through all 10 counter arrays, from lowest to highest\n            while (countBuckets[i].length) {  // Cycle through counter array until empty\n                const numArr = countBuckets[i].shift() // Save number in variable, so it can be added both to old array and to animation\n                arr.push(numArr)\n                animations.push([numArr, counter])\n                counter++\n            }\n        }\n    }\n    \n    return animations\n\n}\n\nexport const pixelMapRadixSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const elementTop = chart[animation[1]].childNodes[0];\n        const elementBottom = chart[animation[1]].childNodes[2];\n        const heightTop = animation[0][2];\n        const heightBottom = animation[0][0];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            elementTop.animate([{ height: `${3 * heightTop}px` }, { height: `${3 * heightTop}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            elementBottom.animate([{ height: `${3 * heightBottom}px` }, { height: `${3 * heightBottom}px` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n","import React, { useState, useEffect } from 'react';\nimport PixelBar from \"./PixelBar\";\nimport { pixelBarShuffle, defaultSort, defaultAnimations, bubbleSort, pixelMapBubbleSortAnimation, pixelMapSelectionSort, pixelMapSelectionSortAnimation, pixelMapInsertionSort, pixelMapInsertionSortAnimation, pixelMapMergeSort, pixelMapMergeSortAnimation, pixelMapQuickSort, pixelMapQuickSortAnimation, pixelMapRadixSort, pixelMapRadixSortAnimation } from \"../utilities/pixelMapFunctions\";\n\nconst PixelMap = ({ sort }) => {\n    const [pixelBars, ] = useState(pixelBarShuffle())\n    const [animations, setAnimations] = useState([])\n    const [sortType, setSortType] = useState({ function: defaultSort });\n    const [animationType, setAnimationType] = useState({ function: defaultAnimations });\n    \n    useEffect(() => {\n        switch (sort) {\n            case \"bubble\":\n                setSortType({ function: bubbleSort })\n                setAnimationType({ function: pixelMapBubbleSortAnimation })\n                break;\n            case \"selection\":\n                setSortType({ function: pixelMapSelectionSort })\n                setAnimationType({ function: pixelMapSelectionSortAnimation })\n                break;\n            case \"insertion\":\n                setSortType({ function: pixelMapInsertionSort })\n                setAnimationType({ function: pixelMapInsertionSortAnimation })\n                break;\n            case \"merge\":\n                setSortType({ function: pixelMapMergeSort })\n                setAnimationType({ function: pixelMapMergeSortAnimation })\n                break;\n            case \"quick\":\n                setSortType({ function: pixelMapQuickSort })\n                setAnimationType({ function: pixelMapQuickSortAnimation })\n                break;\n            case \"radix\":\n                setSortType({ function: pixelMapRadixSort })\n                setAnimationType({ function: pixelMapRadixSortAnimation })\n                break;\n        }\n    }, [sort])\n\n    useEffect(() => {\n        cancelAnimations(animations)\n        runAnimations(pixelBars)\n        \n    }, [sortType])\n\n\n\n\n    const runAnimations = (pixelBars) => {\n        const barAnimations = animationType.function(sortType.function(pixelBars))\n        setAnimations(barAnimations)\n    }\n\n    const playAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") {\n                animation.play()\n            }\n        })\n    }\n\n    const pauseAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") {\n                animation.pause();\n            }\n        })\n    }\n\n    const cancelAnimations = animations => {\n        animations.map((animation) => {\n            animation.cancel()\n        })\n    }   \n    \n\n    return (\n        <div className=\"pixel-map\">\n            <div className=\"chart\">\n                {pixelBars.map((barHeights, barIndex) => {\n                    return (\n                        <PixelBar key={barIndex} heights={barHeights} />\n                    )\n                })}\n                <div className=\"buttons-bar\">\n                    <button onClick={() => playAnimations(animations)}>Play</button>\n                    <button onClick={() => pauseAnimations(animations)}>Pause</button>\n                </div>\n            </div>\n        </div>\n    )\n}\n\nexport default PixelMap;","import React, {useState} from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link } from 'react-router-dom';\n\nimport Nav from 'react-bootstrap/Nav';\n\nimport BarChart from './BarChart';\nimport ColorMap from './ColorMap';\nimport PixelMap from './PixelMap';\n// import PixelPainting from './PixelPainting';\n\nconst Sorting = () => {  \n    \n    const [sort, setSort] = useState(\"default\")\n\n\n    return (\n\n        <Router>\n            <Nav className=\"nav-bar\">\n                <Nav.Item>\n                    <Nav.Link>\n                        <Link to=\"/barchart\">Bar Chart</Link>\n                    </Nav.Link>\n                </Nav.Item>\n\n                <Nav.Item>\n                    <Nav.Link>\n                        <Link to=\"/colormap\">Color Map</Link>\n                    </Nav.Link>\n                </Nav.Item>\n\n                <Nav.Item>\n                    <Nav.Link>\n                        <Link to=\"/pixelmap\">Bar Pixel</Link>\n                    </Nav.Link>\n                </Nav.Item>\n                <div>\n\n                    <ul className=\"sort-types\">\n                        <li onClick={() => setSort(\"bubble\")}>\n                            bubble\n                        </li>\n                        <li onClick={() => setSort(\"selection\")}>\n                            selection\n                        </li>\n                        <li onClick={() => setSort(\"insertion\")}>\n                            insertion\n                        </li>\n                        <li onClick={() => setSort(\"merge\")}>\n                            merge\n                        </li>\n                        <li onClick={() => setSort(\"quick\")}>\n                            quick\n                        </li>\n                        <li onClick={() => setSort(\"radix\")}>\n                            radix\n                        </li>\n                    </ul>\n                </div>\n            </Nav>\n\n            <Switch>\n                <Route path=\"/barchart\">\n                    <BarChart sort={sort} />\n                </Route>\n                <Route path=\"/colormap\">\n                    <ColorMap sort={sort} />\n                </Route>\n                <Route path=\"/pixelmap\">\n                    <PixelMap sort={sort} />\n                </Route>\n                {/* <Route path=\"/pixelpainting\">\n                    <PixelPainting/>\n                </Route> */}\n            </Switch>\n        </Router>\n\n    )\n}\n\nexport default Sorting;\n\n// // All\n// Top bar? What does it say\n// // Sorting\n// Buttons ugly, use bootstrap\n// Shouldn't auto-play on switching sort types\n// Reset should be a totally different layout each timers\n// Needs back button\n// Picture sorting not working (low priority)\n// // Maze\n// Mazes should generate when button press\n// Mazes should solve when button press\n// Black board should generate on load\n// Solving again should reset to uncolored maze\n// Can't adjust maze size\n// Draw maze more slowly? Maybe a bar\n// Bars need to be labelled\n// Need a back button\n// Buttons ugly, use bootstrap\n// Center the thing on the page","// Draw initial Grid\nexport const initializeGrid = (canvas, cellSize, canvasDimensions) => {\n\n    const ctx = canvas.current.getContext('2d');\n    const [width, height] = [canvasDimensions.width, canvasDimensions.height]\n\n    // Initialize Background\n    ctx.canvas.width = width;\n    ctx.canvas.height = height;\n\n    // Initialize Grid as Clear\n    const initialGrid = clearCanvas(canvas, cellSize)\n    \n    // Find x and y coordinates of canvas\n    const [xCoordinate, yCoordinate] = [canvas.current.getBoundingClientRect().x, canvas.current.getBoundingClientRect().y]\n\n    return [initialGrid, xCoordinate, yCoordinate]\n\n\n\n}\n\nexport const clearCanvas = (canvas, cellSize) => {\n    const ctx = canvas.current.getContext('2d');\n    const [width, height] = [ctx.canvas.width, ctx.canvas.height]\n    \n    // Clear Background\n    ctx.clearRect(0, 0, width, height);\n\n    // Construct Grid of Cells\n    const [cols, rows] = [width / cellSize, height / cellSize];\n    \n    const clearGrid = [];\n    // Builds a rows*cols nested array full of walls\n    for (let row = 0; row < rows; row++) {\n        clearGrid.push([])\n        for (let col = 0; col < cols; col++) {\n            clearGrid[row].push(\"path\")\n        }\n    }\n    return clearGrid\n}\n\nexport const fillCanvas = (canvas, cellSize) => {\n    const ctx = canvas.current.getContext('2d');\n    const [width, height] = [ctx.canvas.width, ctx.canvas.height]\n\n    // Fill Background\n    ctx.fillStyle = \"#444\";\n    ctx.fillRect(0, 0, width, height);\n\n    // Construct Grid of Cells\n    const [cols, rows] = [width / cellSize, height / cellSize]\n    const fillGrid = [];\n    // Builds a rows*cols nested array full of walls\n    for (let row = 0; row < rows; row++) {\n        fillGrid.push([])\n        for (let col = 0; col < cols; col++) {\n            fillGrid[row].push(\"wall\")\n        }\n    }\n    return fillGrid\n}\n\n// Generate initial maze\nexport const generateMaze = (grid, algorithm) => {\n\n    // Number of total columns and total rows\n\n    let mazeGrid = JSON.parse(JSON.stringify(grid)); // Deep copy grid so as not to mutate\n    const [rows, cols] = [mazeGrid.length, mazeGrid[0].length]\n\n    // Animate drawing the entrance and exit\n    const [entrance, exit, start] = [[0, 1], [mazeGrid.length - 1, mazeGrid[0].length - 2], [1, 1]]\n    let drawingAnimations = [entrance, exit];\n\n    // Add entrance and exit to state, and to grid\n    mazeGrid[entrance[0]][entrance[1]] = \"path\";\n    mazeGrid[exit[0]][exit[1]] = \"path\";\n\n    // Calls with start as current and previous node; this is to allow for previous node to be used in recursive call\n    let mazeFinished;\n\n    let mazeAlgorithm = ellersMazeAlgorithm\n    switch (algorithm) {\n        case \"eller's\":\n            mazeAlgorithm = ellersMazeAlgorithm\n            break;\n        case \"depthFirst\":\n            mazeAlgorithm = depthFirstMazeAlgorithm\n            break;\n    }\n\n    [mazeGrid, drawingAnimations, mazeFinished] = mazeAlgorithm(start, start, mazeGrid, drawingAnimations)\n    \n    // Add a set number of loops to the maze\n    // const loops = 200;\n    // [mazeGrid, drawingAnimations] = loopMaker(mazeGrid, drawingAnimations, loops);\n\n    const [nodeAnimations, trash] = nodeFinder(mazeGrid, entrance, exit)\n\n    const mazeAnimations = { drawingAnimations: drawingAnimations, nodeAnimations: nodeAnimations }\n\n    return [mazeGrid, mazeAnimations, mazeFinished]\n}\n\nconst shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\nconst ellersMazeAlgorithm = (startNode, prevNode, origMazeGrid, animations) => {\n\n    const mazeGrid = JSON.parse(JSON.stringify(origMazeGrid)) // Deep copy so as not to mutate original array\n\n    let setNoCounter = 1; // To keep track of set names, so there's no repeats\n    for (let i = 1; i < mazeGrid[1].length - 1; i += 2) {\n        mazeGrid[1][i] = setNoCounter; // Initialize the cells of the first row to each exist in their own set.\n        animations.push([1,i])\n        setNoCounter++;\n    }\n\n    for (let j = 1; j < mazeGrid.length - 2; j += 2) {  // Repeat until the last row is reached\n        \n        for (let i = 1; i < mazeGrid[j].length - 1; i += 2) {// Randomly join adjacent cells, but only if they are not in the same set.\n            if (mazeGrid[j][i+2] !== undefined && mazeGrid[j][i] !== mazeGrid[j][i + 2]) {\n                if (Math.random() < .5) { // Some of the cells joined together, so left side and right of wall must match\n                    mazeGrid[j][i + 1] = mazeGrid[j][i];\n                    mazeGrid[j][i + 2] = mazeGrid[j][i];\n                    animations.push([j, i+1])\n                }\n            }\n        }\n        \n        let placeHolder = 1;\n        while (placeHolder < mazeGrid[j].length ) {// For each set, randomly create vertical connections downward to the next row\n            \n            const setNo = mazeGrid[j][placeHolder] // Number stored in grid for current set\n            let setCounter = 1;\n            while (mazeGrid[j][placeHolder + setCounter * 2] === setNo) { // Counts how many in a row have the same setNo\n                setCounter += 1\n            }\n            \n            // For each set, randomly create a random number (1+) of vertical connections downward to the next row.\n            const extensionNo = 1 + Math.floor(Math.random() * setCounter) * .5;\n            let extensionCounter = 0;\n            while (extensionCounter < extensionNo) {  // Keeps cycling until correct number of columns are created\n                const extensionColumn = Math.floor(Math.random() * setCounter) * 2;\n                if (mazeGrid[j + 1][placeHolder + extensionColumn] === \"wall\") {\n                    mazeGrid[j + 1][placeHolder + extensionColumn] = setNo;\n                    animations.push([j + 1, placeHolder + extensionColumn]);\n                    mazeGrid[j + 2][placeHolder + extensionColumn] = setNo;\n                    animations.push([j + 2, placeHolder + extensionColumn]);\n                    extensionCounter ++\n                }\n            } // Consecutive columns are linked together in next section\n\n            \n\n            placeHolder += setCounter*2; // Moves to the next set\n        }\n        \n        for (let l = 1; l < mazeGrid[j].length - 1; l += 2) { \n            if (mazeGrid[j + 2][l] === \"wall\") {// Flesh out the next row by putting any remaining cells into their own sets.\n                mazeGrid[j + 2][l] = setNoCounter;\n                animations.push([j + 2, l])\n                setNoCounter++\n            } \n        }\n    }\n    for (let i = 1; i < mazeGrid[0].length - 2; i+=2) { //For the last row, join all adjacent cells that do not share a set\n        if (mazeGrid[mazeGrid.length - 2][i] !== mazeGrid[mazeGrid.length - 2][i + 2]) {\n            mazeGrid[mazeGrid.length - 2][i + 1] = mazeGrid[mazeGrid.length - 2][i];\n            animations.push([mazeGrid.length - 2, i + 1]);\n            mazeGrid[mazeGrid.length - 2][i + 2] = mazeGrid[mazeGrid.length - 2][i];\n            animations.push([mazeGrid.length - 2, i + 2]);\n        }\n    }\n\n    const pathMazeGrid = []\n    for (let i = 0; i < mazeGrid.length; i++) {\n        const row = [];\n        for (let j = 0; j < mazeGrid[i].length; j++) {\n            if (mazeGrid[i][j] !== \"wall\") {\n                row.push(\"path\")\n            } else {\n                row.push(\"wall\")\n            }\n        }\n        pathMazeGrid.push(row)\n    }\n    \n\n    \n    return [pathMazeGrid, animations, true]\n    \n}\n\nconst depthFirstMazeAlgorithm = (startNode, prevNode, mazeGrid, animations) => {\n    // Draws maze using recursive depth-first algorithm\n    const node = startNode;\n\n    const [row, col] = node;\n\n    mazeGrid[row][col] = \"path\";\n    const [prevRow, prevCol] = prevNode\n    mazeGrid[prevRow][prevCol] = \"path\";\n    let deadEnd = false;\n\n    let newAnimations = [...animations, prevNode, node] // Add current node to path animation\n    const directionArray = shuffle([...Array(4).keys()]); // Create a random array of directions to choose from\n    for (let i = 0; i < 4; i++) {  // Choose the next direction to go in, or return dead end\n        const direction = directionArray[i]\n        switch (direction) {\n            case 0: // Up: if potential path column above is not edge or filled\n                if (((row - 2) >= 0) && (mazeGrid[row - 2][col] === \"wall\")) {\n                    const [midNode, newNode] = [[row - 1, col], [row - 2, col]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n            case 1: // Right: if two squares to the right is not over edge or filled\n                if (((col + 2) < mazeGrid[row].length) && (mazeGrid[row][col + 2] === \"wall\")) {\n                    const [midNode, newNode] = [[row, col + 1], [row, col + 2]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n            case 2: // Down: if potential path column below is not edge or filled\n\n                if (((row + 2) < mazeGrid.length) && (mazeGrid[row + 2][col] === \"wall\")) {\n                    const [midNode, newNode] = [[row + 1, col], [row + 2, col]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n            case 3: // Left: if two squares to the left is not over edge or filled\n                if (((col - 2) >= 0) && (mazeGrid[row][col - 2] === \"wall\")) {\n                    const [midNode, newNode] = [[row, col - 1], [row, col - 2]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n        }\n    }\n    deadEnd = true\n    return [mazeGrid, newAnimations, deadEnd]\n}\n\nconst loopMaker = (mazeGrid, mazeAnimations, loopsRequired) => {\n    let loopsMade = 0;\n    while (loopsMade < loopsRequired) {\n        // Not selecting the bottom 20 % of the maze makes loops more likely to form\n        // Only selects numbers between 1 and 80% of mazeGrid length\n        const randRow = Math.floor(Math.random() * (mazeGrid.length * .8 - 1)) + 1\n        // Select any column except for first and last\n        const randCol = Math.floor(Math.random() * (mazeGrid[0].length - 2)) + 1\n        if ( // Forms loops better by only choosing walls sandwiched between two other walls, but not 3 ways corners\n            mazeGrid[randRow][randCol] === \"wall\"\n            && (\n                (mazeGrid[randRow + 1][randCol] === \"wall\" && mazeGrid[randRow - 1][randCol] === \"wall\" && mazeGrid[randRow][randCol + 1] !== \"wall\" && mazeGrid[randRow][randCol - 1] !== \"wall\") ||\n                (mazeGrid[randRow][randCol + 1] === \"wall\" && mazeGrid[randRow][randCol - 1] === \"wall\" && mazeGrid[randRow + 1][randCol] !== \"wall\" && mazeGrid[randRow - 1][randCol] !== \"wall\")\n            )\n        ) {\n            mazeGrid[randRow][randCol] = \"path\"\n            mazeAnimations.push([randRow, randCol])\n            loopsMade++\n        }\n    }\n\n    return [mazeGrid, mazeAnimations]\n}\n\nexport const nodeFinder = (mazeGrid, entrance, exit) => { // Finds nodes, points at which the maze either turns or forks, for use in building graphs\n    const nodeAnimations = [];\n    const nodeList = []; // List of nodes with the location and directions of nearest nodes\n\n    // Add the start of the maze to the animations\n    nodeAnimations.push(entrance)\n\n    nodeList.push([...entrance, [2]])\n\n    for (let row = 1; row < mazeGrid.length - 1; row++) { // Cycles through rows and columns, searching for nodes in each odd row/col\n        for (let col = 1; col < mazeGrid[0].length - 1; col++) {\n            const directions = [];\n            for (let direction = 0; direction < 4; direction++) {\n\n                switch (direction) {\n                    case 0:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row - 1][col] === \"path\") { // Up: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 1:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col + 1] === \"path\") { // Right: if potential path column right is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 2:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row + 1][col] === \"path\") { // Down: if potential path column down is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 3:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col - 1] === \"path\") { // Left: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                }\n            }\n            if (directions.length === 1) { // If dead end, corner, or intersection\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 2 && (directions[0] - directions[1]) % 2 !== 0) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 3 || directions.length === 4) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            }\n\n        }\n    }\n    // Add the end of the maze to the animations\n    nodeAnimations.push(exit)\n    nodeList.push([...exit, [0]])\n\n    const nodeMazeGrid = JSON.parse(JSON.stringify(mazeGrid))    // Deep copy the maze grid\n    nodeList.forEach(node => nodeMazeGrid[node[0]][node[1]] = \"node\")\n\n    const nodeWeights = weightFinder(nodeMazeGrid, nodeList)\n\n    return [nodeAnimations, nodeWeights]\n}\n\nconst weightFinder = (nodeMazeGrid, nodeList) => {\n    const nodeWeights = {};\n    nodeList.forEach(node => {\n        const [row, col] = [node[0], node[1]];\n        const nodeDirections = []\n        const directions = node[2]\n        directions.forEach(direction => {\n            let i = 1;\n\n\n            switch (direction) {\n                case 0: // Up\n                    while (row - i >= 0 && nodeMazeGrid[row - i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 1: // Right\n                    while (col + i < nodeMazeGrid[row].length && nodeMazeGrid[row][col + i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 2: // Down\n                    while (row + i < nodeMazeGrid.length && nodeMazeGrid[row + i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 3: // Left\n                    while (col - i >= 0 && nodeMazeGrid[row][col - i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n            }\n        })\n        nodeWeights[`${row},${col}`] = nodeDirections\n    })\n    return nodeWeights;\n}\n","export const nodeFinder = (mazeGrid, entrance, exit) => { // Finds nodes, points at which the maze either turns or forks, for use in building graphs\n    const nodeAnimations = [];\n    const nodeList = []; // List of nodes with the location and directions of nearest nodes\n\n    // Add the start of the maze to the animations\n    nodeAnimations.push(entrance)\n\n    nodeList.push([...entrance, [2]])\n\n    for (let row = 1; row < mazeGrid.length - 1; row++) { // Cycles through rows and columns, searching for nodes in each odd row/col\n        for (let col = 1; col < mazeGrid[0].length - 1; col++) {\n            const directions = [];\n            for (let direction = 0; direction < 4; direction++) {\n\n                switch (direction) {\n                    case 0:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row - 1][col] === \"path\") { // Up: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 1:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col + 1] === \"path\") { // Right: if potential path column right is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 2:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row + 1][col] === \"path\") { // Down: if potential path column down is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 3:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col - 1] === \"path\") { // Left: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                }\n            }\n            if (directions.length === 1) { // If dead end, corner, or intersection\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 2 && (directions[0] - directions[1]) % 2 !== 0) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 3 || directions.length === 4) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            }\n\n        }\n    }\n    // Add the end of the maze to the animations\n    nodeAnimations.push(exit)\n    nodeList.push([...exit, [0]])\n\n    const nodeMazeGrid = JSON.parse(JSON.stringify(mazeGrid))    // Deep copy the maze grid\n    nodeList.forEach(node => nodeMazeGrid[node[0]][node[1]] = \"node\")\n\n    const nodeWeights = weightFinder(nodeMazeGrid, nodeList)\n\n    return [nodeAnimations, nodeWeights]\n}\n\nconst weightFinder = (nodeMazeGrid, nodeList) => { // Finds weights for building an edge graph of the maze\n    const nodeWeights = {};\n    nodeList.forEach(node => {\n        const [row, col] = [node[0], node[1]];\n        const nodeDirections = []\n        const directions = node[2]\n        directions.forEach(direction => {\n            let i = 1;\n\n\n            switch (direction) {\n                case 0: // Up\n                    while (row - i >= 0 && nodeMazeGrid[row - i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 1: // Right\n                    while (col + i < nodeMazeGrid[row].length && nodeMazeGrid[row][col + i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 2: // Down\n                    while (row + i < nodeMazeGrid.length && nodeMazeGrid[row + i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 3: // Left\n                    while (col - i >= 0 && nodeMazeGrid[row][col - i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n            }\n        })\n        nodeWeights[`${row},${col}`] = nodeDirections\n    })\n    return nodeWeights;\n}\n\nconst shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\n\n// Maze-solving algorithms:\n\nexport const solveMaze = (grid, defaults, algorithm) => {\n    const newGrid = JSON.parse(JSON.stringify(grid)); // Deep copy of grid\n    const animations = { solvingAnimations: [], backtrackingAnimations: [] };\n\n    let solvingAlgorithm = dijkstrasSolvingAlgorithm\n    switch (algorithm) {\n        case \"depthFirst\":\n            solvingAlgorithm = depthFirstSearchSolvingAlgorithm;\n            break;\n        case \"breadthFirst\":\n            solvingAlgorithm = breadthFirstSearchSolvingAlgorithm\n            break;\n        case \"dijkstra's\":\n            solvingAlgorithm = dijkstrasSolvingAlgorithm\n            break;\n        case \"a-star\":\n            solvingAlgorithm = aStarSolvingAlgorithm\n            break;\n    }\n\n    solvingAlgorithm(defaults.start, defaults.enter, defaults.exit, newGrid, animations)\n    return animations\n}\n\nconst depthFirstSearchSolvingAlgorithm = (startNode, prevNode, endNode, newGrid, animations) => {\n    const node = startNode;\n\n    if ((node[0] === endNode[0]) && (node[1] === endNode[1])) {\n        animations.backtrackingAnimations.push(node)\n        animations.backtrackingAnimations.push(prevNode)\n        return true\n    }\n\n    let mazeEndFound = false;\n    const [row, col] = node;\n    newGrid[row][col] = \"checked\";\n    animations.solvingAnimations.push(node)\n\n    const directionArray = shuffle([...Array(4).keys()]);\n    for (let i = 0; i < 4; i++) {\n\n        const direction = directionArray[i]\n\n        switch (direction) {\n\n            case 0: // Up: checks if 2 squares up is not over edge and there is a path toward that direction\n                if ((row - 1 >= 0) && (newGrid[row - 1][col] === \"path\")) {\n                    const newNode = [row - 1, col];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n\n                }\n                break;\n            case 1: // Right: checks if 2 squares right is not over edge and there is a path toward that direction\n                if ((col + 1 < newGrid[row].length) && (newGrid[row][col + 1] === \"path\")) {\n                    const newNode = [row, col + 1];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n                }\n                break;\n            case 2: // Down: checks if 2 squares down is not over edge and there is a path toward that direction\n                if ((row + 1 < newGrid.length) && (newGrid[row + 1][col] === \"path\")) {\n                    const newNode = [row + 1, col];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n                }\n                break;\n            case 3: // Left: checks if 2 squares left is not over edge and there is a path toward that direction\n                if ((col - 1 >= 0) && (newGrid[row][col - 1] === \"path\")) {\n                    const newNode = [row, col - 1];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n                }\n                break;\n\n        }\n        if (mazeEndFound) {\n            animations.backtrackingAnimations.push(prevNode)\n            return mazeEndFound\n        }\n\n    }\n    return mazeEndFound\n\n}\n\nconst breadthFirstSearchSolvingAlgorithm = (startNode, prevNode, endNode, newGrid, animations) => {\n\n    const frontierQueue = [];\n    const backtrackDictionary = {};\n    frontierQueue.push(prevNode);\n    let checking = true;\n\n\n    const breadthFirstRecursion = (frontierQueue, endNode, newGrid, animations, backtrackDictionary) => {\n        const node = frontierQueue.shift();\n\n        if (node[0] === endNode[0] && node[1] === endNode[1]) return false\n\n        animations.solvingAnimations.push(node);\n\n        const [row, col] = [node[0], node[1]];\n        newGrid[row][col] = \"checked\";\n\n        for (let i = 0; i < 4; i++) {\n            const direction = i;\n\n            switch (direction) {\n\n                case 0: // Up: checks if 2 squares up is not over edge and there is a path toward that direction\n                    if ((row - 1 >= 0) && (newGrid[row - 1][col] === \"path\")) {\n                        const newNode = [row - 1, col];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n                case 1: // Right: checks if 2 squares right is not over edge and there is a path toward that direction\n                    if ((col + 1 < newGrid[row].length) && (newGrid[row][col + 1] === \"path\")) {\n                        const newNode = [row, col + 1];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n                case 2: // Down: checks if 2 squares down is not over edge and there is a path toward that direction\n                    if ((row + 1 < newGrid.length) && (newGrid[row + 1][col] === \"path\")) {\n                        const newNode = [row + 1, col];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n                case 3: // Left: checks if 2 squares left is not over edge and there is a path toward that direction\n                    if ((col - 1 >= 0) && (newGrid[row][col - 1] === \"path\")) {\n                        const newNode = [row, col - 1];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n            }\n        }\n        return (frontierQueue.length > 0)\n    }\n\n    while (checking) {\n        checking = breadthFirstRecursion(frontierQueue, endNode, newGrid, animations, backtrackDictionary);\n    }\n\n    let btNode = endNode;\n    animations.backtrackingAnimations.push(btNode);\n    while (!((btNode[0] === startNode[0]) && (btNode[1] === startNode[1]))) {\n        const dictionaryString = `${btNode[0]},${btNode[1]}`;\n        btNode = backtrackDictionary[dictionaryString]\n        animations.backtrackingAnimations.push(btNode);\n    }\n\n}\n\nconst nodeAndWeightFinder = (mazeGrid, baseNode) => { // Finds nodes, points at which the maze either turns or forks, and their corresponding weights to the base node\n    const nodeAndWeightList = []; // List of nodes with the location and directions of nearest nodes \n    const [row, col] = baseNode;\n    \n    for (let direction = 0; direction < 4; direction++) {\n        \n        let counter = 1;\n        let node;\n        switch (direction) {\n            case 0:\n                if (baseNode[0] - counter >= 0 && mazeGrid[baseNode[0] - counter][baseNode[1]] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0] - counter, baseNode[1]])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n            case 1:\n                if (baseNode[1] + counter < mazeGrid[0].length && mazeGrid[baseNode[0]][baseNode[1] + counter] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0], baseNode[1] + counter])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n            case 2:\n                if (baseNode[0] + counter < mazeGrid.length && mazeGrid[baseNode[0] + counter][baseNode[1]] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0] + counter, baseNode[1]])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n            case 3:\n                if (baseNode[1] - counter >= 0 && mazeGrid[baseNode[0]][baseNode[1] - counter] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0], baseNode[1] - counter])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n        }\n    }\n    \n    return nodeAndWeightList\n}\n\nconst isANode = (mazeGrid, node) => { // Checks if selected location is a node or not\n    // Scans four directions and \n    const [row, col] = node;\n    \n    const directions = [];\n    if (row > 0 && mazeGrid[row - 1][col] === \"path\") { // Up\n        directions.push(0)\n    } \n    if (col < mazeGrid[0].length - 1 && mazeGrid[row][col + 1] === \"path\") { // Right\n        directions.push(1)\n    } \n    if (row < mazeGrid.length - 1 && mazeGrid[row + 1][col] === \"path\") { // Down\n        directions.push(2)\n    } \n    if (col > 0 && mazeGrid[row][col - 1] === \"path\") { // Left\n        directions.push(3)\n    }\n    \n    if (directions.length === 1 || directions.length > 2 || (directions[0] - directions[1]) % 2 !== 0) { \n        // Is either a dead end or a t-junction/4-way or a corner \n        return true\n    }\n\n    return false\n}\n\n\nconst dijkstrasSolvingAlgorithm = (startNode, enterNode, exitNode, mazeGrid, animations, heuristic = false) => {\n    const lowestUnvisitedNode = (distances, visitedNodes) => {\n        let min = [null, Infinity];\n        Object.entries(distances).forEach((distance) => {\n            const currentDistanceStr = distance[0];\n            if (!visitedNodes[currentDistanceStr] && distances[currentDistanceStr] < min[1]) {\n                min = [currentDistanceStr, distance[1]];\n            }\n        })\n\n        return (min[0] === null) ? null : min[0].split(\",\");\n    }\n\n    // Initialize distances dictionary for start and end nodes\n    const distances = {};\n    distances[`${enterNode[0]},${enterNode[1]}`] = 0;\n    distances[`${exitNode[0]},${exitNode[1]}`] = Infinity;\n\n    // Initialize parent nodes dictionary\n    const parentNodes = {};\n    parentNodes[`${exitNode[0]},${exitNode[1]}`] = null;\n\n    // Initialize arrays for visited and unvisited nodes\n    const visitedNodes = {};\n    let unvisitedNodes = nodeAndWeightFinder(mazeGrid, enterNode)\n    \n    let currentNode = enterNode;\n    animations.solvingAnimations.push([enterNode])\n    while (currentNode !== null && (currentNode[0] !== exitNode[0] && currentNode[1] !== exitNode[1])) { // Exits if out of nodes or at end\n        console.log(\"loop\")\n        // Converts back from string to number\n        const [row, col] = [Number(currentNode[0]), Number(currentNode[1])];\n        animations.solvingAnimations.push([row, col])\n\n        const currentNodeStr = `${row},${col}` // String for node currently looking at, for lookup in dictionary\n        const currentDistance = distances[currentNodeStr]; // Distance of current node from start\n        unvisitedNodes = nodeAndWeightFinder(mazeGrid, [row, col]) // Find weights of all attached nodes, meaning distances from current node\n        unvisitedNodes.forEach((edge) => { // Cycle through all nearest nodes\n            const [direction, edgeDistance] = [edge[0], edge[1]] // Direction and distance/weight to that direction\n            let childNode, childNodeStr, totalWeight;\n            let hWeight = 0; // Additional heuristic weight, for use in A*\n            const distanceFromStart = currentDistance + edgeDistance\n\n            switch (direction) {\n                case 0: //Up\n                    // Make new node and node string\n                    childNode = [row - edgeDistance, col];  \n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0; \n                    totalWeight = distanceFromStart + hWeight\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                case 1: //Right\n                    // Make new node and node string\n                    childNode = [row, col + edgeDistance];\n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0;\n                    totalWeight = distanceFromStart + hWeight;\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                case 2: //Down\n                    // Make new node and node string\n                    childNode = [row + edgeDistance, col];\n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0;\n                    totalWeight = distanceFromStart + hWeight;\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                case 3: //Left\n                    // Make new node and node string\n                    childNode = [row, col - edgeDistance];\n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0;\n                    totalWeight = distanceFromStart + hWeight;\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        })\n\n        visitedNodes[currentNodeStr] = unvisitedNodes;\n        currentNode = lowestUnvisitedNode(distances, visitedNodes)\n    }\n\n    if (currentNode === null || (currentNode[0] === exitNode[0] && currentNode[1] === exitNode[1])) {\n        let backtrackNode = exitNode;\n        animations.backtrackingAnimations.push(backtrackNode)\n\n        while (backtrackNode[0] !== enterNode[0] && backtrackNode[1] !== enterNode[1]) {\n            const newNodeStrArray = parentNodes[`${backtrackNode[0]},${backtrackNode[1]}`].split(\",\")\n            backtrackNode = [Number(newNodeStrArray[0]), newNodeStrArray[1]]\n            animations.backtrackingAnimations.push(backtrackNode)\n\n        }\n    }\n}\n\nconst aStarSolvingAlgorithm = (startNode, enterNode, exitNode, mazeGrid, animations) => {\n    dijkstrasSolvingAlgorithm(startNode, enterNode, exitNode, mazeGrid, animations, true)\n}","// Animations\n\nexport const animateMazeDrawing = (mazeAnimations, canvas, cellSize) => {\n    const ctx = canvas.current.getContext('2d');\n\n    let counter = 0;\n    let stepId;\n    function drawPath() {\n        if (mazeAnimations.drawingAnimations.length !== 0) {\n\n            for (let i = 0; i < 725; i++) {\n                if (counter < mazeAnimations.drawingAnimations.length) {\n                    const animation = mazeAnimations.drawingAnimations[counter];\n                    const [row, col] = animation;\n                    ctx.clearRect(col * cellSize, row * cellSize, cellSize, cellSize);\n                    counter++\n                }\n            }\n\n            stepId = window.requestAnimationFrame(drawPath);\n            \n\n        }\n    }\n    const play = () => {\n        window.requestAnimationFrame(drawPath)\n    }\n\n    const stop = () => {\n        cancelAnimationFrame(stepId)\n        return stepId\n    }\n\n    play()\n\n}\n\n    // if (mazeAnimations.nodeAnimations.length !== 0) {\n    //     mazeAnimations.nodeAnimations.forEach((animation, index) => {\n    //         setTimeout(() => {\n    //             const [row, col] = animation;\n    //             ctx.fillStyle = \"#ff0000\"\n    //             ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n    //         }, drawSpeed * mazeAnimations.drawingAnimations.length + drawSpeed * index); // Set a delay based on the time to finish the drawing animation, before drawing the nodes\n    //     })\n    // }\n\n\nexport const animateMazeSolving = (solvingAnimations, canvas, cellSize, drawSpeed) => {\n    const ctx = canvas.current.getContext('2d');\n\n    if (solvingAnimations !== []) {\n\n        solvingAnimations.forEach((animation, index) => {\n            setTimeout(() => {\n                ctx.fillStyle = \"#ff0000\"\n                const [row, col] = animation;\n                ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n            }, drawSpeed * index);\n        })\n\n    }\n}\n\nexport const animateMazeSolvingBacktrack = (backtrackingAnimations, canvas, cellSize, drawSpeed, delay) => {\n    const ctx = canvas.current.getContext('2d');\n\n    if (backtrackingAnimations !== []) {\n\n        backtrackingAnimations.forEach((animation, index) => {\n            setTimeout(() => {\n                ctx.fillStyle = \"#fcf000\"\n                const [row, col] = animation;\n                ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n            }, delay + drawSpeed * index);\n        })\n\n    }\n}","import React, { useState, useEffect, useRef } from 'react';\nimport { initializeGrid, generateMaze, clearCanvas, fillCanvas } from './PathfindingFunctions/mazeGeneratingFunctions.js';\nimport { solveMaze, nodeFinder } from './PathfindingFunctions/mazeSolvingFunctions.js';\nimport { animateMazeDrawing, animateMazeSolving, animateMazeSolvingBacktrack } from './PathfindingFunctions/mazeAnimatingFunctions.js';\n\n\nconst Pathfinding = () => {\n    const canvas = useRef(null);\n    const [cellSize, setCellSize] = useState(10) // Fix this so that it's set with number of cells, not sizee !!!!\n    const [canvasDimensions, setCanvasDimensions] = useState({width: cellSize*51, height: cellSize*51, x: 0, y: 0}) //FIX SO THAT SET PROGRAMMATICALLY\n    const [grid, setGrid] = useState([])\n    const [mazeAnimations, setMazeAnimations] = useState({ drawingAnimations: [], nodeAnimations: [] })\n    const [solvingAnimations, setSolvingAnimations] = useState([])\n    const [drawSpeed, setDrawSpeed] = useState(0)\n    const [mazeGenAlgo, setMazeGenAlgo] = useState(\"eller's\")\n    const [mazeSolveAlgo, setMazeSolveAlgo] = useState(\"depthFirst\")\n\n    useEffect(() => {\n        const [initialGrid, x, y] = initializeGrid(canvas, cellSize, canvasDimensions)\n        console.log(window.innerHeight);\n        \n        setGrid(initialGrid)\n        setCanvasDimensions({\n            ...canvasDimensions,\n            x,\n            y\n        })\n\n    }, [])\n\n    \n    \n\n    // Get all algorithms to work on the non-maze board\n    // Once finished, fix up website and prepare for deployment\n\n    // Possible add-ons\n        // Pixelpainting descrambler\n        // Other maze-building algos - Hunt & kill, sidewinder, prims, kruskal, ellers\n        // Other algorithms - \n            // Pathfinding - best first search\n            // Sorting Heap Sort\n        // More animations - \n            //Pathfinding - show red backtrack and removal for backtracking building algo, current node highlighted in green, path in rainbow colors, show nodes of node graph and connnxns, make a binary search tree and animate it being built\n            // Sorting - \n        // More functionality \n            //Pathfinding - can go forwards and reverse, adjust number of loops, adjust size, adjust speed, reset maze solve or build, make it possible to skip animations, random wall generation, A* draws the optimal path, Dijkstra draws the optimal path?\n\n    \n\n    const [mazeGenerating, setMazeGenerating] = useState(false)\n\n    useEffect(() => {\n        \n        if(mazeGenerating) {\n            const fillGrid = fillCanvas(canvas, cellSize)\n\n            const [mazeGrid, animations, mazeFinished] = generateMaze(fillGrid, mazeGenAlgo)\n\n            setMazeAnimations(animations)\n            setGrid(mazeGrid)\n            if (mazeFinished) {\n                setMazeGenerating(false)\n            }\n\n        }\n    }, [mazeGenerating])\n\n\n\n    const [backtrackingAnimations, setBacktrackingAnimations] = useState([])\n    \n\n    const [mazeSolving, setMazeSolving] = useState(false)\n    useEffect(() => {\n        if (mazeSolving) {\n            const defaults = { enter: [0, 1], exit: [grid.length - 1, grid[0].length - 2], start: [1, 1] };\n            const animations = solveMaze(grid, defaults, mazeSolveAlgo)\n            console.log(\"maze done\");\n            \n            setSolvingAnimations(animations.solvingAnimations)\n            setBacktrackingAnimations(animations.backtrackingAnimations)\n            setMazeSolving(false)\n        }\n        \n    }, [mazeSolving, grid])\n\n\n    \n\n    useEffect(() => {\n        const test = animateMazeDrawing(mazeAnimations, canvas, cellSize, drawSpeed);\n        console.log(test);\n        \n    }, [mazeAnimations]);\n\n\n    \n\n    useEffect(() => {\n        animateMazeSolving(solvingAnimations, canvas, cellSize, drawSpeed)\n    }, [ solvingAnimations]);\n\n    \n\n    useEffect(() => {\n        const delay = solvingAnimations.length * drawSpeed;\n        animateMazeSolvingBacktrack(backtrackingAnimations, canvas, cellSize, drawSpeed, delay)\n    }, [backtrackingAnimations]);\n    \n    const handleOnClick = (e) => {\n        \n        const [row, col] = [Math.floor((e.clientY - canvasDimensions.y) / cellSize), Math.floor((e.clientX - canvasDimensions.x + .5) / cellSize)];\n        \n        const newGrid = [...grid];\n\n        const ctx = canvas.current.getContext('2d');\n        if (grid[row][col] !== \"wall\") {\n            ctx.fillStyle = \"#444\";\n            ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n        } else {\n            ctx.clearRect(col * cellSize, row * cellSize, cellSize, cellSize);\n        }\n\n        newGrid[row][col] = (newGrid[row][col] === \"wall\") ? \"wall\" : \"path\"\n        setGrid(newGrid)\n    };\n\n\n    const [mouseDown, setMouseDown] = useState(false)\n    const [fillType, setFillType] = useState(\"wall\")\n    const handleMouseDown = (e) => {\n        setMouseDown(true)\n        console.log(e);\n        const [row, col] = [Math.floor((e.clientY - canvasDimensions.y) / cellSize), Math.floor((e.clientX - canvasDimensions.x + .5) / cellSize)];\n        setFillType((grid[row][col] === \"wall\") ? \"path\" : \"wall\")\n    }\n\n    const handleMouseUp = (e) => {\n        setMouseDown(false)\n    }\n\n    const handleMouseOut = (e) => {\n        setMouseDown(false)\n    }\n\n    const handleMouseMove = (e) => {\n        if (mouseDown) {\n            const [row, col] = [Math.floor((e.clientY - canvasDimensions.y) / cellSize), Math.floor((e.clientX - canvasDimensions.x + .5) / cellSize)];\n\n            const newGrid = [...grid];\n\n            const ctx = canvas.current.getContext('2d');\n            if (fillType === \"wall\") {\n                ctx.fillStyle = \"#444\";\n                ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n                newGrid[row][col] = \"wall\";\n            } else {\n                ctx.clearRect(col * cellSize, row * cellSize, cellSize, cellSize);\n                newGrid[row][col] = \"path\";\n            }\n\n            setGrid(newGrid)\n        }\n    }\n\n    const handleClearCanvas = () => {\n        const clearGrid = clearCanvas(canvas, cellSize)\n        setGrid(clearGrid)\n    }\n\n    const handleFillCanvas = () => {\n        const fillGrid = fillCanvas(canvas, cellSize)\n        setGrid(fillGrid)\n    }\n\n    \n    return (\n        <div>\n            <div className=\"nav-bar\">\n                <div className=\"gen-algo-bar\">\n                    <button onClick={() => setMazeGenAlgo(\"eller's\")}>Eller's</button>\n                    <button onClick={() => setMazeGenAlgo(\"depthFirst\")}>Depth First</button>\n                </div>\n                <div className=\"gen-algo-bar\">\n                    <button onClick={() => setMazeSolveAlgo(\"depthFirst\")}>Depth First</button>\n                    <button onClick={() => setMazeSolveAlgo(\"breadthFirst\")}>Breadth First</button>\n                    <button onClick={() => setMazeSolveAlgo(\"dijkstra's\")}>Dijkstra's</button>\n                    <button onClick={() => setMazeSolveAlgo(\"a-star\")}>A-star</button>\n                </div>\n                <div className=\"sliders-bar\">\n                    <input onChange=\"\" type=\"range\" min=\"1\" max=\"100\" value=\"50\" class=\"slider\" id=\"myRange\"></input>\n                </div>\n            </div>\n            <div id=\"canvas\">\n                <button onClick={handleClearCanvas}>Clear</button>\n                <button onClick={handleFillCanvas}>Fill</button>\n                <canvas onClick={handleOnClick} onMouseDown={handleMouseDown} onMouseUp={handleMouseUp} onMouseOut={handleMouseOut} onMouseMove={handleMouseMove} ref={canvas}></canvas>\n                <button onClick={() => setMazeGenerating(true)}>Generate Maze</button>\n                <button onClick={() => setMazeSolving(true)}>Solve Maze</button>\n                <button onClick ={() => animateMazeDrawing.play()}>Play</button>\n            </div>\n        </div>\n    )\n}\n\nexport default Pathfinding;\n","import React from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link } from 'react-router-dom';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport Nav from 'react-bootstrap/Nav';\nimport './app.css';\n\nimport Sorting from './Sorting';\nimport Pathfinding from './Pathfinding'\n\nconst App = () => {\n    return (\n        <div className=\"page\">\n             <Router>\n                <Nav activeKey=\"/main\" >\n                    <Nav.Item>\n                        <Nav.Link>\n                            <Link to=\"/\">Main</Link>\n                        </Nav.Link>\n                    </Nav.Item>\n                    <Nav.Item>\n                        <Nav.Link>\n                            <Link to=\"/sorting\">Sorting</Link>\n                        </Nav.Link>\n                    </Nav.Item>\n                    <Nav.Item>\n                        <Nav.Link>\n                            <Link to=\"/pathfinding\">Pathfinding</Link>\n                        </Nav.Link>\n                    </Nav.Item>\n                </Nav>\n\n                <Switch>\n                    <Route path=\"/sorting\">\n                        <Sorting />\n                    </Route>\n                    <Route path=\"/pathfinding\">\n                        <Pathfinding />\n                    </Route>\n                </Switch>\n            </Router>\n        </div>\n    )\n};\n\nexport default App;\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport { barChartRadixSort } from './Sorting/utilities';\n\nReactDOM.render(\n    <App/> , document.getElementById('root')\n);\n\n"],"sourceRoot":""}