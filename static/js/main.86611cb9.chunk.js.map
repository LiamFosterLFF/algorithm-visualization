{"version":3,"sources":["Components/MainPage/maze-card-image.png","Components/MainPage/sorting-card-image.png","Components/MainNavbar.js","Components/MainPage/index.js","Components/DropdownMenu.js","Components/ControlButtons.js","Components/Sorting/utilities/barChartFunctions.js","Components/Sorting/utilities/colorMapFunctions.js","Components/Sorting/utilities/pixelMapFunctions.js","Components/Sorting/utilities/index.js","Components/Sorting/BarChart/Bar.js","Components/Sorting/BarChart/index.js","Components/Sorting/ColorMap/ColorBar.js","Components/Sorting/ColorMap/index.js","Components/Sorting/PixelMap/PixelBar.js","Components/Sorting/PixelMap/index.js","Components/Sorting/index.js","Components/useCanvas.js","Components/useAnimationState.js","Components/Pathfinding/PathfindingFunctions/mazeGeneratingFunctions.js","Components/Pathfinding/PathfindingFunctions/mazeSolvingFunctions.js","Components/Slider.js","Components/Pathfinding/ControlWrapper.js","Components/Pathfinding/index.js","Components/useInterval.js","App.js","index.js"],"names":["module","exports","MainNavbar","url","location","useLocation","Navbar","Nav","variant","activeKey","pathname","Item","style","to","toLowerCase","Collapse","className","MainPage","history","useHistory","handleClick","route","push","CardDeck","Card","onClick","cursor","Img","src","sortingCardImage","Body","Title","Text","Footer","Button","mazeCardImage","DropdownMenu","props","toggleText","title","type","menuOptions","algorithms","map","option","index","Dropdown","key","select","href","Toggle","id","Menu","ControlButtons","buttons","size","ButtonGroup","button","disabled","tooltip","function","text","mergeSortHelper","mainArray","startIdx","endIdx","auxArray","animations","midIdx","Math","floor","merge","i","j","k","animation","comparison","range","swap","sortFunctions","barChart","shuffle","barList","bar","barHeight","random","defaultSort","defaultSortAnimation","bubbleSort","origArr","arr","n","length","bubbleSortAnimation","chart","document","getElementsByClassName","barAnimations","forEach","bar1","bar2","ht1","ht2","animation1","animate","backgroundColor","duration","delay","animation2","height","fill","animation3","animation4","selectionSort","minIndex","selectionSortAnimation","baseChild","checkingChild","minChild","baseHeight","minHeight","insertionSort","insertionSortAnimation","swapElLt","swapElLtHt","swapElRt","swapElRtHt","mergeSort","origArray","mergeSortAnimation","compareEl1","compareEl2","swapEl","swapHt","quickSort","array","partition","left","right","pivot","quickSortHelper","quickSortAnimation","leftEl","rightEl","leftHt","rightHt","radixSort","countBuckets","max","toString","l","stringNum","d","shift","counter","num","radixSortAnimation","element","colorMap","colorList","color","hueValue","swapColor1","swapColor2","baseColor","minColor","swapElLtColor","swapElRtColor","swapColor","leftColor","rightColor","pixelMap","pixelBarList","pixBar","pixelBarHeights","compareEl1Bottom","childNodes","compareEl1Top","compareEl2Bottom","compareEl2Top","swapHt1Top","swapHt1Bottom","swapHt2Top","swapHt2Bottom","baseChildTop","baseChildBottom","minChildTop","minChildBottom","baseTopHeight","baseBottomHeight","minTopHeight","minBottomHeight","swapElLtTop","swapElLtBottom","swapElLtTopHeight","swapElLtBottomHeight","swapElRtTop","swapElRtBottom","swapElRtTopHeight","swapElRtBottomHeight","swapElTop","swapElBottom","swapTopHeight","swapBottomHeight","leftElTop","leftElBottom","rightElTop","rightElBottom","leftTopHeight","leftBottomHeight","rightTopHeight","rightBottomHeight","numArr","elementTop","elementBottom","heightTop","heightBottom","Bar","barStyle","BarChart","bars","barIndex","ColorBar","colorBarStyle","ColorMap","colorIndex","PixelBar","heights","firstSegmentStyle","secondSegmentStyle","thirdSegmentStyle","PixelMap","barHeights","Sorting","useState","chartType","setChartType","setBars","setAnimations","sort","setSort","sortType","setSortType","animationType","setAnimationType","useEffect","cancelAnimations","formatSortFunctionName","sortText","split","restartAnimations","pauseAnimations","playState","pause","cancel","Tabs","onSelect","Tab","eventKey","play","playAnimations","calculateCanvasDimensions","cellGridDimensions","cellSize","width","cols","rows","getFilledCanvas","fillGrid","row","col","calculateCellSize","windowInnerWidth","getMouseCellLocation","mousePosition","canvasBoundingBox","getElementById","getBoundingClientRect","y","x","initializeCanvas","initialState","noOfCellsAcross","noOfCellsHigh","ceil","calculateCellDimensions","cellGridWidth","canvasDimensions","fullCanvas","cellGrid","storedMaze","isDrawing","fillType","previousPoint","canvasReducer","canvas","action","newWindowInnerWidth","payload","newCellSize","newCanvasDimensions","newFullCanvas","newCellGridDimensions","calculateCellGridDimensions","newCellGridWidth","newCellGrid","cloneDeep","flippedCellContent","isPreviousPoint","newCells","rowDiff","colDiff","maxDiff","abs","rowJump","colJump","mCol","fullCellGrid","clearCellGrid","getClearedCanvas","Error","animationStateReducer","animationState","animationStack","playingAnimations","canvasUpdateFunction","resetFunction","solvingAnimations","backtrackingAnimations","animationSpeed","defaultMazeAlgorithm","startNode","prevNode","origMazeGrid","ellersMazeAlgorithm","mazeGrid","JSON","parse","stringify","setNoCounter","undefined","placeHolder","setNo","setCounter","extensionNo","extensionCounter","extensionColumn","pathMazeGrid","depthFirstMazeAlgorithm","node","prevRow","prevCol","newAnimations","directionArray","Array","keys","nodeFinder","entrance","exit","nodeAnimations","nodeList","directions","direction","nodeMazeGrid","weightFinder","nodeWeights","nodeDirections","defaultSolvingAlgorithm","depthFirstSearchSolvingAlgorithm","endNode","newGrid","mazeEndFound","newNode","breadthFirstSearchSolvingAlgorithm","frontierQueue","backtrackDictionary","checking","breadthFirstRecursion","btNode","nodeAndWeightFinder","baseNode","nodeAndWeightList","isANode","dijkstrasSolvingAlgorithm","enterNode","exitNode","heuristic","lowestUnvisitedNode","distances","visitedNodes","min","Infinity","Object","entries","distance","currentDistanceStr","parentNodes","unvisitedNodes","currentNode","Number","currentNodeStr","currentDistance","edge","childNode","childNodeStr","totalWeight","edgeDistance","distanceFromStart","backtrackNode","newNodeStrArray","aStarSolvingAlgorithm","Slider","htmlFor","name","label","onChange","e","setValue","target","value","step","ControlWrapper","newAnimationSpeed","updateAnimationState","updateCanvas","children","setMazeGenAlgo","mazeGenAlgo","setMazeSolveAlgo","mazeSolveAlgo","handleGenerateMaze","handleSolveMaze","Pathfinding","window","innerWidth","useReducer","mazeAnimations","initializeAnimationState","useAnimationState","handleWindowResize","addEventListener","_","removeEventListener","ctx","getContext","cell","fillStyle","fillRect","callback","savedCallback","useRef","current","setInterval","clearInterval","useInterval","remainingStack","noOfUpdates","grid","algorithm","mazeFinished","mazeAlgorithm","start","generateMaze","defaults","enter","solvingAlgorithm","solveMaze","onMouseDown","clientX","clientY","onMouseUp","onMouseOut","onMouseMove","App","exact","from","path","component","ReactDOM","render"],"mappings":"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","file":"static/js/main.86611cb9.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/maze-card-image.f83e9fd7.png\";","module.exports = __webpack_public_path__ + \"static/media/sorting-card-image.9f5ceac9.png\";","import React from 'react';\nimport { Nav, Navbar } from 'react-bootstrap';\nimport { Link, useLocation } from 'react-router-dom';\n\nconst MainNavbar = () => {\n\n    const location = useLocation();\n\n    const isCurrentURL = (url) => {\n        return location.pathname.toLowerCase() === url.toLowerCase();\n    }\n\n\n    return (\n        <Navbar>\n            <Nav variant=\"pills\" activeKey={location.pathname} >\n                <Nav.Item>\n                    <Link style={{\"margin\": \"10px\"}} to=\"/sorting\">Sorting</Link>\n                </Nav.Item>\n                <Nav.Item>\n                    <Link to=\"/pathfinding\">Pathfinding</Link>\n                </Nav.Item>\n            </Nav>\n            { isCurrentURL(\"/main\") ? \n            null : \n            <Navbar.Collapse className=\"justify-content-end\">\n                <Link to=\"/main\">Back to Main</Link>\n            </Navbar.Collapse>\n            }\n        </Navbar>\n    )\n}\n\nexport default MainNavbar;","import React from 'react';\nimport { CardDeck, Card, Button } from 'react-bootstrap';\nimport { useHistory } from \"react-router-dom\";\n\nimport mazeCardImage from \"./maze-card-image.png\";\nimport sortingCardImage from \"./sorting-card-image.png\";\n\nconst MainPage = () => {\n\n    let history = useHistory();\n    \n    const handleClick = (route) => {\n        history.push(`/${route}`);\n    }\n      \n    return (\n        <CardDeck>\n            <Card onClick={() => handleClick(\"sorting\")} style={{cursor: \"pointer\"}}>\n                <Card.Img variant=\"top\" src={sortingCardImage} />\n                <Card.Body>\n                <Card.Title>Sorting Algorithms</Card.Title>\n                <Card.Text>\n                    Set of three different visualizations of the most common algorithms used for sorting arrays.\n                </Card.Text>\n                </Card.Body>\n                <Card.Footer>\n                    <Button>Click Here to Open</Button>\n                </Card.Footer>\n            </Card>\n            <Card onClick={() => handleClick(\"pathfinding\")} style={{cursor: \"pointer\"}}>\n                <Card.Img variant=\"top\" src={mazeCardImage}/>\n                <Card.Body>\n                <Card.Title>Maze Algorithms</Card.Title>\n                <Card.Text>\n                    Visualization of a set of algorithms commonly used for maze generation and solving.\n                </Card.Text>\n                </Card.Body>\n                <Card.Footer>\n                    <Button>Click Here to Open</Button>\n                </Card.Footer>\n            </Card>\n        </CardDeck>\n    )\n}\n\nexport default MainPage;","import React from 'react';\nimport { Dropdown } from 'react-bootstrap';\n\nconst DropdownMenu = (props) => {\n\n    const toggleText = (props.title === \"default\") ? `Choose ${props.type} Algorithm` : props.title;\n    const menuOptions = props.algorithms.map((option, index) => \n        <Dropdown.Item \n            key={index}\n            onClick={() => props.select(option)} \n            href={`#/action-${index+1}`}\n        >\n            {option}\n        </Dropdown.Item>\n    )  \n\n    return (\n        <>\n            <Dropdown>\n                <Dropdown.Toggle variant=\"success\" id=\"dropdown-basic\">\n                    {toggleText}\n                </Dropdown.Toggle>\n\n                <Dropdown.Menu>\n                    {menuOptions}\n                </Dropdown.Menu>\n            </Dropdown>\n\n        </>\n    ) \n}\n\nexport default DropdownMenu;","import React from 'react';\nimport { Button, ButtonGroup } from 'react-bootstrap';\n\nconst ControlButtons = ({ buttons, size }) => {\n\n    return (\n        <div>\n            <ButtonGroup>\n                {buttons.map((button, index) => \n                     <Button \n                        key={index} \n                        title={(button.disabled) ? button.tooltip: null} size={size || \"lg\"} \n                        onClick={() => button.function()} disabled={button.disabled}>{button.text}\n                     </Button>\n                )}\n            </ButtonGroup>\n        </div>\n    )\n}\nexport default ControlButtons;","\nconst shuffle = () => {\n    const bars = 100;\n    const barList = [];\n    for (let bar = 0; bar < bars; bar++) {\n        const barHeight = Math.floor(Math.random() * 1000);\n        barList.push(barHeight)\n    }\n    return barList;\n}\n\n const defaultSort = () => {\n    return []\n}\n\n const defaultSortAnimation = () => {\n    return []\n}\n\n// Bubble Sort\n const bubbleSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n                animations.push([[j, arr[j+1]], [j + 1, arr[j]]])\n            }\n        }\n        \n    }\n    return animations\n}\n\n const bubbleSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const bar1 = chart[animation[0][0]];\n        const bar2 = chart[animation[1][0]];\n        const ht1 = `${animation[0][1] / 10}%`\n        const ht2 = `${animation[1][1] / 10}%`\n        \n\n        // Highlight the two elements to be swapped, and swap their heights\n        // Default as paused so they don't start automatically every time\n        const animation1 = bar1.animate([{backgroundColor: 'rgb(51, 226, 217)'}, {backgroundColor: 'red'}], {duration: duration, delay: index * duration});\n        const animation2 = bar1.animate([{ height: ht2 }, { height: ht2 }], { fill: \"forwards\", duration: duration, delay: index * duration });\n        const animation3 = bar2.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration });\n        const animation4 = bar2.animate([{ height: ht1 }, { height: ht1 }], { fill: \"forwards\", duration: duration, delay: index * duration });\n\n        // Save animations for reuse\n        barAnimations.push(\n            animation1, animation2, animation3, animation4\n        )\n    })\n\n    return barAnimations\n}\n\n// Selection Sort \n const selectionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        let minIndex = i;\n        for (let j = i; j < n; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j\n            }\n            // Checks if sort has reached the end of Array, if so, records that there will be a swap between i and min\n            let swap = false;\n            if (j === n - 1) {\n                swap = true;\n            }\n            // Push the base Element, the element being checked, the current minimum, and an indication of whether a swap has occurred\n            animations.push([[i, arr[i]], [j, arr[j]], [minIndex, arr[minIndex]], swap])\n        }\n        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n    return animations\n}\n\n const selectionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 3;// The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n    \n    animations.forEach((animation, index) => {\n        const baseChild = chart[animation[0][0]];\n        const checkingChild = chart[animation[1][0]];\n        const minChild = chart[animation[2][0]];\n        const baseHeight = `${animation[0][1] / 10}%`\n        const minHeight = `${animation[2][1] / 10}%`\n        const swap = animation[3];\n\n        // Highlight the base of the section being checked, and the current element being compared against the minimum, in bubbleSort, while the min is highlighted in red\n        barAnimations.push(\n            baseChild.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'blue' }], { duration: duration, delay: index * duration }),\n            checkingChild.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'blue' }], { duration: duration, delay: index * duration }),\n            minChild.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration }),\n        )\n        // if the two elements are to be swapped, perform the swap \n        if (swap === true) {\n            barAnimations.push(\n                minChild.animate([{ height: baseHeight }, { height: baseHeight }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChild.animate([{ height: minHeight }, { height: minHeight }], { fill: \"forwards\", duration: duration, delay: index * duration })\n            )\n        }\n    })\n\n    return barAnimations\n}\n\n// Insertion Sort \n const insertionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n\n\n    // Move up through the array one at a time, and insert each new element into already sorted numbers to the left in its proper (ascending) position \n    for (let i = 1; i < n; i++) {\n        let j = i - 1;\n        while (j >= 0 && arr[j] > arr[j+1]) {\n            animations.push([[j, arr[j]], [j+1, arr[j+1]]]);\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            j = j - 1\n        }\n    }\n    \n    return animations\n}\n\n const insertionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElLt = chart[animation[0][0]];\n        const swapElLtHt = `${animation[0][1] / 10}%`;\n        const swapElRt = chart[animation[1][0]];\n        const swapElRtHt = `${animation[1][1] / 10}%`;\n        \n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElRt.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            swapElRt.animate([{ height: swapElLtHt }, { height: swapElLtHt }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElLt.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            swapElLt.animate([{ height: swapElRtHt }, { height: swapElRtHt }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n    \n    return barAnimations\n}\n\n// Merge Sort \n const mergeSort = (origArray) => {\n    // Two separate arrays, one main one and one to hold swapped values until they can be unswapped. Avoids having to create a buffer array during the sorting process\n    const mainArray = [...origArray];\n    const auxArray = [...mainArray]\n    const n = mainArray.length\n    const animations = [];\n    if (n <= 1) {\n        return mainArray\n    }\n    // Initialize first function call\n    mergeSortHelper(mainArray, 0, n - 1, auxArray, animations);\n\n    return animations;\n}\n\nconst mergeSortHelper = (mainArray, startIdx, endIdx, auxArray, animations) => {\n    // Base case, returns if only one element in array\n    if (startIdx === endIdx) return;\n\n    // Find middle index of array, place to split before coming merge\n    const midIdx = Math.floor((startIdx + endIdx) / 2);\n\n    // recursively call function on each half of the array, to keep splitting until base case of 1 is reached. Also, notice that auxArray and mainArray are swapped from initial function call; it's complicated but basically this allows the aux array and main array to keep switching back and forth and save the values from the previous merge, which means that I don't have to create a temporary array to hold the values\n    mergeSortHelper(auxArray, startIdx, midIdx, mainArray, animations);\n    mergeSortHelper(auxArray, midIdx + 1, endIdx, mainArray, animations);\n\n    // Call the merge function to sort the values and combine back together\n    merge(mainArray, startIdx, midIdx, endIdx, auxArray, animations)\n}\n\nconst merge = (mainArray, startIdx, midIdx, endIdx, auxArray, animations) => {\n    // Copies the values of the aux array into the main array, putting the next lowest value from either array at value k\n    let i = startIdx;\n    let j = midIdx + 1;\n    let k = startIdx;\n    \n    // Pick the lowest value from either array and put it into the main array\n    while (i <= midIdx && j <= endIdx) {\n        const animation = {};\n        animation.comparison = [i, j];\n        animation.range = [startIdx, endIdx]\n        if (auxArray[i] >= auxArray[j]) {\n            animation.swap = [k, auxArray[j]]\n            mainArray[k++] = auxArray[j++]\n        } else {\n            animation.swap = [k, auxArray[i]]\n            mainArray[k++] = auxArray[i++]\n        }\n        animations.push(animation);\n    }\n\n    // While there are still values in only one of the two arrays being merged, copy them in; they are already ordered from previous sorts \n    while (j <= endIdx) {\n        animations.push({\n            comparison: [j, j],\n            swap: [k, auxArray[j]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[j++]\n\n    }\n    while (i <= midIdx) {\n        animations.push({\n            comparison: [i, i],\n            swap: [k, auxArray[i]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[i++]\n    }\n}\n\n const mergeSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 30;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const compareEl1 = chart[animation.comparison[0]];\n        const compareEl2 = chart[animation.comparison[1]];\n        const swapEl = chart[animation.swap[0]];\n        const swapHt = `${animation.swap[1] / 10}%`;\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            compareEl1.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            compareEl2.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            swapEl.animate([{ height: swapHt }, { height: swapHt }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n// Quick Sort \n const quickSort = (origArray) => {\n    // Copy original array so as not to mutate it \n    const array = [...origArray];\n    const animations = [];\n\n    const quickSortHelper = (array, left, right, animations) => {\n        if (left >= right) return;\n\n        // Find the center index, by sorting from the two ends and so that everything to the left of the pivot is smaller, and everything right is larger\n        const index = partition(array, left, right);\n        \n        // split the array into two halves, and call recursively on the two halves \n        quickSortHelper(array, left, index - 1, animations);\n        quickSortHelper(array, index, right, animations);\n    }\n\n    const partition = (array, left, right) => {\n        // Pivot starts from right end of subarray \n        const pivot = right;\n        right--;\n        // Keep moving pointers towards middle until two pointers cross one another\n        while (left <= right) {\n            // Find a left side element smaller than pivot, and a right side one larger, and switch them \n            while (array[left] < array[pivot]) {\n                left++\n            }\n            while (array[right] > array[pivot]) {\n                right--\n            }\n            if (left <= right) {\n                animations.push([[left, array[left]], [right, array[right]], [pivot, array[pivot]]]);\n                [array[left], array[right]] = [array[right], array[left]]\n                left++\n                right--\n            }\n        }\n        // Move the pivot into the middle \n        animations.push([[left, array[left]], [pivot, array[pivot]], [pivot, array[pivot]]]);\n        [array[left], array[pivot]] = [array[pivot], array[left]]\n        return left;\n    }\n    // Initial function call \n    quickSortHelper(array, 0, array.length - 1)\n\n    return animations\n}\n\n const quickSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 30;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        \n        const leftEl = chart[animation[0][0]];\n        const rightEl = chart[animation[1][0]];\n        const pivot = chart[animation[2][0]];\n        const leftHt = `${animation[0][1] / 10}%`;\n        const rightHt = `${animation[1][1] / 10}%`;\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            leftEl.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            leftEl.animate([{ height: leftHt }, { height: rightHt }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightEl.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            rightEl.animate([{ height: rightHt }, { height: leftHt }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            pivot.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n// Radix Bar Sort \n const radixSort = (origArr) => {\n    const arr = [...origArr] // Copy original array so as not to mutate it\n    const animations = [];\n\n    // initialize an array subarrays representing numbers 0 through 9, according to their index in parent array \n    const countBuckets = [];\n    for (let i = 0; i < 10; i++) {\n        countBuckets[i] = []\n    }\n\n    let max = 0;\n    // find length of longest number by digits, by converting it to string and measuring its length, then comparing to all other numbers \n    for (let j = 0; j < arr.length; j++) {\n        max = (arr[j].toString().length > max) ? arr[j].toString().length : max;\n    }\n\n    // cycle through array once for each digit in longest number from array \n    for (let l = 0; l < max; l++) {\n\n        while (arr.length) {\n            const stringNum = arr[0].toString()  // Convert front number in array to string\n            const d = stringNum.length - l - 1 // Starting from rightmost digit on first iteration, then moving left on next iteration\n            const digit = (stringNum[d]) ? stringNum[d] : 0 // Select either that digit, or (if too short) use 0\n            countBuckets[digit].push(arr.shift()) // Remove number from array and place into bucket array corresponding to that digit\n        }\n        let counter = 0;\n        for (let i = 0; i < 10; i++) { // Cycle through all 10 counter arrays, from lowest to highest\n            while (countBuckets[i].length) {  // Cycle through counter array until empty\n                const num = countBuckets[i].shift() // Save number in variable, so it can be added both to old array and to animation\n                arr.push(num)\n                animations.push([num, counter])\n                counter++\n            }\n        }\n    }\n    return animations\n\n}\n\n const radixSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 30;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const element = chart[animation[1]];\n        const height = `${animation[0] / 10}%`;\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            element.animate([{ backgroundColor: 'red' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration }),\n            element.animate([{ height: height }, { height: height }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\nconst barChartFunctions = {\n    shuffle,\n    defaultSort,\n    defaultSortAnimation,\n    bubbleSort, \n    bubbleSortAnimation, \n    selectionSort,\n    selectionSortAnimation,\n    insertionSort,\n    insertionSortAnimation,\n    mergeSort,\n    mergeSortAnimation,\n    quickSort,\n    quickSortAnimation,\n    radixSort,\n    radixSortAnimation,\n}\n\nexport default barChartFunctions;\n// // Color Map Animations\n\n// // Bubble Sort Color Map Animation\n// export const colorMapBubbleSortAnimation = (animations) => {\n//     // Sets the animations using the Web Animations API\n//     const chart = document.getElementsByClassName(\"color-bar\");\n//     const duration = .5;   // The base duration, for easy changing later (duration can also be changed via the API)\n//     const barAnimations = [];\n//     animations.forEach((animation, index) => {\n//         const compareEl1 = chart[animation[0][0]];\n//         const compareEl2 = chart[animation[1][0]];\n//         const swapColor1 = animation[0][1];\n//         const swapColor2 = animation[1][1];\n\n\n//         // Exchange the colors of the two elements being selected\n//         barAnimations.push(\n//             compareEl1.animate([{ backgroundColor: `hsl(${swapColor2}, 100%, 50%)` }, { backgroundColor: `hsl(${swapColor2}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n//             compareEl2.animate([{ backgroundColor: `hsl(${swapColor1}, 100%, 50%)` }, { backgroundColor: `hsl(${swapColor1}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n\n//         )\n\n//     })\n//     return barAnimations\n// }\n\n\n// // PixelMap Animations \n\n// // Pixel Map Bubble Sort\n// export const pixelMapBubbleSort = (origArr) => {\n//     // Clone the original array so as not to mutate it\n//     const arr = [...origArr]\n//     // Store the indices of the swaps made in order, to be used in the animations\n//     const animations = []\n//     const n = arr.length;\n//     for (let i = 0; i < n; i++) {\n//         for (let j = 0; j < n - i - 1; j++) {\n//             if (arr[j][0] > arr[j + 1][0]) {\n//                 [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n//                 animations.push([j, j + 1])\n//             }\n//         }\n//     }\n//     return animations\n// }\n\n// // Bubble Sort Pixel Map Animation\n// export const bubbleSortPixelMapAnimation = (animations, speed) => {\n//     for (let i = 0; i < animations.length; i++) {\n//         const [ind1, ind2] = animations[i]\n//         setTimeout(() => {\n//             const parent = document.getElementsByClassName('chart');\n//             const child1 = parent[0].childNodes[ind1];\n//             const child2 = parent[0].childNodes[ind2];\n\n//             // child1.style.backgroundColor = \"red\";\n//             // child2.style.backgroundColor = \"red\";\n//             for (let i = 0; i <= 2; i++) {\n//                 [child1.childNodes[i].style.height, child2.childNodes[i].style.height] = [child2.childNodes[i].style.height, child1.childNodes[i].style.height]\n\n//             }\n//             setTimeout(() => {\n//                 // child1.style.backgroundColor = \"rgb(51, 226, 217)\";\n//                 // child2.style.backgroundColor = \"rgb(51, 226, 217)\";\n//             }, speed);\n//         }, i * speed);\n//     }\n// }\n\n\n\n\n\n// // ***Display Functions***\n\n// // BarChart\n// export const barShuffle = (bars) => {\n//     const barList = [];\n//     for (let bar = 0; bar < bars; bar++) {\n//         const barHeight = Math.floor(Math.random() * 1000);\n//         barList.push(barHeight)\n//     }\n//     return barList;\n// }\n\n\n// // ColorMap\n\n\n\n\n\n// // PixelMap\n// const shuffle = (array) => {\n\n//     for (let i = array.length - 1; i > 0; i--) {\n//         let j = Math.floor(Math.random() * (i + 1));\n//         [array[i], array[j]] = [array[j], array[i]];\n//     }\n//     return array\n// };\n\n\n// export const pixelBarShuffle = () => {\n//     const pixelBarList = [];\n//     const height = 200;\n//     for (let pixBar = 0; pixBar < height; pixBar++) {\n//         const pixelBarHeights = [height - pixBar - 1, 1, pixBar]\n//         pixelBarList.push(pixelBarHeights)\n//     }\n//     return shuffle(pixelBarList)\n// }\n\n\n// // PixelPainting\n\n\n\n\n\n\n\n\n","const shuffle = () => {\n    const bars = 200;\n    const colorList = [];\n    for (let color = 0; color < bars; color++) {\n        const hueValue = Math.floor(Math.random() * 359)\n\n        colorList.push(hueValue)\n    }\n    return colorList\n}\n\nconst defaultSort = () => {\n    return []\n}\n\nconst defaultSortAnimation = () => {\n    return []\n}\n\n// ColorMap Bubble Sort\n\nconst bubbleSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n\n    return animations\n}\n\n\n// Bubble Sort Color Map Animation\nconst bubbleSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = .5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n    animations.forEach((animation, index) => {\n        const compareEl1 = chart[animation[0][0]];\n        const compareEl2 = chart[animation[1][0]];\n        const swapColor1 = animation[0][1];\n        const swapColor2 = animation[1][1];\n\n\n        // Exchange the colors of the two elements being selected\n        barAnimations.push(\n            compareEl1.animate([{ backgroundColor: `hsl(${swapColor2}, 100%, 50%)` }, { backgroundColor: `hsl(${swapColor2}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            compareEl2.animate([{ backgroundColor: `hsl(${swapColor1}, 100%, 50%)` }, { backgroundColor: `hsl(${swapColor1}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n\n        )\n\n    })\n    return barAnimations\n}\n\n// Selection Sort \nconst selectionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        let minIndex = i;\n        for (let j = i; j < n; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j\n            }\n            // Checks if sort has reached the end of Array, if so, records that there will be a swap between i and min\n            let swap = false;\n            if (j === n - 1) {\n                swap = true;\n            }\n            // Push the base Element, the element being checked, the current minimum, and an indication of whether a swap has occurred\n            animations.push([[i, arr[i]], [j, arr[j]], [minIndex, arr[minIndex]], swap])\n        }\n        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n    return animations\n}\n\nconst selectionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = .5;// The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const baseChild = chart[animation[0][0]];\n        const minChild = chart[animation[2][0]];\n        const baseColor = animation[0][1]\n        const minColor = animation[2][1]\n        const swap = animation[3];\n\n        // if the two elements are to be swapped, perform the swap \n        if (swap === true) {\n            barAnimations.push(\n                minChild.animate([{ backgroundColor: `hsl(${baseColor}, 100%, 50%)` }, { backgroundColor: `hsl(${baseColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChild.animate([{ backgroundColor: `hsl(${minColor}, 100%, 50%)` }, { backgroundColor: `hsl(${minColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n            )\n        }\n    })\n\n    return barAnimations\n}\n\n// Insertion Sort \nconst insertionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n\n\n    // Move up through the array one at a time, and insert each new element into already sorted numbers to the left in its proper (ascending) position \n    for (let i = 1; i < n; i++) {\n        let j = i - 1;\n        while (j >= 0 && arr[j] > arr[j + 1]) {\n            animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            j = j - 1\n        }\n    }\n\n    return animations\n}\n\nconst insertionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElLt = chart[animation[0][0]];\n        const swapElLtColor = animation[0][1];\n        const swapElRt = chart[animation[1][0]];\n        const swapElRtColor = animation[1][1];\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElLt.animate([{ backgroundColor: `hsl(${swapElRtColor}, 100%, 50%)` }, { backgroundColor: `hsl(${swapElRtColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElRt.animate([{ backgroundColor: `hsl(${swapElLtColor}, 100%, 50%)` }, { backgroundColor: `hsl(${swapElLtColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n// Merge Sort \nconst mergeSort = (origArray) => {\n    // Two separate arrays, one main one and one to hold swapped values until they can be unswapped. Avoids having to create a buffer array during the sorting process\n    const mainArray = [...origArray];\n    const auxArray = [...mainArray]\n    const n = mainArray.length\n    const animations = [];\n    if (n <= 1) {\n        return mainArray\n    }\n    // Initialize first function call\n    mergeSortHelper(mainArray, 0, n - 1, auxArray, animations);\n\n    return animations;\n}\n\nconst mergeSortHelper = (mainArray, startIdx, endIdx, auxArray, animations) => {\n    // Base case, returns if only one element in array\n    if (startIdx === endIdx) return;\n\n    // Find middle index of array, place to split before coming merge\n    const midIdx = Math.floor((startIdx + endIdx) / 2);\n\n    // recursively call function on each half of the array, to keep splitting until base case of 1 is reached. Also, notice that auxArray and mainArray are swapped from initial function call; it's complicated but basically this allows the aux array and main array to keep switching back and forth and save the values from the previous merge, which means that I don't have to create a temporary array to hold the values\n    mergeSortHelper(auxArray, startIdx, midIdx, mainArray, animations);\n    mergeSortHelper(auxArray, midIdx + 1, endIdx, mainArray, animations);\n\n    // Call the merge function to sort the values and combine back together\n    merge(mainArray, startIdx, midIdx, endIdx, auxArray, animations)\n}\n\nconst merge = (mainArray, startIdx, midIdx, endIdx, auxArray, animations) => {\n    // Copies the values of the aux array into the main array, putting the next lowest value from either array at value k\n    let i = startIdx;\n    let j = midIdx + 1;\n    let k = startIdx;\n\n    // Pick the lowest value from either array and put it into the main array\n    while (i <= midIdx && j <= endIdx) {\n        const animation = {};\n        animation.comparison = [i, j];\n        animation.range = [startIdx, endIdx]\n        if (auxArray[i] >= auxArray[j]) {\n            animation.swap = [k, auxArray[j]]\n            mainArray[k++] = auxArray[j++]\n        } else {\n            animation.swap = [k, auxArray[i]]\n            mainArray[k++] = auxArray[i++]\n        }\n        animations.push(animation);\n    }\n\n    // While there are still values in only one of the two arrays being merged, copy them in; they are already ordered from previous sorts \n    while (j <= endIdx) {\n        animations.push({\n            comparison: [j, j],\n            swap: [k, auxArray[j]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[j++]\n\n    }\n    while (i <= midIdx) {\n        animations.push({\n            comparison: [i, i],\n            swap: [k, auxArray[i]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[i++]\n    }\n}\n\nconst mergeSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapEl = chart[animation.swap[0]];\n        const swapColor = animation.swap[1];\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapEl.animate([{ backgroundColor: `hsl(${swapColor}, 100%, 50%)` }, { backgroundColor: `hsl(${swapColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n        )\n    })\n\n    return barAnimations\n}\n\n// Quick Sort \nconst quickSort = (origArray) => {\n    // Copy original array so as not to mutate it \n    const array = [...origArray];\n    const animations = [];\n\n    const quickSortHelper = (array, left, right, animations) => {\n        if (left >= right) return;\n\n        // Find the center index, by sorting from the two ends and so that everything to the left of the pivot is smaller, and everything right is larger\n        const index = partition(array, left, right);\n\n        // split the array into two halves, and call recursively on the two halves \n        quickSortHelper(array, left, index - 1, animations);\n        quickSortHelper(array, index, right, animations);\n    }\n\n    const partition = (array, left, right) => {\n        // Pivot starts from right end of subarray \n        const pivot = right;\n        right--;\n        // Keep moving pointers towards middle until two pointers cross one another\n        while (left <= right) {\n            // Find a left side element smaller than pivot, and a right side one larger, and switch them \n            while (array[left] < array[pivot]) {\n                left++\n            }\n            while (array[right] > array[pivot]) {\n                right--\n            }\n            if (left <= right) {\n                animations.push([[left, array[left]], [right, array[right]], [pivot, array[pivot]]]);\n                [array[left], array[right]] = [array[right], array[left]]\n                left++\n                right--\n            }\n        }\n        // Move the pivot into the middle \n        animations.push([[left, array[left]], [pivot, array[pivot]], [pivot, array[pivot]]]);\n        [array[left], array[pivot]] = [array[pivot], array[left]]\n        return left;\n    }\n    // Initial function call \n    quickSortHelper(array, 0, array.length - 1)\n\n    return animations\n}\n\nconst quickSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const leftEl = chart[animation[0][0]];\n        const rightEl = chart[animation[1][0]];\n        const leftColor = animation[0][1];\n        const rightColor = animation[1][1];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            leftEl.animate([{ backgroundColor: `hsl(${rightColor}, 100%, 50%)` }, { backgroundColor: `hsl(${rightColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightEl.animate([{ backgroundColor: `hsl(${leftColor}, 100%, 50%)` }, { backgroundColor: `hsl(${leftColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n// Radix Bar Sort \nconst radixSort = (origArr) => {\n    const arr = [...origArr] // Copy original array so as not to mutate it\n    const animations = [];\n\n    // initialize an array subarrays representing numbers 0 through 9, according to their index in parent array \n    const countBuckets = [];\n    for (let i = 0; i < 10; i++) {\n        countBuckets[i] = []\n    }\n\n    let max = 0;\n    // find length of longest number by digits, by converting it to string and measuring its length, then comparing to all other numbers \n    for (let j = 0; j < arr.length; j++) {\n        max = (arr[j].toString().length > max) ? arr[j].toString().length : max;\n    }\n\n    // cycle through array once for each digit in longest number from array \n    for (let l = 0; l < max; l++) {\n\n        while (arr.length) {\n            const stringNum = arr[0].toString()  // Convert front number in array to string\n            const d = stringNum.length - l - 1 // Starting from rightmost digit on first iteration, then moving left on next iteration\n            const digit = (stringNum[d]) ? stringNum[d] : 0 // Select either that digit, or (if too short) use 0\n            countBuckets[digit].push(arr.shift()) // Remove number from array and place into bucket array corresponding to that digit\n        }\n        let counter = 0;\n        for (let i = 0; i < 10; i++) { // Cycle through all 10 counter arrays, from lowest to highest\n            while (countBuckets[i].length) {  // Cycle through counter array until empty\n                const num = countBuckets[i].shift() // Save number in variable, so it can be added both to old array and to animation\n                arr.push(num)\n                animations.push([num, counter])\n                counter++\n            }\n        }\n    }\n    return animations\n\n}\n\nconst radixSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const element = chart[animation[1]];\n        const color = animation[0];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            element.animate([{ backgroundColor: `hsl(${color}, 100%, 50%)` }, { backgroundColor: `hsl(${color}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\nconst colorMapFunctions = {\n    shuffle,\n    defaultSort,\n    defaultSortAnimation,\n    bubbleSort, \n    bubbleSortAnimation, \n    selectionSort,\n    selectionSortAnimation,\n    insertionSort,\n    insertionSortAnimation,\n    mergeSort,\n    mergeSortAnimation,\n    quickSort,\n    quickSortAnimation,\n    radixSort,\n    radixSortAnimation,\n};\n\nexport default colorMapFunctions;","const shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\nconst pixelBarShuffle = () => {\n    const height = 100;\n    const pixelBarList = [];\n    for (let pixBar = 0; pixBar < height; pixBar++) {\n        const pixelBarHeights = [pixBar, 1, height - pixBar - 1]\n        pixelBarList.push(pixelBarHeights)\n    }\n    return shuffle(pixelBarList)\n}\n\n// Sorting Functions\nconst defaultSort = () => {\n    return []\n}\n\nconst defaultSortAnimation = () => {\n    return []\n}\n\n// ColorMap Bubble Sort\nconst bubbleSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j][0] > arr[j + 1][0]) {\n                animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n    \n    return animations\n}\n\n// Bubble Sort Color Map Animation\nconst bubbleSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = .5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n    animations.forEach((animation, index) => {\n        const compareEl1Bottom = chart[animation[0][0]].childNodes[0];\n        const compareEl1Top = chart[animation[0][0]].childNodes[2];\n        const compareEl2Bottom = chart[animation[1][0]].childNodes[0];\n        const compareEl2Top = chart[animation[1][0]].childNodes[2];\n\n        const swapHt1Top = animation[0][1][0];\n        const swapHt1Bottom = animation[0][1][2];\n\n        const swapHt2Top = animation[1][1][0];\n        const swapHt2Bottom = animation[1][1][2];\n\n        \n\n        // Exchange the colors of the two elements being selected\n        barAnimations.push(\n            compareEl1Bottom.animate([{ height: `${swapHt2Bottom}%` }, { height: `${swapHt2Bottom}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            compareEl1Top.animate([{ height: `${swapHt2Top}%` }, { height: `${swapHt2Top}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }), \n            compareEl2Bottom.animate([{ height: `${swapHt1Bottom}%` }, { height: `${swapHt1Bottom}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            compareEl2Top.animate([{ height: `${swapHt1Top}%` }, { height: `${swapHt1Top}%` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n\n    })\n    return barAnimations\n}\n\n// Selection Sort \nconst selectionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        let minIndex = i;\n        for (let j = i; j < n; j++) {\n            if (arr[j][0] < arr[minIndex][0]) {\n                minIndex = j\n            }\n            // Checks if sort has reached the end of Array, if so, records that there will be a swap between i and min\n            let swap = false;\n            if (j === n - 1) {\n                swap = true;\n            }\n            // Push the base Element, the element being checked, the current minimum, and an indication of whether a swap has occurred\n            animations.push([[i, arr[i]], [j, arr[j]], [minIndex, arr[minIndex]], swap])\n        }\n        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n    \n    return animations\n}\n\nconst selectionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = .5;// The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const baseChildTop = chart[animation[0][0]].childNodes[0];\n        const baseChildBottom = chart[animation[0][0]].childNodes[2];\n        const minChildTop = chart[animation[2][0]].childNodes[0];\n        const minChildBottom = chart[animation[2][0]].childNodes[2];\n        const baseTopHeight = animation[0][1][2];\n        const baseBottomHeight = animation[0][1][0];\n        const minTopHeight = animation[2][1][2];\n        const minBottomHeight = animation[2][1][0];\n        const swap = animation[3];\n        \n        // if the two elements are to be swapped, perform the swap \n        if (swap === true) {\n            barAnimations.push(\n                minChildTop.animate([{ height: `${baseTopHeight}%` }, { height: `${baseTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChildTop.animate([{ height: `${minTopHeight}%` }, { height: `${minTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                minChildBottom.animate([{ height: `${baseBottomHeight}%` }, { height: `${baseBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChildBottom.animate([{ height: `${minBottomHeight}%` }, { height: `${minBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n            )\n        }\n    })\n\n    return barAnimations\n}\n\n// Insertion Sort \nconst insertionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n\n\n    // Move up through the array one at a time, and insert each new element into already sorted numbers to the left in its proper (ascending) position \n    for (let i = 1; i < n; i++) {\n        let j = i - 1;\n        while (j >= 0 && arr[j][0] > arr[j + 1][0]) {\n            animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            j = j - 1\n        }\n    }\n\n    return animations\n}\n\nconst insertionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElLtTop = chart[animation[0][0]].childNodes[0];\n        const swapElLtBottom = chart[animation[0][0]].childNodes[2];\n        const swapElLtTopHeight = animation[0][1][2];\n        const swapElLtBottomHeight = animation[0][1][0];\n        const swapElRtTop = chart[animation[1][0]].childNodes[0];\n        const swapElRtBottom = chart[animation[1][0]].childNodes[2];\n        const swapElRtTopHeight = animation[1][1][2];\n        const swapElRtBottomHeight = animation[1][1][0];\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElLtTop.animate([{ height: `${swapElRtTopHeight}%` }, { height: `${swapElRtTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElLtBottom.animate([{ height: `${swapElRtBottomHeight}%` }, { height: `${swapElRtBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElRtTop.animate([{ height: `${swapElLtTopHeight}%` }, { height: `${swapElLtTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElRtBottom.animate([{ height: `${swapElLtBottomHeight}%` }, { height: `${swapElLtBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n        )\n    })\n\n    return barAnimations\n}\n\n// Merge Sort \nconst mergeSort = (origArray) => {\n    // Two separate arrays, one main one and one to hold swapped values until they can be unswapped. Avoids having to create a buffer array during the sorting process\n    const mainArray = [...origArray];\n    const auxArray = [...mainArray]\n    const n = mainArray.length\n    const animations = [];\n    if (n <= 1) {\n        return mainArray\n    }\n    // Initialize first function call\n    mergeSortHelper(mainArray, 0, n - 1, auxArray, animations);\n    \n    return animations;\n}\n\nconst mergeSortHelper = (mainArray, startIdx, endIdx, auxArray, animations) => {\n    // Base case, returns if only one element in array\n    if (startIdx === endIdx) return;\n\n    // Find middle index of array, place to split before coming merge\n    const midIdx = Math.floor((startIdx + endIdx) / 2);\n\n    // recursively call function on each half of the array, to keep splitting until base case of 1 is reached. Also, notice that auxArray and mainArray are swapped from initial function call; it's complicated but basically this allows the aux array and main array to keep switching back and forth and save the values from the previous merge, which means that I don't have to create a temporary array to hold the values\n    mergeSortHelper(auxArray, startIdx, midIdx, mainArray, animations);\n    mergeSortHelper(auxArray, midIdx + 1, endIdx, mainArray, animations);\n\n    // Call the merge function to sort the values and combine back together\n    merge(mainArray, startIdx, midIdx, endIdx, auxArray, animations)\n}\n\nconst merge = (mainArray, startIdx, midIdx, endIdx, auxArray, animations) => {\n    // Copies the values of the aux array into the main array, putting the next lowest value from either array at value k\n    let i = startIdx;\n    let j = midIdx + 1;\n    let k = startIdx;\n\n    // Pick the lowest value from either array and put it into the main array\n    while (i <= midIdx && j <= endIdx) {\n        const animation = {};\n        animation.comparison = [i, j];\n        animation.range = [startIdx, endIdx]\n        if (auxArray[i][0] >= auxArray[j][0]) {\n            animation.swap = [k, auxArray[j]]\n            mainArray[k++] = auxArray[j++]\n        } else {\n            animation.swap = [k, auxArray[i]]\n            mainArray[k++] = auxArray[i++]\n        }\n        animations.push(animation);\n    }\n\n    // While there are still values in only one of the two arrays being merged, copy them in; they are already ordered from previous sorts \n    while (j <= endIdx) {\n        animations.push({\n            comparison: [j, j],\n            swap: [k, auxArray[j]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[j++]\n\n    }\n    while (i <= midIdx) {\n        animations.push({\n            comparison: [i, i],\n            swap: [k, auxArray[i]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[i++]\n    }\n}\n\nconst mergeSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElTop = chart[animation.swap[0]].childNodes[0];\n        const swapElBottom = chart[animation.swap[0]].childNodes[2];\n\n        const swapTopHeight = animation.swap[1][2];\n        const swapBottomHeight = animation.swap[1][0];\n\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElTop.animate([{ height: `${swapTopHeight}%` }, { height: `${swapTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElBottom.animate([{ height: `${swapBottomHeight}%` }, { height: `${swapBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n        )\n    })\n\n    return barAnimations\n}\n\n// Quick Sort \nconst quickSort = (origArray) => {\n    // Copy original array so as not to mutate it \n    const array = [...origArray];\n    const animations = [];\n\n    const quickSortHelper = (array, left, right, animations) => {\n        if (left >= right) return;\n\n        // Find the center index, by sorting from the two ends and so that everything to the left of the pivot is smaller, and everything right is larger\n        const index = partition(array, left, right);\n\n        // split the array into two halves, and call recursively on the two halves \n        quickSortHelper(array, left, index - 1, animations);\n        quickSortHelper(array, index, right, animations);\n    }\n\n    const partition = (array, left, right) => {\n        // Pivot starts from right end of subarray \n        const pivot = right;\n        right--;\n        // Keep moving pointers towards middle until two pointers cross one another\n        while (left <= right) {\n            // Find a left side element smaller than pivot, and a right side one larger, and switch them \n            while (array[left][2] < array[pivot][2]) {\n                left++\n            }\n            while (array[right][2] > array[pivot][2]) {\n                right--\n            }\n            if (left <= right) {\n                animations.push([[left, array[left]], [right, array[right]], [pivot, array[pivot]]]);\n                [array[left], array[right]] = [array[right], array[left]]\n                left++\n                right--\n            }\n        }\n        // Move the pivot into the middle \n        animations.push([[left, array[left]], [pivot, array[pivot]], [pivot, array[pivot]]]);\n        [array[left], array[pivot]] = [array[pivot], array[left]]\n        return left;\n    }\n    // Initial function call \n    quickSortHelper(array, 0, array.length - 1)\n    \n    return animations\n}\n\nconst quickSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const leftElTop = chart[animation[0][0]].childNodes[0];\n        const leftElBottom = chart[animation[0][0]].childNodes[2];\n        const rightElTop = chart[animation[1][0]].childNodes[0];\n        const rightElBottom = chart[animation[1][0]].childNodes[2];\n        const leftTopHeight = animation[0][1][0];\n        const leftBottomHeight = animation[0][1][2];\n        const rightTopHeight = animation[1][1][0];\n        const rightBottomHeight = animation[1][1][2];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            leftElTop.animate([{ height: `${rightTopHeight}%` }, { height: `${rightTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            leftElBottom.animate([{ height: `${rightBottomHeight}%` }, { height: `${rightBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightElTop.animate([{ height: `${leftTopHeight}%` }, { height: `${leftTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightElBottom.animate([{ height: `${leftBottomHeight}%` }, { height: `${leftBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n// Radix Bar Sort \nconst radixSort = (origArr) => {\n    const arr = [...origArr] // Copy original array so as not to mutate it\n    const animations = [];\n\n    // initialize an array subarrays representing numbers 0 through 9, according to their index in parent array \n    const countBuckets = [];\n    for (let i = 0; i < 10; i++) {\n        countBuckets[i] = []\n    }\n\n    let max = 0;\n    // find length of longest number by digits, by converting it to string and measuring its length, then comparing to all other numbers \n    for (let j = 0; j < arr.length; j++) {\n        max = (arr[j].toString().length > max) ? arr[j].toString().length : max;\n    }\n\n    // cycle through array once for each digit in longest number from array \n    for (let l = 0; l < max; l++) {\n\n        while (arr.length) {\n            const stringNum = arr[0][0].toString()  // Convert front number in array to string\n            const d = stringNum.length - l - 1 // Starting from rightmost digit on first iteration, then moving left on next iteration\n            const digit = (stringNum[d]) ? stringNum[d] : 0 // Select either that digit, or (if too short) use 0\n            countBuckets[digit].push(arr.shift()) // Remove number from array and place into bucket array corresponding to that digit\n        }\n        let counter = 0;\n        for (let i = 0; i < 10; i++) { // Cycle through all 10 counter arrays, from lowest to highest\n            while (countBuckets[i].length) {  // Cycle through counter array until empty\n                const numArr = countBuckets[i].shift() // Save number in variable, so it can be added both to old array and to animation\n                arr.push(numArr)\n                animations.push([numArr, counter])\n                counter++\n            }\n        }\n    }\n    \n    return animations\n\n}\n\nconst radixSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const elementTop = chart[animation[1]].childNodes[0];\n        const elementBottom = chart[animation[1]].childNodes[2];\n        const heightTop = animation[0][2];\n        const heightBottom = animation[0][0];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            elementTop.animate([{ height: `${heightTop}%` }, { height: `${heightTop}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            elementBottom.animate([{ height: `${heightBottom}%` }, { height: `${heightBottom}%` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\nconst pixelMapFunctions = {\n    shuffle: pixelBarShuffle,\n    defaultSort,\n    defaultSortAnimation,\n    bubbleSort, \n    bubbleSortAnimation, \n    selectionSort,\n    selectionSortAnimation,\n    insertionSort,\n    insertionSortAnimation,\n    mergeSort,\n    mergeSortAnimation,\n    quickSort,\n    quickSortAnimation,\n    radixSort,\n    radixSortAnimation,\n};\n\nexport default pixelMapFunctions;","import barChart from \"../utilities/barChartFunctions\";\nimport colorMap from \"../utilities/colorMapFunctions\";\nimport pixelMap from \"../utilities/pixelMapFunctions\";\n\nconst sortFunctions = {\n    barChart,\n    colorMap,\n    pixelMap\n}\n\nexport default sortFunctions;","import React from 'react';\n\nconst Bar = ({ height }) => {\n    const barHeightinPercent = height/10;\n    const barStyle = {\n        height: `${barHeightinPercent}%`\n    }\n    \n    return (\n        <div className=\"bar\" style={barStyle}></div>\n    )\n}\n\nexport default Bar;","import React from 'react';\nimport Bar from './Bar';\n\nconst BarChart = ({ bars }) => {\n    return (\n        <div className=\"chart\">\n            {bars.map((barHeight, barIndex) => {\n                return (\n                    <Bar key={barIndex} height={barHeight} />\n                )\n            })}\n        </div>\n    )\n}\n\nexport default BarChart;","import React from 'react';\n\nconst ColorBar = ({ color }) => {\n\n    const colorBarStyle = {\n        backgroundColor: `hsl(${color}, 100%, 50%)`\n    }\n    \n    return (\n        <div className=\"color-bar\" style={colorBarStyle}></div>\n    )\n}\n\nexport default ColorBar;","import React from 'react';\nimport ColorBar from \"./ColorBar\";\n\nconst ColorMap = ({ bars }) => {\n\n    return (\n        <div className=\"chart\">\n            {bars.map((color, colorIndex) => {\n                return (\n                    <ColorBar key={colorIndex} color={color} />\n                )\n            })}\n        </div>\n    )\n}\n\nexport default ColorMap;","import React from 'react';\n\nconst PixelBar = ({ heights }) => {\n    const firstSegmentStyle = {\n        height: `${heights[0]}%`,\n        backgroundColor: '#000'\n    }\n    const secondSegmentStyle = {\n        height: `${heights[1]}%`,\n        backgroundColor: '#fff)'\n    }\n    const thirdSegmentStyle = {\n        height: `${heights[2]}%`,\n        backgroundColor: '#000'\n    }\n\n    \n    return (\n        <div className=\"pixel-bar\">\n            <div style={firstSegmentStyle}></div>\n            <div style={secondSegmentStyle}></div>\n            <div style={thirdSegmentStyle}></div>\n        </div>\n    )\n}\n\nexport default PixelBar;","import React from 'react';\nimport PixelBar from \"./PixelBar\";\n\nconst PixelMap = ({ bars }) => {\n\n    return (\n        <div className=\"chart\">\n            {bars.map((barHeights, barIndex) => {\n                return (\n                    <PixelBar key={barIndex} heights={barHeights} />\n                )\n            })}\n        </div>\n    )\n}\n\nexport default PixelMap;","import React, { useState, useEffect } from 'react';\nimport { Tab, Tabs } from 'react-bootstrap';\n\nimport DropdownMenu from '../DropdownMenu';\nimport ControlButtons from '../ControlButtons';\nimport sortFunctions from \"./utilities\";\n\nimport BarChart from './BarChart';\nimport ColorMap from './ColorMap';\nimport PixelMap from './PixelMap';\n// import PixelPainting from './PixelPainting';\n\nconst Sorting = () => {  \n    \n    const [ chartType, setChartType ] = useState(\"barChart\");\n    const [ bars, setBars] = useState(sortFunctions[chartType].shuffle());\n    const [ animations, setAnimations ] = useState([])\n    // Sort value used to set sorts and animations, honestly following three could be a single state item\n    const [ sort, setSort ] = useState(\"default\")\n    const [ sortType, setSortType ] = useState({function: sortFunctions[chartType].defaultSort });\n    const [ animationType, setAnimationType ] = useState({ function: sortFunctions[chartType].defaultSortAnimation });\n    \n    // Side effect for changing chart type, resets bars and animations every time chart is changed (currently, could save possibly)\n    useEffect(() => {\n        cancelAnimations(animations);\n        setSort(\"default\")\n        // Currently, bars are set by their personal functions but this will need to change if they are to be changeable dynamically\n        setBars(sortFunctions[chartType].shuffle())\n        setAnimations([])\n    }, [chartType])\n    \n    // As said above, this would probably be better if it were a single usestate hook but this is how sorts are changed presently\n    useEffect(() => {\n        const formatSortFunctionName = (sortText) => {\n            return `${sortText.split(' ')[0].toLowerCase()}Sort`\n        }\n        setSortType({ function: sortFunctions[chartType][formatSortFunctionName(sort)]})\n        setAnimationType({ function: sortFunctions[chartType][formatSortFunctionName(sort) + 'Animation']})\n    }, [sort, chartType])\n\n    // Changing the sort type cancels the previous animations and sets new ones\n    useEffect(() => {\n        restartAnimations(animations, bars);\n    }, [sortType, bars])\n\n\n    // Control functionality\n    const playAnimations = (animations) => {\n        animations.forEach((animation) => {\n            if (animation.playState !== \"finished\") { animation.play() }\n        })\n    }\n\n    const pauseAnimations = (animations) => {\n        animations.forEach((animation) => {\n            if (animation.playState !== \"finished\") { animation.pause() }\n        })\n    }\n\n    const restartAnimations = (animations) => {\n        cancelAnimations(animations);\n        const barAnimations = animationType.function(sortType.function(bars));\n        pauseAnimations(barAnimations)\n        setAnimations(barAnimations);\n    }\n\n    const resetAnimations = () => {\n        setSort(\"default\");\n    }\n\n    const cancelAnimations = animations => {\n        animations.forEach((animation) => {\n            animation.cancel();\n        })\n    }   \n\n    return (\n        <div>\n            <Tabs\n                id=\"controlled-tab-example\"\n                activeKey={chartType}\n                onSelect={(chart) => setChartType(chart)}\n            >\n                <Tab eventKey=\"barChart\" title=\"Bar Chart\">\n                    <BarChart bars={bars}/>\n                </Tab>\n                <Tab eventKey=\"colorMap\" title=\"Color Map\">\n                    <ColorMap bars={bars}/>\n                </Tab>\n                <Tab eventKey=\"pixelMap\" title=\"Pixel Map\">\n                    <PixelMap bars={bars}/>\n                </Tab>\n            </Tabs>\n            <DropdownMenu\n                type={\"Sorting\"}\n                select={setSort}\n                title={sort}\n                algorithms={[\"Bubble Sort\", \"Insertion Sort\", \"Selection Sort\", \"Merge Sort\", \"Quick Sort\", \"Radix Sort\"]}\n            />\n            <ControlButtons \n                buttons={[\n                    { \"function\": () => playAnimations(animations), text: \"Play\", disabled: (sort === \"default\"), tooltip: \"Choose a Sorting Algorithm\" } ,\n                    { \"function\": () => pauseAnimations(animations), text: \"Pause\", disabled: (sort === \"default\"), tooltip: \"Choose a Sorting Algorithm\" } ,\n                    { \"function\": () => restartAnimations(animations), text: \"Restart\", disabled: (sort === \"default\"), tooltip: \"Choose a Sorting Algorithm\" } ,\n                    { \"function\": () => resetAnimations(animations), text: \"Reset\", disabled: (sort === \"default\"), tooltip: \"Choose a Sorting Algorithm\" }\n                ]}\n            />\n        </div>\n    )\n}\n\nexport default Sorting;\n\n","import { useReducer } from 'react';\nimport { cloneDeep } from 'lodash';\n\nconst calculateCellDimensions = (noOfCellsAcross) => {\n    const noOfCellsHigh = Math.ceil(noOfCellsAcross * .45)\n    const normalizedNoOfCellsHigh = (noOfCellsHigh % 2 === 0)? noOfCellsHigh + 1 : noOfCellsHigh;\n    return { \n        cols: noOfCellsAcross, \n        // noOfCellsAcross must always be odd for walls to match up\n        rows: normalizedNoOfCellsHigh\n    };\n}\n\nconst calculateCanvasDimensions = (cellGridDimensions, cellSize) => {\n    return {\n        width: cellGridDimensions.cols * cellSize, \n        height: cellGridDimensions.rows * cellSize\n    }\n}\n\nconst getFilledCanvas = (cellGridDimensions) => {\n    const {rows, cols} = cellGridDimensions;\n    const fillGrid = [];\n    for (let row = 0; row < rows; row++) {\n        fillGrid.push([]);\n        for (let col = 0; col < cols; col++) {\n            fillGrid[row].push(\"wall\");\n        }\n    }\n    return fillGrid\n}\n\nconst getClearedCanvas = (cellGridDimensions) => {\n    const {rows, cols} = cellGridDimensions;\n    const fillGrid = [];\n    for (let row = 0; row < rows; row++) {\n        fillGrid.push([]);\n        for (let col = 0; col < cols; col++) {\n            fillGrid[row].push(\"path\");\n        }\n    }\n    return fillGrid\n}\n\nconst calculateCellSize = (windowInnerWidth, cellGridDimensions) => {\n    // Canvas should be .8 the width of the window, but this has to be set in the cellSize so that they match up\n    // Not doing it here makes it too confusing to match up the width and the height of the canvas\n    const viewportWidthMultiplier = .8\n    return viewportWidthMultiplier * windowInnerWidth / cellGridDimensions.cols\n}\n\nconst calculateCellGridDimensions = (noOfCellsAcross) => {\n    const noOfCellsHigh = Math.ceil(noOfCellsAcross * .45)\n    const normalizedNoOfCellsHigh = (noOfCellsHigh % 2 === 0)? noOfCellsHigh + 1 : noOfCellsHigh;\n    return { \n        cols: noOfCellsAcross, \n        // noOfCellsAcross must always be odd for walls to match up\n        rows: normalizedNoOfCellsHigh\n    };\n}\n\nconst getMouseCellLocation = (mousePosition, cellSize) => {\n    // Needs canvas to subtract size of bounding box\n    const canvas = document.getElementById('canvas');\n    const canvasBoundingBox = canvas.getBoundingClientRect();\n    // Returns [row, col]\n    return [Math.floor((mousePosition.y - canvasBoundingBox.y) / cellSize), Math.floor((mousePosition.x - canvasBoundingBox.x + .5) / cellSize)]\n}\n\nconst initializeCanvas = (initialState) => {\n    const windowInnerWidth = initialState.windowInnerWidth\n    const cellGridDimensions = calculateCellDimensions(initialState.cellGridWidth)\n    const cellSize = calculateCellSize(windowInnerWidth, cellGridDimensions)\n    const canvasDimensions = calculateCanvasDimensions(cellGridDimensions, cellSize)\n    const fullCanvas = getFilledCanvas(cellGridDimensions)\n    return {\n        windowInnerWidth,\n        cellGridDimensions,\n        cellSize,\n        canvasDimensions,\n        cellGrid: fullCanvas,\n        // Stored maze, for use in resetting\n        storedMaze: fullCanvas,\n        // Boolean for use in drawing functionality\n        isDrawing: false,\n        // Value for flipping cells when drawing\n        fillType: null,\n        // Saving previous point allows us to catch all points dragged over (as browser event has fairly slow fire rate)\n        previousPoint: [null, null]\n    }\n}\n\nconst canvasReducer = (canvas, action) => {   \n    switch (action.type) {\n        case \"resize-canvas\": {\n            // Recalculate canvas dimensions every time window dimensions change\n            const newWindowInnerWidth = action.payload.windowInnerWidth\n            const newCellSize = calculateCellSize(newWindowInnerWidth, canvas.cellGridDimensions)\n            const newCanvasDimensions = calculateCanvasDimensions(canvas.cellGridDimensions, newCellSize)\n            const newFullCanvas = getFilledCanvas(canvas.cellGridDimensions)\n            return {\n                ...canvas,\n                windowInnerWidth: newWindowInnerWidth,\n                cellSize: newCellSize,\n                canvasDimensions: newCanvasDimensions,\n                cellGrid: newFullCanvas,\n                storedMaze: newFullCanvas\n            }\n        }\n        case \"resize-cell\": {\n            // Recalculate cell size based on slider movement\n            const newCellGridDimensions = calculateCellGridDimensions(action.payload.newCellGridWidth)\n            const newCellSize = calculateCellSize(canvas.windowInnerWidth, newCellGridDimensions);\n            const newCanvasDimensions = calculateCanvasDimensions(newCellGridDimensions, newCellSize)\n            const newFullCanvas = getFilledCanvas(newCellGridDimensions)\n            return {\n                ...canvas,\n                cellGridDimensions: newCellGridDimensions,\n                cellSize: newCellSize,\n                canvasDimensions: newCanvasDimensions,\n                cellGrid: newFullCanvas,\n                storedMaze: newFullCanvas\n            }\n        }\n        case \"handle-mouse-down\": {\n            // Clicking changes the color of that cell, clicking + holding has separate (line-drawing) functionality\n            const [row, col] = getMouseCellLocation(action.payload.mousePosition, canvas.cellSize);\n            const newCellGrid = cloneDeep(canvas.cellGrid);\n            // Fill type remains constant as the opposite of cell content before the click, so you can draw lines after click\n            const flippedCellContent = (newCellGrid[row][col] === \"wall\") ? \"path\" : \"wall\"\n            newCellGrid[row][col] = flippedCellContent;\n            return {\n                ...canvas,\n                isDrawing: true,\n                previousPoint: [row, col],\n                fillType: flippedCellContent,\n                cellGrid: newCellGrid,\n                storedMaze: newCellGrid\n            }\n        }\n        case \"handle-mouse-out-up\": {\n            // Unclicking and moving out of frame/canvas turns drawing off\n            return {\n                ...canvas,\n                isDrawing: false,\n                previousPoint: [null, null]\n            }\n        }\n        case \"handle-mouse-move\": {\n            // Moving while mouse being held draws manhattan lines on the canvas (if drawing)\n            const [row, col] = getMouseCellLocation(action.payload.mousePosition, canvas.cellSize);\n            const isPreviousPoint = (row === canvas.previousPoint[0] && col === canvas.previousPoint[1])\n            if (canvas.isDrawing && !isPreviousPoint) {\n                const newCells = [...canvas.cellGrid];\n                // Find all cells in between two points by:\n                // Finding Manhattan distance values between the two points\n                const [rowDiff, colDiff] = [row - canvas.previousPoint[0], col - canvas.previousPoint[1]];\n                // Choosing which one is larger (in absolute terms)\n                const maxDiff = Math.max(Math.abs(rowDiff), Math.abs(colDiff));\n                // Cycling through all cells in between previousPoint and current one\n                // Add the smallest jump along the line between cells that will change value of one of the cells\n                for (let i = 0; i < maxDiff; i++) {\n                    const [rowJump, colJump] = [rowDiff * ((i+1) / maxDiff), colDiff * ((i+1) / maxDiff)];\n                    const [mRow, mCol] = [Math.floor(canvas.previousPoint[0] + rowJump), Math.floor(canvas.previousPoint[1] + colJump)];\n                    newCells[mRow][mCol] = canvas.fillType;\n    \n                }\n                return {\n                    ...canvas,\n                    cellGrid: newCells,\n                    storedMaze: newCells,\n                    previousPoint: [row, col]\n                }\n            }\n            return {...canvas}\n        }\n        case \"fill-cell-grid\": {\n            const fullCellGrid = getFilledCanvas(canvas.cellGridDimensions);\n            return {\n                ...canvas,\n                cellGrid: fullCellGrid,\n                storedMaze: fullCellGrid\n            }\n        }\n        case \"clear-cell-grid\": {\n            const clearCellGrid = getClearedCanvas(canvas.cellGridDimensions);\n            return {\n                ...canvas,\n                cellGrid: clearCellGrid,\n                storedMaze: clearCellGrid\n            }\n        }\n        case \"save-stored-maze\": {\n            return {\n                ...canvas,\n                storedMaze: action.payload.storedMaze\n            }\n        }\n        case \"load-stored-maze\": {\n            return {\n                ...canvas,\n                cellGrid: cloneDeep(canvas.storedMaze)\n            }\n        }\n        case \"animate-maze\": {\n            return {\n                ...canvas,\n                cellGrid: action.payload.newCellGrid\n            }\n        }\n        // case \"draw-cells\": {\n        //     const colorDict = {\n        //         \"wall\": '#444',\n        //         \"path\": '#fff',\n        //         \"node\": \"#0000ff\",\n        //         \"searched\": \"#ff0000\",\n        //         \"backtrack\": \"#ffff00\"\n        //     }\n        //     const ctx = action.payload.cnv.getContext('2d');\n        //     for (let row = 0; row < canvas.cellGrid.length; row++) {\n        //         for (let col = 0; col < canvas.cellGrid[row].length; col++) {\n        //             const cell = canvas.cellGrid[row][col];\n                    \n        //             ctx.fillStyle = colorDict[cell];\n        //             ctx.fillRect(col * canvas.cellSize, row * canvas.cellSize, canvas.cellSize, canvas.cellSize);\n        //         }\n        //     }\n        // }\n        default:\n            throw new Error()\n    }\n}\n\nexport const useCanvas = (initialState) => {\n    return useReducer(canvasReducer, initializeCanvas(initialState))\n}","import { useReducer } from 'react';\n\nconst initializeAnimationState = (initialState) => {\n    return {\n        animations: { mazeAnimations: [], nodeAnimations: [], solvingAnimations: [], backtrackingAnimations: [] },\n        animationStack: [],\n        animationSpeed: initialState.animationSpeed,\n        playingAnimations: true\n    }\n}\n\nconst animationStateReducer = (animationState, action) => {\n    switch (action.type) {\n        case \"load-and-play-animations\": {\n            return {\n                ...animationState,\n                animations: {...animationState.animations, ...action.payload.animations},\n                animationStack: [...action.payload.animationStack],\n                playingAnimations: true\n            }\n        }\n        case \"update-animation-stack\": {\n            action.payload.canvasUpdateFunction();\n            return {\n                ...animationState,\n                animationStack: [...action.payload.animationStack]\n            }\n        }\n        case \"play-animations\": {\n            return {\n                ...animationState,\n                playingAnimations: true\n            }\n        }\n        case \"pause-animations\": {\n            return {\n                ...animationState,\n                playingAnimations: false\n            }\n        }\n        case \"reset-animations\": {\n            action.payload.resetFunction()\n            return {\n                ...animationState,\n                animationStack: [],\n                playingAnimations: false\n            }\n        }\n        case \"replay-animations\": {\n            action.payload.resetFunction()\n            return {\n                ...animationState,\n                animationStack: [...animationState.animations.solvingAnimations, ...animationState.animations.backtrackingAnimations],\n                playingAnimations: true\n            }\n        }\n        case \"set-animation-speed\": {\n            return {\n                ...animationState,\n                animationSpeed: action.payload.animationSpeed\n            }\n        }\n        default:\n            throw new Error()\n    }\n}\n\n\nexport const useAnimationState = (initialState) => {\n    return useReducer(animationStateReducer, initializeAnimationState(initialState))\n}","export const calculateCanvasSize = (noOfCellsAcross, cellSize) => {\n    // Canvas dims are .8vw, .4vh (height is 1/2 cells across)\n    const canvasViewportDims = {width: .8, height: .8}\n    const canvasDims = { \n        width: canvasViewportDims.width * noOfCellsAcross * cellSize, \n        // # of Cells across will always be odd, so rounding up 1/2 is also odd\n        height: canvasViewportDims.height * Math.ceil(noOfCellsAcross / 2) * cellSize\n    }\n    return canvasDims;\n}\n\nexport const recalculateCanvasSize = (noOfCells, windowDims, cellSize) => {\n\n    // // Canvas dims are .8vw, .7vh\n    // const canvasViewportDims = {width: .8, height: .7}\n    // const canvasDims = {\n    //     width: Math.floor(canvasViewportDims.width * windowDims.width * noOfCells, \n    //     height: Math.floor(windowDims.width * canvasViewportDims.width/cellSize) * noOfCells * .5\n    // }\n    // return canvasDims;\n}\n\nexport const getFullCanvas = (canvasDimensions, cellSize) => {\n    // Construct Grid of Cells\n    const [cols, rows] = [Math.floor(canvasDimensions.width / cellSize), Math.floor(canvasDimensions.height / cellSize)]\n    console.log(cols, rows);\n    const fillGrid = [];\n    // Builds a rows*cols nested array full of walls\n    for (let row = 0; row < rows; row++) {\n        fillGrid.push([])\n        for (let col = 0; col < cols; col++) {\n            fillGrid[row].push(\"wall\")\n        }\n    }\n    return fillGrid\n}\n\nexport const getClearCanvas = (canvasDimensions, cellSize) => {\n    // Construct Grid of Cells\n    const [cols, rows] = [canvasDimensions.width / cellSize, canvasDimensions.height / cellSize]\n    const fillGrid = [];\n    // Builds a rows*cols nested array full of walls\n    for (let row = 0; row < rows; row++) {\n        fillGrid.push([])\n        for (let col = 0; col < cols; col++) {\n            fillGrid[row].push(\"path\")\n        }\n    }\n    return fillGrid\n}\n\n// Generate initial maze\nexport const generateMaze = (grid, algorithm) => {\n\n    // Number of total columns and total rows\n    let mazeGrid = JSON.parse(JSON.stringify(grid)); // Deep copy grid so as not to mutate\n\n    // Animate drawing the entrance and exit\n    const [entrance, exit, start] = [[0, 1], [mazeGrid.length - 1, mazeGrid[0].length - 2], [1, 1]]\n    let mazeAnimations = [entrance, exit];\n\n    // Add entrance and exit to state, and to grid\n    mazeGrid[entrance[0]][entrance[1]] = \"path\";\n    mazeGrid[exit[0]][exit[1]] = \"path\";\n\n    // Calls with start as current and previous node; this is to allow for previous node to be used in recursive call\n    let mazeFinished;\n    let mazeAlgorithm;\n    switch (algorithm) {\n        case \"Eller's Algorithm\":\n            mazeAlgorithm = ellersMazeAlgorithm\n            break;\n        case \"Recursive Backtracking\":\n            mazeAlgorithm = depthFirstMazeAlgorithm\n            break;\n        case \"default\" :\n            mazeAlgorithm = defaultMazeAlgorithm;\n            break;\n        default:\n            break;\n    }\n\n    [mazeGrid, mazeAnimations, mazeFinished] = mazeAlgorithm(start, start, mazeGrid, mazeAnimations)\n    mazeAnimations = mazeAnimations.map((animation) => {\n        return {location: animation, type: \"path\"}\n    })\n    // Add a set number of loops to the maze\n    // const loops = 200;\n    // [mazeGrid, mazeAnimations] = loopMaker(mazeGrid, mazeAnimations, loops);\n\n    let [nodeAnimations, ] = nodeFinder(mazeGrid, entrance, exit)\n    nodeAnimations = nodeAnimations.map((animation) => {\n        return {location: animation, type: \"node\"}\n    })\n    const animations = { mazeAnimations, nodeAnimations }\n\n    return [mazeGrid, animations, mazeFinished]\n}\n\nconst shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\nconst defaultMazeAlgorithm = (startNode, prevNode, origMazeGrid, animations) => {\n    return [origMazeGrid, animations, true]\n}\n\nconst ellersMazeAlgorithm = (startNode, prevNode, origMazeGrid, animations) => {\n    const mazeGrid = JSON.parse(JSON.stringify(origMazeGrid)) // Deep copy so as not to mutate original array\n\n    let setNoCounter = 1; // To keep track of set names, so there's no repeats\n    for (let i = 1; i < mazeGrid[1].length - 1; i += 2) {\n        mazeGrid[1][i] = setNoCounter; // Initialize the cells of the first row to each exist in their own set.\n        animations.push([1,i])\n        setNoCounter++;\n    }\n\n    for (let j = 1; j < mazeGrid.length - 2; j += 2) {  // Repeat until the last row is reached\n        \n        for (let i = 1; i < mazeGrid[j].length - 1; i += 2) {// Randomly join adjacent cells, but only if they are not in the same set.\n            if (mazeGrid[j][i+2] !== undefined && mazeGrid[j][i] !== mazeGrid[j][i + 2]) {\n                if (Math.random() < .5) { // Some of the cells joined together, so left side and right of wall must match\n                    mazeGrid[j][i + 1] = mazeGrid[j][i];\n                    mazeGrid[j][i + 2] = mazeGrid[j][i];\n                    animations.push([j, i+1])\n                }\n            }\n        }\n        \n        let placeHolder = 1;\n        while (placeHolder < mazeGrid[j].length ) {// For each set, randomly create vertical connections downward to the next row\n            \n            const setNo = mazeGrid[j][placeHolder] // Number stored in grid for current set\n            let setCounter = 1;\n            while (mazeGrid[j][placeHolder + setCounter * 2] === setNo) { // Counts how many in a row have the same setNo\n                setCounter += 1\n            }\n            \n            // For each set, randomly create a random number (1+) of vertical connections downward to the next row.\n            const extensionNo = 1 + Math.floor(Math.random() * setCounter) * .5;\n            let extensionCounter = 0;\n            while (extensionCounter < extensionNo) {  // Keeps cycling until correct number of columns are created\n                const extensionColumn = Math.floor(Math.random() * setCounter) * 2;\n                if (mazeGrid[j + 1][placeHolder + extensionColumn] === \"wall\") {\n                    mazeGrid[j + 1][placeHolder + extensionColumn] = setNo;\n                    animations.push([j + 1, placeHolder + extensionColumn]);\n                    mazeGrid[j + 2][placeHolder + extensionColumn] = setNo;\n                    animations.push([j + 2, placeHolder + extensionColumn]);\n                    extensionCounter ++\n                }\n            } // Consecutive columns are linked together in next section\n\n            \n\n            placeHolder += setCounter*2; // Moves to the next set\n        }\n        \n        for (let l = 1; l < mazeGrid[j].length - 1; l += 2) { \n            if (mazeGrid[j + 2][l] === \"wall\") {// Flesh out the next row by putting any remaining cells into their own sets.\n                mazeGrid[j + 2][l] = setNoCounter;\n                animations.push([j + 2, l])\n                setNoCounter++\n            } \n        }\n    }\n    for (let i = 1; i < mazeGrid[0].length - 2; i+=2) { //For the last row, join all adjacent cells that do not share a set\n        if (mazeGrid[mazeGrid.length - 2][i] !== mazeGrid[mazeGrid.length - 2][i + 2]) {\n            mazeGrid[mazeGrid.length - 2][i + 1] = mazeGrid[mazeGrid.length - 2][i];\n            animations.push([mazeGrid.length - 2, i + 1]);\n            mazeGrid[mazeGrid.length - 2][i + 2] = mazeGrid[mazeGrid.length - 2][i];\n            animations.push([mazeGrid.length - 2, i + 2]);\n        }\n    }\n\n    const pathMazeGrid = []\n    for (let i = 0; i < mazeGrid.length; i++) {\n        const row = [];\n        for (let j = 0; j < mazeGrid[i].length; j++) {\n            if (mazeGrid[i][j] !== \"wall\") {\n                row.push(\"path\")\n            } else {\n                row.push(\"wall\")\n            }\n        }\n        pathMazeGrid.push(row)\n    }\n    \n\n    \n    return [pathMazeGrid, animations, true]\n    \n}\n\nconst depthFirstMazeAlgorithm = (startNode, prevNode, mazeGrid, animations) => {\n    // Draws maze using recursive depth-first algorithm\n    const node = startNode;\n\n    const [row, col] = node;\n\n    mazeGrid[row][col] = \"path\";\n    const [prevRow, prevCol] = prevNode\n    mazeGrid[prevRow][prevCol] = \"path\";\n    let deadEnd = false;\n\n    let newAnimations = [...animations, prevNode, node] // Add current node to path animation\n    const directionArray = shuffle([...Array(4).keys()]); // Create a random array of directions to choose from\n    for (let i = 0; i < 4; i++) {  // Choose the next direction to go in, or return dead end\n        const direction = directionArray[i]\n        switch (direction) {\n            case 0: // Up: if potential path column above is not edge or filled\n                if (((row - 2) >= 0) && (mazeGrid[row - 2][col] === \"wall\")) {\n                    const [midNode, newNode] = [[row - 1, col], [row - 2, col]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n            case 1: // Right: if two squares to the right is not over edge or filled\n                if (((col + 2) < mazeGrid[row].length) && (mazeGrid[row][col + 2] === \"wall\")) {\n                    const [midNode, newNode] = [[row, col + 1], [row, col + 2]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n            case 2: // Down: if potential path column below is not edge or filled\n\n                if (((row + 2) < mazeGrid.length) && (mazeGrid[row + 2][col] === \"wall\")) {\n                    const [midNode, newNode] = [[row + 1, col], [row + 2, col]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n            case 3: // Left: if two squares to the left is not over edge or filled\n                if (((col - 2) >= 0) && (mazeGrid[row][col - 2] === \"wall\")) {\n                    const [midNode, newNode] = [[row, col - 1], [row, col - 2]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n            default:\n                break;\n        }\n    }\n    deadEnd = true\n    return [mazeGrid, newAnimations, deadEnd]\n}\n\n// const loopMaker = (mazeGrid, mazeAnimations, loopsRequired) => {\n//     let loopsMade = 0;\n//     while (loopsMade < loopsRequired) {\n//         // Not selecting the bottom 20 % of the maze makes loops more likely to form\n//         // Only selects numbers between 1 and 80% of mazeGrid length\n//         const randRow = Math.floor(Math.random() * (mazeGrid.length * .8 - 1)) + 1\n//         // Select any column except for first and last\n//         const randCol = Math.floor(Math.random() * (mazeGrid[0].length - 2)) + 1\n//         if ( // Forms loops better by only choosing walls sandwiched between two other walls, but not 3 ways corners\n//             mazeGrid[randRow][randCol] === \"wall\"\n//             && (\n//                 (mazeGrid[randRow + 1][randCol] === \"wall\" && mazeGrid[randRow - 1][randCol] === \"wall\" && mazeGrid[randRow][randCol + 1] !== \"wall\" && mazeGrid[randRow][randCol - 1] !== \"wall\") ||\n//                 (mazeGrid[randRow][randCol + 1] === \"wall\" && mazeGrid[randRow][randCol - 1] === \"wall\" && mazeGrid[randRow + 1][randCol] !== \"wall\" && mazeGrid[randRow - 1][randCol] !== \"wall\")\n//             )\n//         ) {\n//             mazeGrid[randRow][randCol] = \"path\"\n//             mazeAnimations.push([randRow, randCol])\n//             loopsMade++\n//         }\n//     }\n\n//     return [mazeGrid, mazeAnimations]\n// }\n\nexport const nodeFinder = (mazeGrid, entrance, exit) => { // Finds nodes, points at which the maze either turns or forks, for use in building graphs\n    const nodeAnimations = [];\n    const nodeList = []; // List of nodes with the location and directions of nearest nodes\n\n    // Add the start of the maze to the animations\n    nodeAnimations.push(entrance)\n\n    nodeList.push([...entrance, [2]])\n\n    for (let row = 1; row < mazeGrid.length - 1; row++) { // Cycles through rows and columns, searching for nodes in each odd row/col\n        for (let col = 1; col < mazeGrid[0].length - 1; col++) {\n            const directions = [];\n            for (let direction = 0; direction < 4; direction++) {\n\n                switch (direction) {\n                    case 0:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row - 1][col] === \"path\") { // Up: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 1:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col + 1] === \"path\") { // Right: if potential path column right is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 2:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row + 1][col] === \"path\") { // Down: if potential path column down is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 3:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col - 1] === \"path\") { // Left: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (directions.length === 1) { // If dead end, corner, or intersection\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 2 && (directions[0] - directions[1]) % 2 !== 0) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 3 || directions.length === 4) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            }\n\n        }\n    }\n    // Add the end of the maze to the animations\n    nodeAnimations.push(exit)\n    nodeList.push([...exit, [0]])\n\n    const nodeMazeGrid = JSON.parse(JSON.stringify(mazeGrid))    // Deep copy the maze grid\n    nodeList.forEach(node => nodeMazeGrid[node[0]][node[1]] = \"node\")\n\n    const nodeWeights = weightFinder(nodeMazeGrid, nodeList)\n\n    return [nodeAnimations, nodeWeights]\n}\n\nconst weightFinder = (nodeMazeGrid, nodeList) => {\n    const nodeWeights = {};\n    nodeList.forEach(node => {\n        const [row, col] = [node[0], node[1]];\n        const nodeDirections = []\n        const directions = node[2]\n        directions.forEach(direction => {\n            let i = 1;\n\n\n            switch (direction) {\n                case 0: // Up\n                    while (row - i >= 0 && nodeMazeGrid[row - i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 1: // Right\n                    while (col + i < nodeMazeGrid[row].length && nodeMazeGrid[row][col + i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 2: // Down\n                    while (row + i < nodeMazeGrid.length && nodeMazeGrid[row + i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 3: // Left\n                    while (col - i >= 0 && nodeMazeGrid[row][col - i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                default:\n                    break;\n            }\n        })\n        nodeWeights[`${row},${col}`] = nodeDirections\n    })\n    return nodeWeights;\n}\n","export const nodeFinder = (mazeGrid, entrance, exit) => { // Finds nodes, points at which the maze either turns or forks, for use in building graphs\n    const nodeAnimations = [];\n    const nodeList = []; // List of nodes with the location and directions of nearest nodes\n\n    // Add the start of the maze to the animations\n    nodeAnimations.push(entrance)\n\n    nodeList.push([...entrance, [2]])\n\n    for (let row = 1; row < mazeGrid.length - 1; row++) { // Cycles through rows and columns, searching for nodes in each odd row/col\n        for (let col = 1; col < mazeGrid[0].length - 1; col++) {\n            const directions = [];\n            for (let direction = 0; direction < 4; direction++) {\n\n                switch (direction) {\n                    case 0:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row - 1][col] === \"path\") { // Up: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 1:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col + 1] === \"path\") { // Right: if potential path column right is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 2:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row + 1][col] === \"path\") { // Down: if potential path column down is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 3:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col - 1] === \"path\") { // Left: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (directions.length === 1) { // If dead end, corner, or intersection\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 2 && (directions[0] - directions[1]) % 2 !== 0) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 3 || directions.length === 4) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            }\n\n        }\n    }\n    // Add the end of the maze to the animations\n    nodeAnimations.push(exit)\n    nodeList.push([...exit, [0]])\n\n    const nodeMazeGrid = JSON.parse(JSON.stringify(mazeGrid))    // Deep copy the maze grid\n    nodeList.forEach(node => nodeMazeGrid[node[0]][node[1]] = \"node\")\n\n    const nodeWeights = weightFinder(nodeMazeGrid, nodeList)\n\n    return [nodeAnimations, nodeWeights]\n}\n\nconst weightFinder = (nodeMazeGrid, nodeList) => { // Finds weights for building an edge graph of the maze\n    const nodeWeights = {};\n    nodeList.forEach(node => {\n        const [row, col] = [node[0], node[1]];\n        const nodeDirections = []\n        const directions = node[2]\n        directions.forEach(direction => {\n            let i = 1;\n\n\n            switch (direction) {\n                case 0: // Up\n                    while (row - i >= 0 && nodeMazeGrid[row - i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 1: // Right\n                    while (col + i < nodeMazeGrid[row].length && nodeMazeGrid[row][col + i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 2: // Down\n                    while (row + i < nodeMazeGrid.length && nodeMazeGrid[row + i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 3: // Left\n                    while (col - i >= 0 && nodeMazeGrid[row][col - i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                default:\n                    break;\n            }\n        })\n        nodeWeights[`${row},${col}`] = nodeDirections\n    })\n    return nodeWeights;\n}\n\nconst shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\n\n// Maze-solving algorithms:\n\nexport const solveMaze = (grid, defaults, algorithm) => {\n    const newGrid = JSON.parse(JSON.stringify(grid)); // Deep copy of grid\n    const animations = { solvingAnimations: [], backtrackingAnimations: [] };\n\n    let solvingAlgorithm;\n    switch (algorithm) {\n        case \"Depth-First Search\":\n            solvingAlgorithm = depthFirstSearchSolvingAlgorithm;\n            break;\n        case \"Breadth-First Search\":\n            solvingAlgorithm = breadthFirstSearchSolvingAlgorithm\n            break;\n        case \"Djikstra's Algorithm\":\n            solvingAlgorithm = dijkstrasSolvingAlgorithm\n            break;\n        case \"A* Search Algorithm\":\n            solvingAlgorithm = aStarSolvingAlgorithm\n            break;\n        default: \n            solvingAlgorithm = defaultSolvingAlgorithm;\n            break;\n    }\n\n    solvingAlgorithm(defaults.start, defaults.enter, defaults.exit, newGrid, animations)\n    const mappedSolvingAnimations = animations.solvingAnimations.map((animation) => {\n        return {location: animation, type: \"searched\"}\n    })\n    const mappedBacktrackingAnimations = animations.backtrackingAnimations.map((animation) => {\n        return {location: animation, type: \"backtrack\"}\n    })\n    \n    const mappedAnimations = {\n        solvingAnimations: mappedSolvingAnimations,\n        backtrackingAnimations: mappedBacktrackingAnimations\n    }\n    return mappedAnimations\n}\n\nconst defaultSolvingAlgorithm = (startNode, prevNode, origMazeGrid, animations) => {\n    return false\n}\n\nconst depthFirstSearchSolvingAlgorithm = (startNode, prevNode, endNode, newGrid, animations) => {\n    const node = startNode;\n\n    if ((node[0] === endNode[0]) && (node[1] === endNode[1])) {\n        animations.backtrackingAnimations.push(node)\n        animations.backtrackingAnimations.push(prevNode)\n        return true\n    }\n\n    let mazeEndFound = false;\n    const [row, col] = node;\n    newGrid[row][col] = \"checked\";\n    animations.solvingAnimations.push(node)\n\n    const directionArray = shuffle([...Array(4).keys()]);\n    for (let i = 0; i < 4; i++) {\n\n        const direction = directionArray[i]\n\n        switch (direction) {\n\n            case 0: // Up: checks if 2 squares up is not over edge and there is a path toward that direction\n                if ((row - 1 >= 0) && (newGrid[row - 1][col] === \"path\")) {\n                    const newNode = [row - 1, col];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n\n                }\n                break;\n            case 1: // Right: checks if 2 squares right is not over edge and there is a path toward that direction\n                if ((col + 1 < newGrid[row].length) && (newGrid[row][col + 1] === \"path\")) {\n                    const newNode = [row, col + 1];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n                }\n                break;\n            case 2: // Down: checks if 2 squares down is not over edge and there is a path toward that direction\n                if ((row + 1 < newGrid.length) && (newGrid[row + 1][col] === \"path\")) {\n                    const newNode = [row + 1, col];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n                }\n                break;\n            case 3: // Left: checks if 2 squares left is not over edge and there is a path toward that direction\n                if ((col - 1 >= 0) && (newGrid[row][col - 1] === \"path\")) {\n                    const newNode = [row, col - 1];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n                }\n                break;\n            default:\n                break;\n\n        }\n        if (mazeEndFound) {\n            animations.backtrackingAnimations.push(prevNode)\n            return mazeEndFound\n        }\n\n    }\n    return mazeEndFound\n\n}\n\nconst breadthFirstSearchSolvingAlgorithm = (startNode, prevNode, endNode, newGrid, animations) => {\n\n    const frontierQueue = [];\n    const backtrackDictionary = {};\n    frontierQueue.push(prevNode);\n    let checking = true;\n\n\n    const breadthFirstRecursion = (frontierQueue, endNode, newGrid, animations, backtrackDictionary) => {\n        const node = frontierQueue.shift();\n\n        if (node[0] === endNode[0] && node[1] === endNode[1]) return false\n\n        animations.solvingAnimations.push(node);\n\n        const [row, col] = [node[0], node[1]];\n        newGrid[row][col] = \"checked\";\n\n        for (let i = 0; i < 4; i++) {\n            const direction = i;\n\n            switch (direction) {\n\n                case 0: // Up: checks if 2 squares up is not over edge and there is a path toward that direction\n                    if ((row - 1 >= 0) && (newGrid[row - 1][col] === \"path\")) {\n                        const newNode = [row - 1, col];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n                case 1: // Right: checks if 2 squares right is not over edge and there is a path toward that direction\n                    if ((col + 1 < newGrid[row].length) && (newGrid[row][col + 1] === \"path\")) {\n                        const newNode = [row, col + 1];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n                case 2: // Down: checks if 2 squares down is not over edge and there is a path toward that direction\n                    if ((row + 1 < newGrid.length) && (newGrid[row + 1][col] === \"path\")) {\n                        const newNode = [row + 1, col];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n                case 3: // Left: checks if 2 squares left is not over edge and there is a path toward that direction\n                    if ((col - 1 >= 0) && (newGrid[row][col - 1] === \"path\")) {\n                        const newNode = [row, col - 1];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n        return (frontierQueue.length > 0)\n    }\n\n    while (checking) {\n        checking = breadthFirstRecursion(frontierQueue, endNode, newGrid, animations, backtrackDictionary);\n    }\n\n    let btNode = endNode;\n    animations.backtrackingAnimations.push(btNode);\n    while (!((btNode[0] === startNode[0]) && (btNode[1] === startNode[1]))) {\n        const dictionaryString = `${btNode[0]},${btNode[1]}`;\n        btNode = backtrackDictionary[dictionaryString]\n        animations.backtrackingAnimations.push(btNode);\n    }\n\n}\n\nconst nodeAndWeightFinder = (mazeGrid, baseNode) => { // Finds nodes, points at which the maze either turns or forks, and their corresponding weights to the base node\n    const nodeAndWeightList = []; // List of nodes with the location and directions of nearest nodes \n    \n    for (let direction = 0; direction < 4; direction++) {\n        \n        let counter = 1;\n        switch (direction) {\n            case 0:\n                if (baseNode[0] - counter >= 0 && mazeGrid[baseNode[0] - counter][baseNode[1]] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0] - counter, baseNode[1]])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n            case 1:\n                if (baseNode[1] + counter < mazeGrid[0].length && mazeGrid[baseNode[0]][baseNode[1] + counter] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0], baseNode[1] + counter])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n            case 2:\n                if (baseNode[0] + counter < mazeGrid.length && mazeGrid[baseNode[0] + counter][baseNode[1]] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0] + counter, baseNode[1]])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n            case 3:\n                if (baseNode[1] - counter >= 0 && mazeGrid[baseNode[0]][baseNode[1] - counter] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0], baseNode[1] - counter])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n            default:\n                break;\n        }\n    }\n    \n    return nodeAndWeightList\n}\n\nconst isANode = (mazeGrid, node) => { // Checks if selected location is a node or not\n    // Scans four directions and \n    const [row, col] = node;\n    \n    const directions = [];\n    if (row > 0 && mazeGrid[row - 1][col] === \"path\") { // Up\n        directions.push(0)\n    } \n    if (col < mazeGrid[0].length - 1 && mazeGrid[row][col + 1] === \"path\") { // Right\n        directions.push(1)\n    } \n    if (row < mazeGrid.length - 1 && mazeGrid[row + 1][col] === \"path\") { // Down\n        directions.push(2)\n    } \n    if (col > 0 && mazeGrid[row][col - 1] === \"path\") { // Left\n        directions.push(3)\n    }\n    \n    if (directions.length === 1 || directions.length > 2 || (directions[0] - directions[1]) % 2 !== 0) { \n        // Is either a dead end or a t-junction/4-way or a corner \n        return true\n    }\n\n    return false\n}\n\n\nconst dijkstrasSolvingAlgorithm = (startNode, enterNode, exitNode, mazeGrid, animations, heuristic = false) => {\n    const lowestUnvisitedNode = (distances, visitedNodes) => {\n        let min = [null, Infinity];\n        Object.entries(distances).forEach((distance) => {\n            const currentDistanceStr = distance[0];\n            if (!visitedNodes[currentDistanceStr] && distances[currentDistanceStr] < min[1]) {\n                min = [currentDistanceStr, distance[1]];\n            }\n        })\n\n        return (min[0] === null) ? null : min[0].split(\",\");\n    }\n\n    // Initialize distances dictionary for start and end nodes\n    const distances = {};\n    distances[`${enterNode[0]},${enterNode[1]}`] = 0;\n    distances[`${exitNode[0]},${exitNode[1]}`] = Infinity;\n\n    // Initialize parent nodes dictionary\n    const parentNodes = {};\n    parentNodes[`${exitNode[0]},${exitNode[1]}`] = null;\n\n    // Initialize arrays for visited and unvisited nodes\n    const visitedNodes = {};\n    let unvisitedNodes = nodeAndWeightFinder(mazeGrid, enterNode)\n    \n    let currentNode = enterNode;\n    animations.solvingAnimations.push(enterNode)\n    while (currentNode !== null && (currentNode[0] !== exitNode[0] && currentNode[1] !== exitNode[1])) { // Exits if out of nodes or at end\n        // Converts back from string to number\n        const [row, col] = [Number(currentNode[0]), Number(currentNode[1])];\n        animations.solvingAnimations.push([row, col])\n\n        const currentNodeStr = `${row},${col}` // String for node currently looking at, for lookup in dictionary\n        const currentDistance = distances[currentNodeStr]; // Distance of current node from start\n        unvisitedNodes = nodeAndWeightFinder(mazeGrid, [row, col]) // Find weights of all attached nodes, meaning distances from current node\n        unvisitedNodes.forEach((edge) => { // Cycle through all nearest nodes\n            const [direction, edgeDistance] = [edge[0], edge[1]] // Direction and distance/weight to that direction\n            let childNode, childNodeStr, totalWeight;\n            let hWeight = 0; // Additional heuristic weight, for use in A*\n            const distanceFromStart = currentDistance + edgeDistance\n\n            switch (direction) {\n                case 0: //Up\n                    // Make new node and node string\n                    childNode = [row - edgeDistance, col];  \n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0; \n                    totalWeight = distanceFromStart + hWeight\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                case 1: //Right\n                    // Make new node and node string\n                    childNode = [row, col + edgeDistance];\n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0;\n                    totalWeight = distanceFromStart + hWeight;\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                case 2: //Down\n                    // Make new node and node string\n                    childNode = [row + edgeDistance, col];\n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0;\n                    totalWeight = distanceFromStart + hWeight;\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                case 3: //Left\n                    // Make new node and node string\n                    childNode = [row, col - edgeDistance];\n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0;\n                    totalWeight = distanceFromStart + hWeight;\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        })\n\n        visitedNodes[currentNodeStr] = unvisitedNodes;\n        currentNode = lowestUnvisitedNode(distances, visitedNodes)\n    }\n\n    if (currentNode === null || (currentNode[0] === exitNode[0] && currentNode[1] === exitNode[1])) {\n        let backtrackNode = exitNode;\n        animations.backtrackingAnimations.push(backtrackNode)\n\n        while (backtrackNode[0] !== enterNode[0] && backtrackNode[1] !== enterNode[1]) {\n            const newNodeStrArray = parentNodes[`${backtrackNode[0]},${backtrackNode[1]}`].split(\",\")\n            backtrackNode = [Number(newNodeStrArray[0]), newNodeStrArray[1]]\n            animations.backtrackingAnimations.push(backtrackNode)\n\n        }\n    }\n}\n\nconst aStarSolvingAlgorithm = (startNode, enterNode, exitNode, mazeGrid, animations) => {\n    dijkstrasSolvingAlgorithm(startNode, enterNode, exitNode, mazeGrid, animations, true)\n}","import React from 'react'\n\nconst Slider = (props) => {\n    return (\n        <div className=\"sliders-bar\">\n            <label htmlFor={props.name}>{props.label}</label>\n            <input \n                onChange={(e) => props.setValue(e.target.value)} \n                type=\"range\" \n                min={props.range.min}\n                max={props.range.max}\n                step={props.range.step}\n                value={props.value} \n                className=\"slider\" \n                id={props.name}\n            ></input>\n        </div>\n    )\n}\n\nexport default Slider;","import React from 'react';\nimport DropdownMenu from '../DropdownMenu.js';\nimport ControlButtons from '../ControlButtons.js';\nimport Slider from '../Slider';\n\nconst ControlWrapper = (props) => {\n    return (\n        <>\n            <Slider \n            value={props.animationState.animationSpeed}\n            setValue={(newAnimationSpeed) => props.updateAnimationState({type: \"set-animation-speed\", payload: { animationSpeed: newAnimationSpeed }})}\n            name={\"animationSpeedSlider\"}\n            label={\"Animation Speed\"}\n            range={{ \"min\": 1, \"max\": 100, \"step\": 1 }}\n            />\n            <Slider \n                value={props.canvas.cellGridDimensions.cols}\n                setValue={(newCellGridWidth) => props.updateCanvas({type: \"resize-cell\", payload: { newCellGridWidth }})}\n                name={\"noOfCellsAcrossSlider\"}\n                label={\"Cell Size\"}\n                range={{ \"min\": 11, \"max\": 201, \"step\": 2 }}\n            />\n            {props.children}\n            <div>\n                <div className=\"input-group justify-content-center\" >\n                    <DropdownMenu\n                        type={\"Maze Generation\"}\n                        select={props.setMazeGenAlgo}\n                        title={props.mazeGenAlgo}\n                        algorithms={[\"Eller's Algorithm\", \"Recursive Backtracking\"]}\n                    />\n                    <DropdownMenu\n                        type={\"Maze Solving\"}\n                        select={props.setMazeSolveAlgo}\n                        title={props.mazeSolveAlgo}\n                        algorithms={[\"Depth-First Search\", \"Breadth-First Search\", \"Djikstra's Algorithm\", \"A* Search Algorithm\"]}\n                    />\n                </div>\n                <ControlButtons\n                    size = {\"sm\"}\n                    buttons={[\n                        { \"function\": () => props.updateCanvas({type: \"clear-cell-grid\"}), text: \"Clear\", disabled: false },\n                        { \"function\": () => props.updateCanvas({type: \"fill-cell-grid\"}), text: \"Fill\", disabled: false },\n                        { \"function\": props.handleGenerateMaze, text: \"Generate Maze\", disabled: (props.mazeGenAlgo === \"default\"), tooltip: \"Choose a Maze Generation Algorithm\" },\n                        { \"function\": props.handleSolveMaze, text: \"Solve Maze\", disabled: (props.mazeSolveAlgo === 'default'), tooltip: \"Choose a Maze Solving Algorithm\" },\n                    ]}\n                />\n                <ControlButtons\n                    size = {\"sm\"}\n                    buttons={[\n                        { \"function\": () => props.updateAnimationState({type: \"play-animations\"}), text: \"Play\", disabled: (props.mazeGenAlgo === \"default\"), tooltip: \"Choose a Maze Generation Algorithm\" },\n                        { \"function\": () => props.updateAnimationState({type: \"pause-animations\"}), text: \"Pause\", disabled: (props.mazeGenAlgo === \"default\"), tooltip: \"Choose a Maze Generation Algorithm\" },\n                        { \"function\": () => props.updateAnimationState({type: \"reset-animations\", payload: { resetFunction: () => props.updateCanvas({type: \"load-stored-maze\"})}}), text: \"Reset\", disabled: (props.mazeGenAlgo === \"default\"), tooltip: \"Choose a Maze Generation Algorithm\" },\n                        { \"function\": () => props.updateAnimationState({type: \"replay-animations\", payload: { resetFunction: () => props.updateCanvas({type: \"load-stored-maze\"})}}), text: \"Replay\", disabled: (props.mazeGenAlgo === \"default\"), tooltip: \"Choose a Maze Generation Algorithm\" },\n                    ]}\n                />\n            </div>\n        </>\n    )\n}\n\nexport default ControlWrapper;","import React, { useState, useEffect, useReducer } from 'react';\nimport { useInterval } from '../useInterval'\nimport { useCanvas } from '../useCanvas'\nimport { useAnimationState } from '../useAnimationState'\n// Import all functions from a single file as a dictionary, order them better as well\nimport { generateMaze, getFullCanvas, getClearCanvas, recalculateCanvasSize } from './PathfindingFunctions/mazeGeneratingFunctions.js';\n\nimport { solveMaze } from './PathfindingFunctions/mazeSolvingFunctions.js';\n\nimport DropdownMenu from '../DropdownMenu.js';\nimport ControlButtons from '../ControlButtons.js';\nimport Slider from '../Slider';\nimport { cloneDeep } from 'lodash';\nimport ControlWrapper from './ControlWrapper';\n\nconst Pathfinding = () => {\n\n    const [ canvas, updateCanvas ] = useCanvas({cellGridWidth: 101, windowInnerWidth: window.innerWidth})\n    const [ animationState, updateAnimationState ] = useAnimationState({ animationSpeed: 50 })\n\n    const [ mazeGenAlgo, setMazeGenAlgo ] = useState(\"default\")\n    const [ mazeSolveAlgo, setMazeSolveAlgo ] = useState(\"default\")\n\n    // Reset window dimension state every time window resized (w/ cleanup function)\n    useEffect(() => {\n        const handleWindowResize = () => updateCanvas({type: \"resize-canvas\", payload: {windowInnerWidth: window.innerWidth}})\n        window.addEventListener('resize', handleWindowResize);\n\n        return _ => {\n            window.removeEventListener('resize', handleWindowResize)\n        }\n    })\n\n    // Redraw canvas cells every time array representing them are changed\n    useEffect(() => {\n        const cnv = document.getElementById('canvas');\n        const ctx = cnv.getContext('2d');\n        for (let row = 0; row < canvas.cellGrid.length; row++) {\n            for (let col = 0; col < canvas.cellGrid[row].length; col++) {\n                const cell = canvas.cellGrid[row][col];\n                const colorDict = {\n                    \"wall\": '#444',\n                    \"path\": '#fff',\n                    \"node\": \"#0000ff\",\n                    \"searched\": \"#ff0000\",\n                    \"backtrack\": \"#ffff00\"\n                }\n                ctx.fillStyle = colorDict[cell];\n                ctx.fillRect(col * canvas.cellSize, row * canvas.cellSize, canvas.cellSize, canvas.cellSize);\n            }\n        }\n    }, [canvas.cellGrid, canvas.cellSize])\n    \n    const handleGenerateMaze = () => {\n        // Fill in cells for use by algorithm, default is walls\n        updateCanvas({type: \"fill-cell-grid\"})\n        const [ mazeGrid, {mazeAnimations, nodeAnimations}, ] = generateMaze(cloneDeep(canvas.cellGrid), mazeGenAlgo)\n        // Store maze for use in reset\n        updateCanvas({type: \"save-stored-maze\", payload: { storedMaze: cloneDeep(mazeGrid) }})\n        updateAnimationState({\n            type: \"load-and-play-animations\", \n            payload: { \n                animations: {\n                    mazeAnimations,\n                    nodeAnimations\n                },\n                animationStack: [...mazeAnimations]\n            }\n        })\n    }\n\n    const handleSolveMaze = () => {\n        // Uses a set of default entry, exit, start points; these are adjustable but currently not part of state\n        const defaults = { enter: [0, 1], exit: [canvas.cellGrid.length - 1, canvas.cellGrid[0].length - 2], start: [1, 1] };\n\n        // // Reset cells to those stored in maze cells, in case a solution already in place\n        updateCanvas({type: \"load-stored-maze\"})\n        const {solvingAnimations, backtrackingAnimations} = solveMaze(cloneDeep(canvas.cellGrid), defaults, mazeSolveAlgo)\n        updateAnimationState({\n            type: \"load-and-play-animations\", \n            payload: { \n                animations: {\n                    solvingAnimations,\n                    backtrackingAnimations\n                },\n                animationStack: [...solvingAnimations, ...backtrackingAnimations]\n            }\n        })\n    }\n\n    // Custom hook for animations - can control speed, choose type, control playback\n    // Basically works by just burning through the animation stack until it's gone\n    useInterval(() => {     \n        const newCellGrid = [...canvas.cellGrid];\n        const remainingStack = [...animationState.animationStack]\n        const noOfUpdates = animationState.animationSpeed;\n        for (let i = 0; i < noOfUpdates; i++) {\n            if (remainingStack.length) {\n                const animation = remainingStack.shift();\n                const [row, col] = animation.location;\n                newCellGrid[row][col] = animation.type;\n            } else {\n                updateAnimationState({type: \"pause-animations\"})\n            }\n        }\n        updateAnimationState({\n            type: \"update-animation-stack\", \n            payload: { \n                animationStack: remainingStack,\n                canvasUpdateFunction: () => updateCanvas({type: \"animate-maze\", payload: { newCellGrid }})\n            }\n        })\n    }, animationState.playingAnimations ? 5 : null);\n\n    // Dropdown Generating and Solving Algorithm Change Side-effects\n\n    useEffect(() => {\n        updateCanvas({type: \"fill-cell-grid\"})\n    }, [mazeGenAlgo])\n\n    useEffect(() => {\n        updateAnimationState({type: \"reset-animations\", payload: { resetFunction: () => updateCanvas({type: \"load-stored-maze\"})}})\n    }, [mazeSolveAlgo])\n\n    return (\n        <ControlWrapper\n            canvas={canvas} updateCanvas={updateCanvas}\n            animationState={animationState} updateAnimationState={updateAnimationState}\n            mazeGenAlgo={mazeGenAlgo} setMazeGenAlgo={setMazeGenAlgo}\n            mazeSolveAlgo={mazeSolveAlgo} setMazeSolveAlgo={setMazeSolveAlgo}\n            handleGenerateMaze={handleGenerateMaze} handleSolveMaze={handleSolveMaze}\n        >\n            <div style={{ width: canvas.canvasDimensions.width, height: canvas.canvasDimensions.height }}>\n                <canvas \n                    id=\"canvas\"\n                    \n                    width={canvas.canvasDimensions.width}\n                    height={canvas.canvasDimensions.height}\n                    \n                    onMouseDown={(e) => updateCanvas({type: \"handle-mouse-down\", payload: { mousePosition : {x: e.clientX, y:e.clientY} }})} \n                    onMouseUp={() => updateCanvas({type: \"handle-mouse-out-up\"})} \n                    onMouseOut={() => updateCanvas({type: \"handle-mouse-out-up\"})} \n                    onMouseMove={(e) => updateCanvas({type: \"handle-mouse-move\", payload: { mousePosition : {x: e.clientX, y:e.clientY} }})}\n                />\n            </div>\n        </ControlWrapper>\n    )\n}\n\nexport default Pathfinding;\n\n// Still left to do:\n// Bugs: \n//      Below are basicall all just one bug, issues surrounding the way maze algorithms interact with state\n//      Get maze building working with no maze\n//      What happens if no solution to maze?\n\n{/* <Slider \nvalue={animationState.animationSpeed}\nsetValue={(newAnimationSpeed) => updateAnimationState({type: \"set-animation-speed\", payload: { animationSpeed: newAnimationSpeed }})}\nname={\"animationSpeedSlider\"}\nlabel={\"Animation Speed\"}\nrange={{ \"min\": 1, \"max\": 100, \"step\": 1 }}\n/>\n<Slider \nvalue={canvas.cellGridDimensions.cols}\nsetValue={(newCellGridWidth) => updateCanvas({type: \"resize-cell\", payload: { newCellGridWidth }})}\nname={\"noOfCellsAcrossSlider\"}\nlabel={\"Cell Size\"}\nrange={{ \"min\": 11, \"max\": 201, \"step\": 2 }}\n/>\n\n<div className=\"input-group justify-content-center\" >\n                    <DropdownMenu\n                        type={\"Maze Generation\"}\n                        select={setMazeGenAlgo}\n                        title={mazeGenAlgo}\n                        algorithms={[\"Eller's Algorithm\", \"Recursive Backtracking\"]}\n                    />\n                    <DropdownMenu\n                        type={\"Maze Solving\"}\n                        select={setMazeSolveAlgo}\n                        title={mazeSolveAlgo}\n                        algorithms={[\"Depth-First Search\", \"Breadth-First Search\", \"Djikstra's Algorithm\", \"A* Search Algorithm\"]}\n                    />\n                </div>\n                <ControlButtons\n                    size = {\"sm\"}\n                    buttons={[\n                        { \"function\": () => updateCanvas({type: \"clear-cell-grid\"}), text: \"Clear\", disabled: false },\n                        { \"function\": () => updateCanvas({type: \"fill-cell-grid\"}), text: \"Fill\", disabled: false },\n                        { \"function\": handleGenerateMaze, text: \"Generate Maze\", disabled: (mazeGenAlgo === \"default\"), tooltip: \"Choose a Maze Generation Algorithm\" },\n                        { \"function\": handleSolveMaze, text: \"Solve Maze\", disabled: (mazeSolveAlgo === 'default'), tooltip: \"Choose a Maze Solving Algorithm\" },\n                    ]}\n                />\n                <ControlButtons\n                    size = {\"sm\"}\n                    buttons={[\n                        { \"function\": () => updateAnimationState({type: \"play-animations\"}), text: \"Play\", disabled: (mazeGenAlgo === \"default\"), tooltip: \"Choose a Maze Generation Algorithm\" },\n                        { \"function\": () => updateAnimationState({type: \"pause-animations\"}), text: \"Pause\", disabled: (mazeGenAlgo === \"default\"), tooltip: \"Choose a Maze Generation Algorithm\" },\n                        { \"function\": () => updateAnimationState({type: \"reset-animations\", payload: { resetFunction: () => updateCanvas({type: \"load-stored-maze\"})}}), text: \"Reset\", disabled: (mazeGenAlgo === \"default\"), tooltip: \"Choose a Maze Generation Algorithm\" },\n                        { \"function\": () => updateAnimationState({type: \"replay-animations\", payload: { resetFunction: () => updateCanvas({type: \"load-stored-maze\"})}}), text: \"Replay\", disabled: (mazeGenAlgo === \"default\"), tooltip: \"Choose a Maze Generation Algorithm\" },\n                    ]}\n                />\n            </div> */}","import { useEffect, useRef } from 'react';\n\nexport const useInterval = (callback, delay) => {\n    const savedCallback = useRef();\n\n    useEffect(() => {\n        savedCallback.current = callback;\n    }, [callback])\n\n    useEffect(() => {\n        const tick = () => {\n            savedCallback.current()\n        }\n        if (delay !== null) {\n            let id = setInterval(tick, delay)\n            return () => clearInterval(id)\n        }\n    }, [delay])\n}\n","import React from 'react';\nimport { BrowserRouter as Router, Route, Switch, Redirect } from 'react-router-dom';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport './app.css';\n\nimport Navbar from './Components/MainNavbar';\n\nimport MainPage from './Components/MainPage';\nimport Sorting from './Components/Sorting';\nimport Pathfinding from './Components/Pathfinding'\n\nconst App = () => {\n\n    return (\n        <div className=\"page\">\n            <Router>\n                <Navbar/>\n\n                <Switch>\n                    <Redirect exact from= \"/algorithm-visualization\" to=\"/main\" />\n                    <Route path=\"/main\" component={MainPage} />\n                    <Route path=\"/sorting\" component={Sorting} />\n                    <Route path=\"/pathfinding\" component={Pathfinding} />\n                </Switch>\n            </Router>\n        </div>\n    )\n};\n\nexport default App;\n\n// Still left to do:\n// Bugs: \n//      Below are basicall all just one bug, issues surrounding the way maze algorithms interact with state\n//      Get maze building working with no maze\n//      What happens if no solution to maze?\n//      Reset/replay only works on the first go round, then seems to be resetting  to the solved maze\n//      Changing solving algorithm should reset to just maze w/ no solutions\n//      Fix all console warnings on all pages\n//      Sorting bug: why animations starts early\n\n// explanations, for\n//      Games Readme\n//      Games How to play\n//      Sorting Algorithms\n//      Sorting Complexity\n//      Pathfinding algorithms\n//      Games Title\n\n// Nice but not necessary:\n//      Sorting slider for bars\n//      Build a dynamic slider for maze cell size\n//      Refactor sorting algorithm state to be a single state value\n//      Sorting animations play automatically?\n//      Go through and comment/possibly refactor algorithms\n//      Refactor sorting animations using usewebanimations custom hook, allowing for better/safer dependencies\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n    <App/>, document.getElementById('root')\n);\n\n"],"sourceRoot":""}