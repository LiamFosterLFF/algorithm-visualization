{"version":3,"sources":["Sorting/BarChart/Bar.js","Sorting/utilities/index.js","Sorting/BarChart/index.js","Sorting/ColorMap/ColorBar.js","Sorting/utilities/colorBarFunctions.js","Sorting/ColorMap/index.js","Sorting/PixelMap/PixelBar.js","Sorting/utilities/pixelMapFunctions.js","Sorting/PixelMap/index.js","Sorting/index.js","Pathfinding/PathfindingFunctions/mazeGeneratingFunctions.js","Pathfinding/PathfindingFunctions/mazeSolvingFunctions.js","Pathfinding/PathfindingFunctions/mazeAnimatingFunctions.js","Pathfinding/index.js","App.js","index.js"],"names":["Bar","height","barStyle","className","style","bubbleSort","origArr","arr","animations","n","length","i","j","push","bubbleSortBarChartAnimation","chart","document","getElementsByClassName","barAnimations","forEach","animation","index","bar1","bar2","ht1","ht2","animate","backgroundColor","duration","delay","fill","selectionSort","minIndex","swap","selectionSortBarChartAnimation","console","log","baseChild","checkingChild","minChild","baseHeight","minHeight","insertionSort","insertionSortBarChartAnimation","swapElLt","swapElLtHt","swapElRt","swapElRtHt","mergeSort","origArray","mainArray","auxArray","mergeSortHelper","startIdx","endIdx","midIdx","Math","floor","merge","k","comparison","range","mergeSortBarChartAnimation","compareEl1","compareEl2","swapEl","swapHt","quickSort","array","partition","left","right","pivot","quickSortHelper","quickSortBarChartAnimation","leftEl","rightEl","leftHt","rightHt","barChartRadixSort","countBuckets","max","toString","l","stringNum","d","shift","counter","num","radixSortBarChartAnimation","element","BarChart","sort","useState","bars","barList","bar","barHeight","random","barShuffle","setAnimations","function","sortType","setSortType","animationType","setAnimationType","useEffect","resetAnimations","runAnimations","map","cancel","barIndex","key","onClick","playState","play","playAnimations","pause","pauseAnimations","ColorBar","color","colorBarStyle","colorMapBubbleSort","colorMapBubbleSortAnimation","swapColor1","swapColor2","colorMapSelectionSortAnimation","baseColor","minColor","colorMapInsertionSortAnimation","swapElLtColor","swapElRtColor","colorMapMergeSortAnimation","swapColor","colorMapQuickSortAnimation","leftColor","rightColor","radixSort","colorMapRadixSortAnimation","ColorMap","colorList","hueValue","colorShuffle","colors","colorAnimations","colorIndex","PixelBar","heights","firstSegmentStyle","secondSegmentStyle","thirdSegmentStyle","pixelBarShuffle","pixelBarList","pixBar","pixelBarHeights","shuffle","pixelMapBubbleSortAnimation","compareEl1Bottom","childNodes","compareEl1Top","compareEl2Bottom","compareEl2Top","swapHt1Top","swapHt1Bottom","swapHt2Top","swapHt2Bottom","pixelMapSelectionSort","pixelMapSelectionSortAnimation","baseChildTop","baseChildBottom","minChildTop","minChildBottom","baseTopHeight","baseBottomHeight","minTopHeight","minBottomHeight","pixelMapInsertionSort","pixelMapInsertionSortAnimation","swapElLtTop","swapElLtBottom","swapElLtTopHeight","swapElLtBottomHeight","swapElRtTop","swapElRtBottom","swapElRtTopHeight","swapElRtBottomHeight","pixelMapMergeSort","pixelMapMergeSortAnimation","swapElTop","swapElBottom","swapTopHeight","swapBottomHeight","pixelMapQuickSort","pixelMapQuickSortAnimation","leftElTop","leftElBottom","rightElTop","rightElBottom","leftTopHeight","leftBottomHeight","rightTopHeight","rightBottomHeight","pixelMapRadixSort","numArr","pixelMapRadixSortAnimation","elementTop","elementBottom","heightTop","heightBottom","PixelMap","pixelBars","barHeights","Sorting","setSort","id","to","path","clearCanvas","canvas","cellSize","ctx","current","getContext","width","clearRect","cols","rows","clearGrid","row","col","fillCanvas","fillStyle","fillRect","fillGrid","ellersMazeAlgorithm","startNode","prevNode","origMazeGrid","mazeGrid","JSON","parse","stringify","setNoCounter","undefined","placeHolder","setNo","setCounter","extensionNo","extensionCounter","extensionColumn","pathMazeGrid","depthFirstMazeAlgorithm","node","prevRow","prevCol","newAnimations","directionArray","Array","keys","nodeFinder","entrance","exit","nodeAnimations","nodeList","directions","direction","nodeMazeGrid","weightFinder","nodeWeights","nodeDirections","depthFirstSearchSolvingAlgorithm","endNode","newGrid","backtrackingAnimations","mazeEndFound","solvingAnimations","newNode","breadthFirstSearchSolvingAlgorithm","frontierQueue","backtrackDictionary","checking","breadthFirstRecursion","btNode","nodeAndWeightFinder","baseNode","nodeAndWeightList","isANode","dijkstrasSolvingAlgorithm","enterNode","exitNode","heuristic","lowestUnvisitedNode","distances","visitedNodes","min","Infinity","Object","entries","distance","currentDistanceStr","split","parentNodes","unvisitedNodes","currentNode","Number","currentNodeStr","currentDistance","edge","childNode","childNodeStr","totalWeight","edgeDistance","distanceFromStart","backtrackNode","newNodeStrArray","aStarSolvingAlgorithm","animateMazeDrawing","mazeAnimations","drawPath","drawingAnimations","window","requestAnimationFrame","Pathfinding","useRef","x","y","canvasDimensions","setCanvasDimensions","grid","setGrid","setMazeAnimations","setSolvingAnimations","drawSpeed","mazeGenAlgo","setMazeGenAlgo","mazeSolveAlgo","setMazeSolveAlgo","initialGrid","getBoundingClientRect","initializeGrid","innerHeight","mazeGenerating","setMazeGenerating","algorithm","mazeFinished","start","mazeAlgorithm","generateMaze","setBacktrackingAnimations","mazeSolving","setMazeSolving","defaults","enter","solvingAlgorithm","solveMaze","test","setTimeout","animateMazeSolving","animateMazeSolvingBacktrack","mouseDown","setMouseDown","fillType","setFillType","onChange","type","value","class","e","clientY","clientX","onMouseDown","onMouseUp","onMouseOut","onMouseMove","ref","App","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.941d1ee8.chunk.js","sourcesContent":["import React from 'react';\n\nconst Bar = ({ height }) => {\n    \n    const barHeightinPercent = height/10;\n    const barStyle = {\n        height: `${barHeightinPercent}%`\n    }\n    \n    return (\n        <div className=\"bar\" style={barStyle}></div>\n    )\n}\n\nexport default Bar;","import $ from 'jquery';\n\n// ***Sort Functions***\n// Bubble Sort\nexport const bubbleSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n                animations.push([[j, arr[j+1]], [j + 1, arr[j]]])\n            }\n        }\n        \n    }\n    return animations\n}\n\nexport const bubbleSortBarChartAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const bar1 = chart[animation[0][0]];\n        const bar2 = chart[animation[1][0]];\n        const ht1 = `${animation[0][1] / 10}%`\n        const ht2 = `${animation[1][1] / 10}%`\n        \n        // Highlight the two elements to be swapped, and swap their heights\n        barAnimations.push(\n            bar1.animate([{backgroundColor: 'rgb(51, 226, 217)'}, {backgroundColor: 'red'}], {duration: duration, delay: index * duration}),\n            bar1.animate([{ height: ht2 }, { height: ht2 }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            bar2.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration }),\n            bar2.animate([{ height: ht1 }, { height: ht1 }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n        )\n    })\n\n    return barAnimations\n}\n\n// Selection Sort \nexport const selectionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        let minIndex = i;\n        for (let j = i; j < n; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j\n            }\n            // Checks if sort has reached the end of Array, if so, records that there will be a swap between i and min\n            let swap = false;\n            if (j === n - 1) {\n                swap = true;\n            }\n            // Push the base Element, the element being checked, the current minimum, and an indication of whether a swap has occurred\n            animations.push([[i, arr[i]], [j, arr[j]], [minIndex, arr[minIndex]], swap])\n        }\n        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n    return animations\n}\n\n\nexport const selectionSortBarChartAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 3;// The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n    console.log(('a'));\n    \n    animations.forEach((animation, index) => {\n        const baseChild = chart[animation[0][0]];\n        const checkingChild = chart[animation[1][0]];\n        const minChild = chart[animation[2][0]];\n        const baseHeight = `${animation[0][1] / 10}%`\n        const minHeight = `${animation[2][1] / 10}%`\n        const swap = animation[3];\n\n        // Highlight the base of the section being checked, and the current element being compared against the minimum, in bubbleSort, while the min is highlighted in red\n        barAnimations.push(\n            baseChild.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'blue' }], { duration: duration, delay: index * duration }),\n            checkingChild.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'blue' }], { duration: duration, delay: index * duration }),\n            minChild.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration }),\n        )\n        // if the two elements are to be swapped, perform the swap \n        if (swap === true) {\n            barAnimations.push(\n                minChild.animate([{ height: baseHeight }, { height: baseHeight }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChild.animate([{ height: minHeight }, { height: minHeight }], { fill: \"forwards\", duration: duration, delay: index * duration })\n            )\n        }\n    })\n\n    return barAnimations\n}\n\n// Insertion Sort \nexport const insertionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n\n\n    // Move up through the array one at a time, and insert each new element into already sorted numbers to the left in its proper (ascending) position \n    for (let i = 1; i < n; i++) {\n        const key = arr[i]\n        let j = i - 1;\n        while (j >= 0 && arr[j] > arr[j+1]) {\n            animations.push([[j, arr[j]], [j+1, arr[j+1]]]);\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            j = j - 1\n        }\n    }\n    \n    return animations\n}\n\n\nexport const insertionSortBarChartAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElLt = chart[animation[0][0]];\n        const swapElLtHt = `${animation[0][1] / 10}%`;\n        const swapElRt = chart[animation[1][0]];\n        const swapElRtHt = `${animation[1][1] / 10}%`;\n        \n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElRt.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            swapElRt.animate([{ height: swapElLtHt }, { height: swapElLtHt }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElLt.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            swapElLt.animate([{ height: swapElRtHt }, { height: swapElRtHt }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n    \n    return barAnimations\n}\n\n\n// Merge Sort \nexport const mergeSort = (origArray) => {\n    // Two separate arrays, one main one and one to hold swapped values until they can be unswapped. Avoids having to create a buffer array during the sorting process\n    const mainArray = [...origArray];\n    const auxArray = [...mainArray]\n    const n = mainArray.length\n    const animations = [];\n    if (n <= 1) {\n        return mainArray\n    }\n    // Initialize first function call\n    mergeSortHelper(mainArray, 0, n - 1, auxArray, animations);\n    // console.log(\"main\", mainArray, \"aux\", auxArray);;\n\n    return animations;\n}\n\nconst mergeSortHelper = (mainArray, startIdx, endIdx, auxArray, animations) => {\n    // Base case, returns if only one element in array\n    if (startIdx === endIdx) return;\n\n    // Find middle index of array, place to split before coming merge\n    const midIdx = Math.floor((startIdx + endIdx) / 2);\n\n    // recursively call function on each half of the array, to keep splitting until base case of 1 is reached. Also, notice that auxArray and mainArray are swapped from initial function call; it's complicated but basically this allows the aux array and main array to keep switching back and forth and save the values from the previous merge, which means that I don't have to create a temporary array to hold the values\n    mergeSortHelper(auxArray, startIdx, midIdx, mainArray, animations);\n    mergeSortHelper(auxArray, midIdx + 1, endIdx, mainArray, animations);\n\n    // Call the merge function to sort the values and combine back together\n    merge(mainArray, startIdx, midIdx, endIdx, auxArray, animations)\n}\n\nconst merge = (mainArray, startIdx, midIdx, endIdx, auxArray, animations) => {\n    // Copies the values of the aux array into the main array, putting the next lowest value from either array at value k\n    let i = startIdx;\n    let j = midIdx + 1;\n    let k = startIdx;\n    \n    // Pick the lowest value from either array and put it into the main array\n    while (i <= midIdx && j <= endIdx) {\n        const animation = {};\n        animation.comparison = [i, j];\n        animation.range = [startIdx, endIdx]\n        if (auxArray[i] >= auxArray[j]) {\n            animation.swap = [k, auxArray[j]]\n            mainArray[k++] = auxArray[j++]\n        } else {\n            animation.swap = [k, auxArray[i]]\n            mainArray[k++] = auxArray[i++]\n        }\n        animations.push(animation);\n    }\n\n    // While there are still values in only one of the two arrays being merged, copy them in; they are already ordered from previous sorts \n    while (j <= endIdx) {\n        animations.push({\n            comparison: [j, j],\n            swap: [k, auxArray[j]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[j++]\n\n    }\n    while (i <= midIdx) {\n        animations.push({\n            comparison: [i, i],\n            swap: [k, auxArray[i]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[i++]\n    }\n}\n\nexport const mergeSortBarChartAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 30;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const compareEl1 = chart[animation.comparison[0]];\n        const compareEl2 = chart[animation.comparison[1]];\n        const swapEl = chart[animation.swap[0]];\n        const swapHt = `${animation.swap[1] / 10}%`;\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            compareEl1.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            compareEl2.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            swapEl.animate([{ height: swapHt }, { height: swapHt }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n// Quick Sort \nexport const quickSort = (origArray) => {\n    // Copy original array so as not to mutate it \n    const array = [...origArray];\n    const animations = [];\n\n    const quickSortHelper = (array, left, right, animations) => {\n        if (left >= right) return;\n\n        // Find the center index, by sorting from the two ends and so that everything to the left of the pivot is smaller, and everything right is larger\n        const index = partition(array, left, right);\n        \n        // split the array into two halves, and call recursively on the two halves \n        quickSortHelper(array, left, index - 1, animations);\n        quickSortHelper(array, index, right, animations);\n    }\n\n    const partition = (array, left, right) => {\n        // Pivot starts from right end of subarray \n        const pivot = right;\n        right--;\n        // Keep moving pointers towards middle until two pointers cross one another\n        while (left <= right) {\n            // Find a left side element smaller than pivot, and a right side one larger, and switch them \n            while (array[left] < array[pivot]) {\n                left++\n            }\n            while (array[right] > array[pivot]) {\n                right--\n            }\n            if (left <= right) {\n                animations.push([[left, array[left]], [right, array[right]], [pivot, array[pivot]]]);\n                [array[left], array[right]] = [array[right], array[left]]\n                left++\n                right--\n            }\n        }\n        // Move the pivot into the middle \n        animations.push([[left, array[left]], [pivot, array[pivot]], [pivot, array[pivot]]]);\n        [array[left], array[pivot]] = [array[pivot], array[left]]\n        return left;\n    }\n    // Initial function call \n    quickSortHelper(array, 0, array.length - 1)\n\n    return animations\n}\n\nexport const quickSortBarChartAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 30;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        \n        const leftEl = chart[animation[0][0]];\n        const rightEl = chart[animation[1][0]];\n        const pivot = chart[animation[2][0]];\n        const leftHt = `${animation[0][1] / 10}%`;\n        const rightHt = `${animation[1][1] / 10}%`;\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            leftEl.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            leftEl.animate([{ height: leftHt }, { height: rightHt }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightEl.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            rightEl.animate([{ height: rightHt }, { height: leftHt }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            pivot.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n\n// Radix Bar Sort \nexport const barChartRadixSort = (origArr) => {\n    const arr = [...origArr] // Copy original array so as not to mutate it\n    const animations = [];\n\n    // initialize an array subarrays representing numbers 0 through 9, according to their index in parent array \n    const countBuckets = [];\n    for (let i = 0; i < 10; i++) {\n        countBuckets[i] = []\n    }\n\n    let max = 0;\n    // find length of longest number by digits, by converting it to string and measuring its length, then comparing to all other numbers \n    for (let j = 0; j < arr.length; j++) {\n        max = (arr[j].toString().length > max) ? arr[j].toString().length : max;\n    }\n\n    // cycle through array once for each digit in longest number from array \n    for (let l = 0; l < max; l++) {\n\n        while (arr.length) {\n            const stringNum = arr[0].toString()  // Convert front number in array to string\n            const d = stringNum.length - l - 1 // Starting from rightmost digit on first iteration, then moving left on next iteration\n            const digit = (stringNum[d]) ? stringNum[d] : 0 // Select either that digit, or (if too short) use 0\n            countBuckets[digit].push(arr.shift()) // Remove number from array and place into bucket array corresponding to that digit\n        }\n        let counter = 0;\n        for (let i = 0; i < 10; i++) { // Cycle through all 10 counter arrays, from lowest to highest\n            while (countBuckets[i].length) {  // Cycle through counter array until empty\n                const num = countBuckets[i].shift() // Save number in variable, so it can be added both to old array and to animation\n                arr.push(num)\n                animations.push([num, counter])\n                counter++\n            }\n        }\n    }\n    return animations\n\n}\n\nexport const radixSortBarChartAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 30;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const element = chart[animation[1]];\n        const height = `${animation[0] / 10}%`;\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            element.animate([{ backgroundColor: 'red' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration }),\n            element.animate([{ height: height }, { height: height }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n\n\n// PixelMap Animations \n\n// Pixel Map Bubble Sort\nexport const pixelMapBubbleSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j][0] > arr[j + 1][0]) {\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n                animations.push([j, j + 1])\n            }\n        }\n    }\n    return animations\n}\n\n// Bubble Sort Pixel Mpa Animation\nexport const bubbleSortPixelMapAnimation = (animations, speed) => {\n    for (let i = 0; i < animations.length; i++) {\n        const [ind1, ind2] = animations[i]\n        setTimeout(() => {\n            const parent = document.getElementsByClassName('chart');\n            const child1 = parent[0].childNodes[ind1];\n            const child2 = parent[0].childNodes[ind2];\n            // console.log(child1);\n\n            // child1.style.backgroundColor = \"red\";\n            // child2.style.backgroundColor = \"red\";\n            for (let i = 0; i <= 2; i++) {\n                [child1.childNodes[i].style.height, child2.childNodes[i].style.height] = [child2.childNodes[i].style.height, child1.childNodes[i].style.height]\n\n            }\n            setTimeout(() => {\n                // child1.style.backgroundColor = \"rgb(51, 226, 217)\";\n                // child2.style.backgroundColor = \"rgb(51, 226, 217)\";\n            }, speed);\n        }, i * speed);\n    }\n}\n\n\n// ***Display Functions***\n\n// BarChart\nexport const barShuffle = (bars) => {\n    const barList = [];\n    for (let bar = 0; bar < bars; bar++) {\n        const barHeight = Math.floor(Math.random() * 1000);\n        barList.push(barHeight)\n    }\n    return barList;\n}\n\n\n// ColorMap\n\n\n\n\n\n// PixelMap\nconst shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\n\nexport const pixelBarShuffle = () => {\n    const pixelBarList = [];\n    const height = 200;\n    for (let pixBar = 0; pixBar < height; pixBar++) {\n        const pixelBarHeights = [height - pixBar - 1, 1, pixBar]\n        pixelBarList.push(pixelBarHeights)\n    }\n    return shuffle(pixelBarList)\n}\n\n\n// PixelPainting\n\n\n\n\n\n\n\n\n","import React, { useEffect, useState } from 'react';\n\nimport Bar from './Bar';\n\nimport { barShuffle, bubbleSort, bubbleSortBarChartAnimation, selectionSort, selectionSortBarChartAnimation, insertionSort, insertionSortBarChartAnimation, mergeSort, mergeSortBarChartAnimation, quickSort, quickSortBarChartAnimation, barChartRadixSort, radixSortBarChartAnimation } from \"../utilities\";\n\nconst BarChart = ({ sort }) => {\n    const [bars, setBars] = useState(barShuffle(100));\n    const [animations, setAnimations] = useState([])\n    const [sortType, setSortType] = useState({function: bubbleSort});\n    const [animationType, setAnimationType] = useState({ function: bubbleSortBarChartAnimation });\n    \n    useEffect(() => {\n        switch (sort) {\n            case \"bubble\":\n                setSortType({ function: bubbleSort})\n                setAnimationType({ function: bubbleSortBarChartAnimation })\n                break;\n            case \"selection\":\n                setSortType({ function: selectionSort})\n                setAnimationType({ function: selectionSortBarChartAnimation })\n                break;\n            case \"insertion\":\n                setSortType({ function: insertionSort})\n                setAnimationType({ function: insertionSortBarChartAnimation })\n                break;\n            case \"merge\":\n                setSortType({ function: mergeSort})\n                setAnimationType({ function: mergeSortBarChartAnimation })\n                break;\n            case \"quick\":\n                setSortType({ function: quickSort})\n                setAnimationType({ function: quickSortBarChartAnimation })\n                break;\n            case \"radix\":\n                setSortType({ function: barChartRadixSort})\n                setAnimationType({ function: radixSortBarChartAnimation })\n                break;\n            }\n        }, [sort])\n\n    useEffect(() => {\n        resetAnimations(animations)\n        runAnimations(bars)\n\n    }, [sortType])\n\n\n\n\n    const runAnimations = (bars) => {\n        const barAnimations = animationType.function(sortType.function(bars))\n        setAnimations(barAnimations)\n    }\n\n    const playAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") {\n                animation.play()\n            }\n        })\n    }\n\n    const pauseAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") {\n                animation.pause();\n            }\n        })\n    }\n\n    const resetAnimations = animations => {\n        animations.map((animation) => {\n            animation.cancel()\n        })\n    }   \n\n\n    return (\n            <div className=\"chart\">\n                {bars.map((barHeight, barIndex) => {\n                    return (\n                        <Bar key={barIndex} height={barHeight} />\n                    )\n                })}\n                <div className=\"buttons-bar\">\n                    <button onClick={() => resetAnimations(animations)}>Reset</button>\n                    <button onClick={() => playAnimations(animations)}>Play</button>\n                    <button onClick={() => pauseAnimations(animations)}>Pause</button>\n                </div>\n            </div>\n\n    )\n}\n\nexport default BarChart;","import React from 'react';\n\nconst ColorBar = ({ color }) => {\n\n    const colorBarStyle = {\n        backgroundColor: `hsl(${color}, 100%, 50%)`\n    }\n    // console.log(color);\n    \n    return (\n        <div className=\"color-bar\" style={colorBarStyle}></div>\n    )\n}\n\nexport default ColorBar;","// Generate Random Colors\nexport const colorShuffle = (bars) => {\n    const colorList = [];\n    for (let color = 0; color < bars; color++) {\n        const hueValue = Math.floor(Math.random() * 359)\n\n        colorList.push(hueValue)\n    }\n    return colorList\n}\n\n\n// ColorMap Bubble Sort\nexport const colorMapBubbleSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n\n    return animations\n}\n\n\n\n// Bubble Sort Color Map Animation\nexport const colorMapBubbleSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = .5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n    animations.forEach((animation, index) => {\n        const compareEl1 = chart[animation[0][0]];\n        const compareEl2 = chart[animation[1][0]];\n        const swapColor1 = animation[0][1];\n        const swapColor2 = animation[1][1];\n\n\n        // Exchange the colors of the two elements being selected\n        barAnimations.push(\n            compareEl1.animate([{ backgroundColor: `hsl(${swapColor2}, 100%, 50%)` }, { backgroundColor: `hsl(${swapColor2}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            compareEl2.animate([{ backgroundColor: `hsl(${swapColor1}, 100%, 50%)` }, { backgroundColor: `hsl(${swapColor1}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n\n        )\n\n    })\n    return barAnimations\n}\n\n// Selection Sort \nexport const selectionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        let minIndex = i;\n        for (let j = i; j < n; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j\n            }\n            // Checks if sort has reached the end of Array, if so, records that there will be a swap between i and min\n            let swap = false;\n            if (j === n - 1) {\n                swap = true;\n            }\n            // Push the base Element, the element being checked, the current minimum, and an indication of whether a swap has occurred\n            animations.push([[i, arr[i]], [j, arr[j]], [minIndex, arr[minIndex]], swap])\n        }\n        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n    return animations\n}\n\n\nexport const colorMapSelectionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = .5;// The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const baseChild = chart[animation[0][0]];\n        const minChild = chart[animation[2][0]];\n        const baseColor = animation[0][1]\n        const minColor = animation[2][1]\n        const swap = animation[3];\n\n        // if the two elements are to be swapped, perform the swap \n        if (swap === true) {\n            barAnimations.push(\n                minChild.animate([{ backgroundColor: `hsl(${baseColor}, 100%, 50%)` }, { backgroundColor: `hsl(${baseColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChild.animate([{ backgroundColor: `hsl(${minColor}, 100%, 50%)` }, { backgroundColor: `hsl(${minColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n            )\n        }\n    })\n\n    return barAnimations\n}\n\n// Insertion Sort \nexport const insertionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n\n\n    // Move up through the array one at a time, and insert each new element into already sorted numbers to the left in its proper (ascending) position \n    for (let i = 1; i < n; i++) {\n        const key = arr[i]\n        let j = i - 1;\n        while (j >= 0 && arr[j] > arr[j + 1]) {\n            animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            j = j - 1\n        }\n    }\n\n    return animations\n}\n\n\nexport const colorMapInsertionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElLt = chart[animation[0][0]];\n        const swapElLtColor = animation[0][1];\n        const swapElRt = chart[animation[1][0]];\n        const swapElRtColor = animation[1][1];\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElLt.animate([{ backgroundColor: `hsl(${swapElRtColor}, 100%, 50%)` }, { backgroundColor: `hsl(${swapElRtColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElRt.animate([{ backgroundColor: `hsl(${swapElLtColor}, 100%, 50%)` }, { backgroundColor: `hsl(${swapElLtColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n\n// Merge Sort \nexport const mergeSort = (origArray) => {\n    // Two separate arrays, one main one and one to hold swapped values until they can be unswapped. Avoids having to create a buffer array during the sorting process\n    const mainArray = [...origArray];\n    const auxArray = [...mainArray]\n    const n = mainArray.length\n    const animations = [];\n    if (n <= 1) {\n        return mainArray\n    }\n    // Initialize first function call\n    mergeSortHelper(mainArray, 0, n - 1, auxArray, animations);\n    // console.log(\"main\", mainArray, \"aux\", auxArray);;\n\n    return animations;\n}\n\nconst mergeSortHelper = (mainArray, startIdx, endIdx, auxArray, animations) => {\n    // Base case, returns if only one element in array\n    if (startIdx === endIdx) return;\n\n    // Find middle index of array, place to split before coming merge\n    const midIdx = Math.floor((startIdx + endIdx) / 2);\n\n    // recursively call function on each half of the array, to keep splitting until base case of 1 is reached. Also, notice that auxArray and mainArray are swapped from initial function call; it's complicated but basically this allows the aux array and main array to keep switching back and forth and save the values from the previous merge, which means that I don't have to create a temporary array to hold the values\n    mergeSortHelper(auxArray, startIdx, midIdx, mainArray, animations);\n    mergeSortHelper(auxArray, midIdx + 1, endIdx, mainArray, animations);\n\n    // Call the merge function to sort the values and combine back together\n    merge(mainArray, startIdx, midIdx, endIdx, auxArray, animations)\n}\n\nconst merge = (mainArray, startIdx, midIdx, endIdx, auxArray, animations) => {\n    // Copies the values of the aux array into the main array, putting the next lowest value from either array at value k\n    let i = startIdx;\n    let j = midIdx + 1;\n    let k = startIdx;\n\n    // Pick the lowest value from either array and put it into the main array\n    while (i <= midIdx && j <= endIdx) {\n        const animation = {};\n        animation.comparison = [i, j];\n        animation.range = [startIdx, endIdx]\n        if (auxArray[i] >= auxArray[j]) {\n            animation.swap = [k, auxArray[j]]\n            mainArray[k++] = auxArray[j++]\n        } else {\n            animation.swap = [k, auxArray[i]]\n            mainArray[k++] = auxArray[i++]\n        }\n        animations.push(animation);\n    }\n\n    // While there are still values in only one of the two arrays being merged, copy them in; they are already ordered from previous sorts \n    while (j <= endIdx) {\n        animations.push({\n            comparison: [j, j],\n            swap: [k, auxArray[j]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[j++]\n\n    }\n    while (i <= midIdx) {\n        animations.push({\n            comparison: [i, i],\n            swap: [k, auxArray[i]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[i++]\n    }\n}\n\nexport const colorMapMergeSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapEl = chart[animation.swap[0]];\n        const swapColor = animation.swap[1];\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapEl.animate([{ backgroundColor: `hsl(${swapColor}, 100%, 50%)` }, { backgroundColor: `hsl(${swapColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n        )\n    })\n\n    return barAnimations\n}\n\n// Quick Sort \nexport const quickSort = (origArray) => {\n    // Copy original array so as not to mutate it \n    const array = [...origArray];\n    const animations = [];\n\n    const quickSortHelper = (array, left, right, animations) => {\n        if (left >= right) return;\n\n        // Find the center index, by sorting from the two ends and so that everything to the left of the pivot is smaller, and everything right is larger\n        const index = partition(array, left, right);\n\n        // split the array into two halves, and call recursively on the two halves \n        quickSortHelper(array, left, index - 1, animations);\n        quickSortHelper(array, index, right, animations);\n    }\n\n    const partition = (array, left, right) => {\n        // Pivot starts from right end of subarray \n        const pivot = right;\n        right--;\n        // Keep moving pointers towards middle until two pointers cross one another\n        while (left <= right) {\n            // Find a left side element smaller than pivot, and a right side one larger, and switch them \n            while (array[left] < array[pivot]) {\n                left++\n            }\n            while (array[right] > array[pivot]) {\n                right--\n            }\n            if (left <= right) {\n                animations.push([[left, array[left]], [right, array[right]], [pivot, array[pivot]]]);\n                [array[left], array[right]] = [array[right], array[left]]\n                left++\n                right--\n            }\n        }\n        // Move the pivot into the middle \n        animations.push([[left, array[left]], [pivot, array[pivot]], [pivot, array[pivot]]]);\n        [array[left], array[pivot]] = [array[pivot], array[left]]\n        return left;\n    }\n    // Initial function call \n    quickSortHelper(array, 0, array.length - 1)\n\n    return animations\n}\n\nexport const colorMapQuickSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const leftEl = chart[animation[0][0]];\n        const rightEl = chart[animation[1][0]];\n        const leftColor = animation[0][1];\n        const rightColor = animation[1][1];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            leftEl.animate([{ backgroundColor: `hsl(${rightColor}, 100%, 50%)` }, { backgroundColor: `hsl(${rightColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightEl.animate([{ backgroundColor: `hsl(${leftColor}, 100%, 50%)` }, { backgroundColor: `hsl(${leftColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n\n// Radix Bar Sort \nexport const radixSort = (origArr) => {\n    const arr = [...origArr] // Copy original array so as not to mutate it\n    const animations = [];\n\n    // initialize an array subarrays representing numbers 0 through 9, according to their index in parent array \n    const countBuckets = [];\n    for (let i = 0; i < 10; i++) {\n        countBuckets[i] = []\n    }\n\n    let max = 0;\n    // find length of longest number by digits, by converting it to string and measuring its length, then comparing to all other numbers \n    for (let j = 0; j < arr.length; j++) {\n        max = (arr[j].toString().length > max) ? arr[j].toString().length : max;\n    }\n\n    // cycle through array once for each digit in longest number from array \n    for (let l = 0; l < max; l++) {\n\n        while (arr.length) {\n            const stringNum = arr[0].toString()  // Convert front number in array to string\n            const d = stringNum.length - l - 1 // Starting from rightmost digit on first iteration, then moving left on next iteration\n            const digit = (stringNum[d]) ? stringNum[d] : 0 // Select either that digit, or (if too short) use 0\n            countBuckets[digit].push(arr.shift()) // Remove number from array and place into bucket array corresponding to that digit\n        }\n        let counter = 0;\n        for (let i = 0; i < 10; i++) { // Cycle through all 10 counter arrays, from lowest to highest\n            while (countBuckets[i].length) {  // Cycle through counter array until empty\n                const num = countBuckets[i].shift() // Save number in variable, so it can be added both to old array and to animation\n                arr.push(num)\n                animations.push([num, counter])\n                counter++\n            }\n        }\n    }\n    return animations\n\n}\n\nexport const colorMapRadixSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const element = chart[animation[1]];\n        const color = animation[0];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            element.animate([{ backgroundColor: `hsl(${color}, 100%, 50%)` }, { backgroundColor: `hsl(${color}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n","import React, { useState, useEffect } from 'react';\nimport ColorBar from \"./ColorBar\";\nimport { colorShuffle, colorMapBubbleSort, colorMapBubbleSortAnimation, selectionSort, colorMapSelectionSortAnimation, insertionSort, colorMapInsertionSortAnimation, mergeSort, colorMapMergeSortAnimation, quickSort, colorMapQuickSortAnimation, radixSort, colorMapRadixSortAnimation } from '../utilities/colorBarFunctions';\n\nconst ColorMap = ({ sort }) => {\n    const [colors, setColors] = useState(colorShuffle(200))\n    const [animations, setAnimations] = useState([])\n    const [sortType, setSortType] = useState({ function: colorMapBubbleSort });\n    const [animationType, setAnimationType] = useState({ function: colorMapBubbleSortAnimation });\n\n    useEffect(() => {\n        switch (sort) {\n            case \"bubble\":\n                setSortType({ function: colorMapBubbleSort })\n                setAnimationType({ function: colorMapBubbleSortAnimation })\n                break;\n            case \"selection\":\n                setSortType({ function: selectionSort })\n                setAnimationType({ function: colorMapSelectionSortAnimation })\n                break;\n            case \"insertion\":\n                setSortType({ function: insertionSort })\n                setAnimationType({ function: colorMapInsertionSortAnimation })\n                break;\n            case \"merge\":\n                setSortType({ function: mergeSort })\n                setAnimationType({ function: colorMapMergeSortAnimation })\n                break;\n            case \"quick\":\n                setSortType({ function: quickSort })\n                setAnimationType({ function: colorMapQuickSortAnimation })\n                break;\n            case \"radix\":\n                setSortType({ function: radixSort })\n                setAnimationType({ function: colorMapRadixSortAnimation })\n                break;\n        }\n    }, [sort])\n\n    useEffect(() => {\n        resetAnimations(animations)\n        runAnimations(colors)\n    }, [sortType])\n\n    const runAnimations = (colors) => {\n        const colorAnimations = animationType.function(sortType.function(colors))\n        setAnimations(colorAnimations)\n    }\n\n    const playAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") {\n                animation.play()\n            }\n        })\n    }\n\n    const pauseAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") {\n                animation.pause();\n            }\n        })\n    }\n\n    const resetAnimations = animations => {\n        animations.map((animation) => {\n            animation.cancel()\n        })\n    }   \n    \n\n    return (\n        <div className=\"color-map\">\n            <div className=\"chart\">\n                {colors.map((color, colorIndex) => {\n                    return (\n                        <ColorBar key={colorIndex} color={color} />\n                    )\n                })}\n                <div className=\"buttons-bar\">\n                    <button onClick={() => resetAnimations(animations)}>Reset</button>\n                    <button onClick={() => playAnimations(animations)}>Play</button>\n                    <button onClick={() => pauseAnimations(animations)}>Pause</button>\n                </div>\n            </div>\n        </div>\n    )\n}\n\nexport default ColorMap;","import React from 'react';\n\nconst PixelBar = ({ heights }) => {\n\n    const firstSegmentStyle = {\n        height: `${3*heights[0]}px`,\n        backgroundColor: '#000'\n    }\n    const secondSegmentStyle = {\n        height: `${3*heights[1]}px`,\n        backgroundColor: '#fff)'\n    }\n    const thirdSegmentStyle = {\n        height: `${3*heights[2]}px`,\n        backgroundColor: '#000'\n    }\n\n    \n    return (\n        <div className=\"pixel-bar\">\n            <div style={firstSegmentStyle}></div>\n            <div style={secondSegmentStyle}></div>\n            <div style={thirdSegmentStyle}></div>\n        </div>\n    )\n}\n\nexport default PixelBar;","// Generate Random Pixel Bars\nconst shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\nexport const pixelBarShuffle = () => {\n    const height = 200;\n    const pixelBarList = [];\n    for (let pixBar = 0; pixBar < height; pixBar++) {\n        const pixelBarHeights = [pixBar, 1, height - pixBar - 1]\n        pixelBarList.push(pixelBarHeights)\n    }\n    return shuffle(pixelBarList)\n}\n\n\n// ColorMap Bubble Sort\nexport const bubbleSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j][0] > arr[j + 1][0]) {\n                animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n    \n    return animations\n}\n\n\n\n// Bubble Sort Color Map Animation\nexport const pixelMapBubbleSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = .5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n    animations.forEach((animation, index) => {\n        const compareEl1Bottom = chart[animation[0][0]].childNodes[0];\n        const compareEl1Top = chart[animation[0][0]].childNodes[2];\n        const compareEl2Bottom = chart[animation[1][0]].childNodes[0];\n        const compareEl2Top = chart[animation[1][0]].childNodes[2];\n\n        const swapHt1Top = animation[0][1][0];\n        const swapHt1Bottom = animation[0][1][2];\n\n        const swapHt2Top = animation[1][1][0];\n        const swapHt2Bottom = animation[1][1][2];\n\n        \n\n        // Exchange the colors of the two elements being selected\n        barAnimations.push(\n            compareEl1Bottom.animate([{ height: `${3 * swapHt2Bottom}px` }, { height: `${3 * swapHt2Bottom}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            compareEl1Top.animate([{ height: `${3 * swapHt2Top}px` }, { height: `${3 * swapHt2Top}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }), \n            compareEl2Bottom.animate([{ height: `${3 * swapHt1Bottom}px` }, { height: `${3 * swapHt1Bottom}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            compareEl2Top.animate([{ height: `${3 * swapHt1Top}px` }, { height: `${3 * swapHt1Top}px` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n\n    })\n    return barAnimations\n}\n\n// Selection Sort \nexport const pixelMapSelectionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        let minIndex = i;\n        for (let j = i; j < n; j++) {\n            if (arr[j][0] < arr[minIndex][0]) {\n                minIndex = j\n            }\n            // Checks if sort has reached the end of Array, if so, records that there will be a swap between i and min\n            let swap = false;\n            if (j === n - 1) {\n                swap = true;\n            }\n            // Push the base Element, the element being checked, the current minimum, and an indication of whether a swap has occurred\n            animations.push([[i, arr[i]], [j, arr[j]], [minIndex, arr[minIndex]], swap])\n        }\n        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n    \n    return animations\n}\n\n\nexport const pixelMapSelectionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = .5;// The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const baseChildTop = chart[animation[0][0]].childNodes[0];\n        const baseChildBottom = chart[animation[0][0]].childNodes[2];\n        const minChildTop = chart[animation[2][0]].childNodes[0];\n        const minChildBottom = chart[animation[2][0]].childNodes[2];\n        const baseTopHeight = animation[0][1][2];\n        const baseBottomHeight = animation[0][1][0];\n        const minTopHeight = animation[2][1][2];\n        const minBottomHeight = animation[2][1][0];\n        const swap = animation[3];\n        \n        // if the two elements are to be swapped, perform the swap \n        if (swap === true) {\n            barAnimations.push(\n                minChildTop.animate([{ height: `${3 * baseTopHeight}px` }, { height: `${3 * baseTopHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChildTop.animate([{ height: `${3 * minTopHeight}px` }, { height: `${3 * minTopHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                minChildBottom.animate([{ height: `${3 * baseBottomHeight}px` }, { height: `${3 * baseBottomHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChildBottom.animate([{ height: `${3 * minBottomHeight}px` }, { height: `${3 * minBottomHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n            )\n        }\n    })\n\n    return barAnimations\n}\n\n// Insertion Sort \nexport const pixelMapInsertionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n\n\n    // Move up through the array one at a time, and insert each new element into already sorted numbers to the left in its proper (ascending) position \n    for (let i = 1; i < n; i++) {\n        const key = arr[i]\n        let j = i - 1;\n        while (j >= 0 && arr[j][0] > arr[j + 1][0]) {\n            animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            j = j - 1\n        }\n    }\n\n    return animations\n}\n\n\nexport const pixelMapInsertionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElLtTop = chart[animation[0][0]].childNodes[0];\n        const swapElLtBottom = chart[animation[0][0]].childNodes[2];\n        const swapElLtTopHeight = animation[0][1][2];\n        const swapElLtBottomHeight = animation[0][1][0];\n        const swapElRtTop = chart[animation[1][0]].childNodes[0];\n        const swapElRtBottom = chart[animation[1][0]].childNodes[2];\n        const swapElRtTopHeight = animation[1][1][2];\n        const swapElRtBottomHeight = animation[1][1][0];\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElLtTop.animate([{ height: `${3 * swapElRtTopHeight}px` }, { height: `${3 * swapElRtTopHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElLtBottom.animate([{ height: `${3 * swapElRtBottomHeight}px` }, { height: `${3 * swapElRtBottomHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElRtTop.animate([{ height: `${3 * swapElLtTopHeight}px` }, { height: `${3 * swapElLtTopHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElRtBottom.animate([{ height: `${3 * swapElLtBottomHeight}px` }, { height: `${3 * swapElLtBottomHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n        )\n    })\n\n    return barAnimations\n}\n\n\n// Merge Sort \nexport const pixelMapMergeSort = (origArray) => {\n    // Two separate arrays, one main one and one to hold swapped values until they can be unswapped. Avoids having to create a buffer array during the sorting process\n    const mainArray = [...origArray];\n    const auxArray = [...mainArray]\n    const n = mainArray.length\n    const animations = [];\n    if (n <= 1) {\n        return mainArray\n    }\n    // Initialize first function call\n    mergeSortHelper(mainArray, 0, n - 1, auxArray, animations);\n    // console.log(\"main\", mainArray, \"aux\", auxArray);;\n    \n    return animations;\n}\n\nconst mergeSortHelper = (mainArray, startIdx, endIdx, auxArray, animations) => {\n    // Base case, returns if only one element in array\n    if (startIdx === endIdx) return;\n\n    // Find middle index of array, place to split before coming merge\n    const midIdx = Math.floor((startIdx + endIdx) / 2);\n\n    // recursively call function on each half of the array, to keep splitting until base case of 1 is reached. Also, notice that auxArray and mainArray are swapped from initial function call; it's complicated but basically this allows the aux array and main array to keep switching back and forth and save the values from the previous merge, which means that I don't have to create a temporary array to hold the values\n    mergeSortHelper(auxArray, startIdx, midIdx, mainArray, animations);\n    mergeSortHelper(auxArray, midIdx + 1, endIdx, mainArray, animations);\n\n    // Call the merge function to sort the values and combine back together\n    merge(mainArray, startIdx, midIdx, endIdx, auxArray, animations)\n}\n\nconst merge = (mainArray, startIdx, midIdx, endIdx, auxArray, animations) => {\n    // Copies the values of the aux array into the main array, putting the next lowest value from either array at value k\n    let i = startIdx;\n    let j = midIdx + 1;\n    let k = startIdx;\n\n    // Pick the lowest value from either array and put it into the main array\n    while (i <= midIdx && j <= endIdx) {\n        const animation = {};\n        animation.comparison = [i, j];\n        animation.range = [startIdx, endIdx]\n        if (auxArray[i][0] >= auxArray[j][0]) {\n            animation.swap = [k, auxArray[j]]\n            mainArray[k++] = auxArray[j++]\n        } else {\n            animation.swap = [k, auxArray[i]]\n            mainArray[k++] = auxArray[i++]\n        }\n        animations.push(animation);\n    }\n\n    // While there are still values in only one of the two arrays being merged, copy them in; they are already ordered from previous sorts \n    while (j <= endIdx) {\n        animations.push({\n            comparison: [j, j],\n            swap: [k, auxArray[j]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[j++]\n\n    }\n    while (i <= midIdx) {\n        animations.push({\n            comparison: [i, i],\n            swap: [k, auxArray[i]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[i++]\n    }\n}\n\nexport const pixelMapMergeSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElTop = chart[animation.swap[0]].childNodes[0];\n        const swapElBottom = chart[animation.swap[0]].childNodes[2];\n\n        const swapTopHeight = animation.swap[1][2];\n        const swapBottomHeight = animation.swap[1][0];\n\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElTop.animate([{ height: `${3 * swapTopHeight}px` }, { height: `${3 * swapTopHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElBottom.animate([{ height: `${3 * swapBottomHeight}px` }, { height: `${3 * swapBottomHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n        )\n    })\n\n    return barAnimations\n}\n\n// Quick Sort \nexport const pixelMapQuickSort = (origArray) => {\n    // Copy original array so as not to mutate it \n    const array = [...origArray];\n    const animations = [];\n\n    const quickSortHelper = (array, left, right, animations) => {\n        if (left >= right) return;\n\n        // Find the center index, by sorting from the two ends and so that everything to the left of the pivot is smaller, and everything right is larger\n        const index = partition(array, left, right);\n\n        // split the array into two halves, and call recursively on the two halves \n        quickSortHelper(array, left, index - 1, animations);\n        quickSortHelper(array, index, right, animations);\n    }\n\n    const partition = (array, left, right) => {\n        // Pivot starts from right end of subarray \n        const pivot = right;\n        right--;\n        // Keep moving pointers towards middle until two pointers cross one another\n        while (left <= right) {\n            // Find a left side element smaller than pivot, and a right side one larger, and switch them \n            while (array[left][2] < array[pivot][2]) {\n                left++\n            }\n            while (array[right][2] > array[pivot][2]) {\n                right--\n            }\n            if (left <= right) {\n                animations.push([[left, array[left]], [right, array[right]], [pivot, array[pivot]]]);\n                [array[left], array[right]] = [array[right], array[left]]\n                left++\n                right--\n            }\n        }\n        // Move the pivot into the middle \n        animations.push([[left, array[left]], [pivot, array[pivot]], [pivot, array[pivot]]]);\n        [array[left], array[pivot]] = [array[pivot], array[left]]\n        return left;\n    }\n    // Initial function call \n    quickSortHelper(array, 0, array.length - 1)\n    \n    return animations\n}\n\nexport const pixelMapQuickSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const leftElTop = chart[animation[0][0]].childNodes[0];\n        const leftElBottom = chart[animation[0][0]].childNodes[2];\n        const rightElTop = chart[animation[1][0]].childNodes[0];\n        const rightElBottom = chart[animation[1][0]].childNodes[2];\n        const leftTopHeight = animation[0][1][0];\n        const leftBottomHeight = animation[0][1][2];\n        const rightTopHeight = animation[1][1][0];\n        const rightBottomHeight = animation[1][1][2];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            leftElTop.animate([{ height: `${3 * rightTopHeight}px` }, { height: `${3 * rightTopHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            leftElBottom.animate([{ height: `${3 * rightBottomHeight}px` }, { height: `${3 * rightBottomHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightElTop.animate([{ height: `${3 * leftTopHeight}px` }, { height: `${3 * leftTopHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightElBottom.animate([{ height: `${3 * leftBottomHeight}px` }, { height: `${3 * leftBottomHeight}px` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n\n// Radix Bar Sort \nexport const pixelMapRadixSort = (origArr) => {\n    const arr = [...origArr] // Copy original array so as not to mutate it\n    const animations = [];\n\n    // initialize an array subarrays representing numbers 0 through 9, according to their index in parent array \n    const countBuckets = [];\n    for (let i = 0; i < 10; i++) {\n        countBuckets[i] = []\n    }\n\n    let max = 0;\n    // find length of longest number by digits, by converting it to string and measuring its length, then comparing to all other numbers \n    for (let j = 0; j < arr.length; j++) {\n        max = (arr[j].toString().length > max) ? arr[j].toString().length : max;\n    }\n\n    // cycle through array once for each digit in longest number from array \n    for (let l = 0; l < max; l++) {\n\n        while (arr.length) {\n            const stringNum = arr[0][0].toString()  // Convert front number in array to string\n            const d = stringNum.length - l - 1 // Starting from rightmost digit on first iteration, then moving left on next iteration\n            const digit = (stringNum[d]) ? stringNum[d] : 0 // Select either that digit, or (if too short) use 0\n            countBuckets[digit].push(arr.shift()) // Remove number from array and place into bucket array corresponding to that digit\n        }\n        let counter = 0;\n        for (let i = 0; i < 10; i++) { // Cycle through all 10 counter arrays, from lowest to highest\n            while (countBuckets[i].length) {  // Cycle through counter array until empty\n                const numArr = countBuckets[i].shift() // Save number in variable, so it can be added both to old array and to animation\n                arr.push(numArr)\n                animations.push([numArr, counter])\n                counter++\n            }\n        }\n    }\n    \n    return animations\n\n}\n\nexport const pixelMapRadixSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const elementTop = chart[animation[1]].childNodes[0];\n        const elementBottom = chart[animation[1]].childNodes[2];\n        const heightTop = animation[0][2];\n        const heightBottom = animation[0][0];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            elementTop.animate([{ height: `${3 * heightTop}px` }, { height: `${3 * heightTop}px` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            elementBottom.animate([{ height: `${3 * heightBottom}px` }, { height: `${3 * heightBottom}px` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n","import React, { useState, useEffect } from 'react';\nimport PixelBar from \"./PixelBar\";\nimport { pixelBarShuffle, bubbleSort, pixelMapBubbleSortAnimation, pixelMapSelectionSort, pixelMapSelectionSortAnimation, pixelMapInsertionSort, pixelMapInsertionSortAnimation, pixelMapMergeSort, pixelMapMergeSortAnimation, pixelMapQuickSort, pixelMapQuickSortAnimation, pixelMapRadixSort, pixelMapRadixSortAnimation } from \"../utilities/pixelMapFunctions\";\n\nconst PixelMap = ({ sort }) => {\n    const [pixelBars, setPixelBars] = useState(pixelBarShuffle())\n    const [animations, setAnimations] = useState([])\n    const [sortType, setSortType] = useState({ function: bubbleSort });\n    const [animationType, setAnimationType] = useState({ function: pixelMapBubbleSortAnimation });\n    \n    useEffect(() => {\n        switch (sort) {\n            case \"bubble\":\n                setSortType({ function: bubbleSort })\n                setAnimationType({ function: pixelMapBubbleSortAnimation })\n                break;\n            case \"selection\":\n                setSortType({ function: pixelMapSelectionSort })\n                setAnimationType({ function: pixelMapSelectionSortAnimation })\n                break;\n            case \"insertion\":\n                setSortType({ function: pixelMapInsertionSort })\n                setAnimationType({ function: pixelMapInsertionSortAnimation })\n                break;\n            case \"merge\":\n                setSortType({ function: pixelMapMergeSort })\n                setAnimationType({ function: pixelMapMergeSortAnimation })\n                break;\n            case \"quick\":\n                setSortType({ function: pixelMapQuickSort })\n                setAnimationType({ function: pixelMapQuickSortAnimation })\n                break;\n            case \"radix\":\n                setSortType({ function: pixelMapRadixSort })\n                setAnimationType({ function: pixelMapRadixSortAnimation })\n                break;\n        }\n    }, [sort])\n\n    useEffect(() => {\n        resetAnimations(animations)\n        runAnimations(pixelBars)\n        \n    }, [sortType])\n\n\n\n\n    const runAnimations = (pixelBars) => {\n        const barAnimations = animationType.function(sortType.function(pixelBars))\n        setAnimations(barAnimations)\n    }\n\n    const playAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") {\n                animation.play()\n            }\n        })\n    }\n\n    const pauseAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") {\n                animation.pause();\n            }\n        })\n    }\n\n    const resetAnimations = animations => {\n        animations.map((animation) => {\n            animation.cancel()\n        })\n    }   \n\n    \n\n\n\n    \n\n    \n\n    \n\n    return (\n        <div className=\"pixel-map\">\n            <div className=\"chart\">\n                {pixelBars.map((barHeights, barIndex) => {\n                    return (\n                        <PixelBar key={barIndex} heights={barHeights} />\n                    )\n                })}\n                <div className=\"buttons-bar\">\n                    <button onClick={() => resetAnimations(animations)}>Reset</button>\n                    <button onClick={() => playAnimations(animations)}>Play</button>\n                    <button onClick={() => pauseAnimations(animations)}>Pause</button>\n                </div>\n            </div>\n        </div>\n    )\n}\n\nexport default PixelMap;","import React, {useState} from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link } from 'react-router-dom';\n\nimport BarChart from './BarChart';\nimport ColorMap from './ColorMap';\nimport PixelMap from './PixelMap';\n// import PixelPainting from './PixelPainting';\n\nconst Sorting = () => {  \n    \n    const [sort, setSort] = useState(\"bubble\")\n\n\n    return (\n\n        <Router>\n            <nav className=\"nav-bar\">\n                <div>\n                    <ul className=\"chart-types\">\n                        <li><Link className=\"chart-link\" id=\"bar-chart\"to=\"/barchart\">Bar Chart</Link></li>\n                        <li><Link  className=\"chart-link\" id=\"color-map\" to=\"/colormap\">Color Map</Link></li>\n                        <li><Link  className=\"chart-link\" id=\"pixel-map\" to=\"/pixelmap\">Pixel Map</Link></li>\n                        {/* <li><Link to=\"/pixelpainting\">Pixel Painting</Link></li> */}\n                    </ul>\n                    <ul className=\"sort-types\">\n                        <li onClick={() => setSort(\"bubble\")}>\n                            bubble\n                        </li>\n                        <li onClick={() => setSort(\"selection\")}>\n                            selection\n                        </li>\n                        <li onClick={() => setSort(\"insertion\")}>\n                            insertion\n                        </li>\n                        <li onClick={() => setSort(\"merge\")}>\n                            merge\n                        </li>\n                        <li onClick={() => setSort(\"quick\")}>\n                            quick\n                        </li>\n                        <li onClick={() => setSort(\"radix\")}>\n                            radix\n                        </li>\n                    </ul>\n                </div>\n            </nav>\n\n            <Switch>\n                <Route path=\"/barchart\">\n                    <BarChart sort={sort} />\n                </Route>\n                <Route path=\"/colormap\">\n                    <ColorMap sort={sort} />\n                </Route>\n                <Route path=\"/pixelmap\">\n                    <PixelMap sort={sort} />\n                </Route>\n                {/* <Route path=\"/pixelpainting\">\n                    <PixelPainting/>\n                </Route> */}\n            </Switch>\n        </Router>\n\n    )\n}\n\nexport default Sorting;","// Draw initial Grid\nexport const initializeGrid = (canvas, cellSize, canvasDimensions) => {\n\n    const ctx = canvas.current.getContext('2d');\n    const [width, height] = [canvasDimensions.width, canvasDimensions.height]\n\n    // Initialize Background\n    ctx.canvas.width = width;\n    ctx.canvas.height = height;\n\n    // Initialize Grid as Clear\n    const initialGrid = clearCanvas(canvas, cellSize)\n    \n    // Find x and y coordinates of canvas\n    const [xCoordinate, yCoordinate] = [canvas.current.getBoundingClientRect().x, canvas.current.getBoundingClientRect().y]\n\n    return [initialGrid, xCoordinate, yCoordinate]\n\n\n\n}\n\nexport const clearCanvas = (canvas, cellSize) => {\n    const ctx = canvas.current.getContext('2d');\n    const [width, height] = [ctx.canvas.width, ctx.canvas.height]\n    \n    // Clear Background\n    ctx.clearRect(0, 0, width, height);\n\n    // Construct Grid of Cells\n    const [cols, rows] = [width / cellSize, height / cellSize];\n    \n    const clearGrid = [];\n    // Builds a rows*cols nested array full of walls\n    for (let row = 0; row < rows; row++) {\n        clearGrid.push([])\n        for (let col = 0; col < cols; col++) {\n            clearGrid[row].push(\"path\")\n        }\n    }\n    return clearGrid\n}\n\nexport const fillCanvas = (canvas, cellSize) => {\n    const ctx = canvas.current.getContext('2d');\n    const [width, height] = [ctx.canvas.width, ctx.canvas.height]\n\n    // Fill Background\n    ctx.fillStyle = \"#444\";\n    ctx.fillRect(0, 0, width, height);\n\n    // Construct Grid of Cells\n    const [cols, rows] = [width / cellSize, height / cellSize]\n    const fillGrid = [];\n    // Builds a rows*cols nested array full of walls\n    for (let row = 0; row < rows; row++) {\n        fillGrid.push([])\n        for (let col = 0; col < cols; col++) {\n            fillGrid[row].push(\"wall\")\n        }\n    }\n    return fillGrid\n}\n\n// Generate initial maze\nexport const generateMaze = (grid, algorithm) => {\n\n    // Number of total columns and total rows\n\n    let mazeGrid = JSON.parse(JSON.stringify(grid)); // Deep copy grid so as not to mutate\n    const [rows, cols] = [mazeGrid.length, mazeGrid[0].length]\n\n    // Animate drawing the entrance and exit\n    const [entrance, exit, start] = [[0, 1], [mazeGrid.length - 1, mazeGrid[0].length - 2], [1, 1]]\n    let drawingAnimations = [entrance, exit];\n\n    // Add entrance and exit to state, and to grid\n    mazeGrid[entrance[0]][entrance[1]] = \"path\";\n    mazeGrid[exit[0]][exit[1]] = \"path\";\n\n    // Calls with start as current and previous node; this is to allow for previous node to be used in recursive call\n    let mazeFinished;\n\n    let mazeAlgorithm = ellersMazeAlgorithm\n    switch (algorithm) {\n        case \"eller's\":\n            mazeAlgorithm = ellersMazeAlgorithm\n            break;\n        case \"depthFirst\":\n            mazeAlgorithm = depthFirstMazeAlgorithm\n            break;\n    }\n\n    [mazeGrid, drawingAnimations, mazeFinished] = mazeAlgorithm(start, start, mazeGrid, drawingAnimations)\n    \n    // Add a set number of loops to the maze\n    // const loops = 200;\n    // [mazeGrid, drawingAnimations] = loopMaker(mazeGrid, drawingAnimations, loops);\n\n    const [nodeAnimations, trash] = nodeFinder(mazeGrid, entrance, exit)\n\n    const mazeAnimations = { drawingAnimations: drawingAnimations, nodeAnimations: nodeAnimations }\n\n    return [mazeGrid, mazeAnimations, mazeFinished]\n}\n\nconst shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\nconst ellersMazeAlgorithm = (startNode, prevNode, origMazeGrid, animations) => {\n\n    const mazeGrid = JSON.parse(JSON.stringify(origMazeGrid)) // Deep copy so as not to mutate original array\n\n    let setNoCounter = 1; // To keep track of set names, so there's no repeats\n    for (let i = 1; i < mazeGrid[1].length - 1; i += 2) {\n        mazeGrid[1][i] = setNoCounter; // Initialize the cells of the first row to each exist in their own set.\n        animations.push([1,i])\n        setNoCounter++;\n    }\n\n    for (let j = 1; j < mazeGrid.length - 2; j += 2) {  // Repeat until the last row is reached\n        \n        for (let i = 1; i < mazeGrid[j].length - 1; i += 2) {// Randomly join adjacent cells, but only if they are not in the same set.\n            if (mazeGrid[j][i+2] !== undefined && mazeGrid[j][i] !== mazeGrid[j][i + 2]) {\n                if (Math.random() < .5) { // Some of the cells joined together, so left side and right of wall must match\n                    mazeGrid[j][i + 1] = mazeGrid[j][i];\n                    mazeGrid[j][i + 2] = mazeGrid[j][i];\n                    animations.push([j, i+1])\n                }\n            }\n        }\n        \n        let placeHolder = 1;\n        while (placeHolder < mazeGrid[j].length ) {// For each set, randomly create vertical connections downward to the next row\n            \n            const setNo = mazeGrid[j][placeHolder] // Number stored in grid for current set\n            let setCounter = 1;\n            while (mazeGrid[j][placeHolder + setCounter * 2] === setNo) { // Counts how many in a row have the same setNo\n                setCounter += 1\n            }\n            \n            // For each set, randomly create a random number (1+) of vertical connections downward to the next row.\n            const extensionNo = 1 + Math.floor(Math.random() * setCounter) * .5;\n            let extensionCounter = 0;\n            while (extensionCounter < extensionNo) {  // Keeps cycling until correct number of columns are created\n                const extensionColumn = Math.floor(Math.random() * setCounter) * 2;\n                if (mazeGrid[j + 1][placeHolder + extensionColumn] === \"wall\") {\n                    mazeGrid[j + 1][placeHolder + extensionColumn] = setNo;\n                    animations.push([j + 1, placeHolder + extensionColumn]);\n                    mazeGrid[j + 2][placeHolder + extensionColumn] = setNo;\n                    animations.push([j + 2, placeHolder + extensionColumn]);\n                    extensionCounter ++\n                }\n            } // Consecutive columns are linked together in next section\n\n            \n\n            placeHolder += setCounter*2; // Moves to the next set\n        }\n        \n        for (let l = 1; l < mazeGrid[j].length - 1; l += 2) { \n            if (mazeGrid[j + 2][l] === \"wall\") {// Flesh out the next row by putting any remaining cells into their own sets.\n                mazeGrid[j + 2][l] = setNoCounter;\n                animations.push([j + 2, l])\n                setNoCounter++\n            } \n        }\n    }\n    for (let i = 1; i < mazeGrid[0].length - 2; i+=2) { //For the last row, join all adjacent cells that do not share a set\n        if (mazeGrid[mazeGrid.length - 2][i] !== mazeGrid[mazeGrid.length - 2][i + 2]) {\n            mazeGrid[mazeGrid.length - 2][i + 1] = mazeGrid[mazeGrid.length - 2][i];\n            animations.push([mazeGrid.length - 2, i + 1]);\n            mazeGrid[mazeGrid.length - 2][i + 2] = mazeGrid[mazeGrid.length - 2][i];\n            animations.push([mazeGrid.length - 2, i + 2]);\n        }\n    }\n\n    const pathMazeGrid = []\n    for (let i = 0; i < mazeGrid.length; i++) {\n        const row = [];\n        for (let j = 0; j < mazeGrid[i].length; j++) {\n            if (mazeGrid[i][j] !== \"wall\") {\n                row.push(\"path\")\n            } else {\n                row.push(\"wall\")\n            }\n        }\n        pathMazeGrid.push(row)\n    }\n    \n\n    \n    return [pathMazeGrid, animations, true]\n    \n}\n\nconst depthFirstMazeAlgorithm = (startNode, prevNode, mazeGrid, animations) => {\n    // Draws maze using recursive depth-first algorithm\n    const node = startNode;\n\n    const [row, col] = node;\n\n    mazeGrid[row][col] = \"path\";\n    const [prevRow, prevCol] = prevNode\n    mazeGrid[prevRow][prevCol] = \"path\";\n    let deadEnd = false;\n\n    let newAnimations = [...animations, prevNode, node] // Add current node to path animation\n    const directionArray = shuffle([...Array(4).keys()]); // Create a random array of directions to choose from\n    for (let i = 0; i < 4; i++) {  // Choose the next direction to go in, or return dead end\n        const direction = directionArray[i]\n        switch (direction) {\n            case 0: // Up: if potential path column above is not edge or filled\n                if (((row - 2) >= 0) && (mazeGrid[row - 2][col] === \"wall\")) {\n                    const [midNode, newNode] = [[row - 1, col], [row - 2, col]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n            case 1: // Right: if two squares to the right is not over edge or filled\n                if (((col + 2) < mazeGrid[row].length) && (mazeGrid[row][col + 2] === \"wall\")) {\n                    const [midNode, newNode] = [[row, col + 1], [row, col + 2]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n            case 2: // Down: if potential path column below is not edge or filled\n\n                if (((row + 2) < mazeGrid.length) && (mazeGrid[row + 2][col] === \"wall\")) {\n                    const [midNode, newNode] = [[row + 1, col], [row + 2, col]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n            case 3: // Left: if two squares to the left is not over edge or filled\n                if (((col - 2) >= 0) && (mazeGrid[row][col - 2] === \"wall\")) {\n                    const [midNode, newNode] = [[row, col - 1], [row, col - 2]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n        }\n    }\n    deadEnd = true\n    return [mazeGrid, newAnimations, deadEnd]\n}\n\nconst loopMaker = (mazeGrid, mazeAnimations, loopsRequired) => {\n    let loopsMade = 0;\n    while (loopsMade < loopsRequired) {\n        // Not selecting the bottom 20 % of the maze makes loops more likely to form\n        // Only selects numbers between 1 and 80% of mazeGrid length\n        const randRow = Math.floor(Math.random() * (mazeGrid.length * .8 - 1)) + 1\n        // Select any column except for first and last\n        const randCol = Math.floor(Math.random() * (mazeGrid[0].length - 2)) + 1\n        if ( // Forms loops better by only choosing walls sandwiched between two other walls, but not 3 ways corners\n            mazeGrid[randRow][randCol] === \"wall\"\n            && (\n                (mazeGrid[randRow + 1][randCol] === \"wall\" && mazeGrid[randRow - 1][randCol] === \"wall\" && mazeGrid[randRow][randCol + 1] !== \"wall\" && mazeGrid[randRow][randCol - 1] !== \"wall\") ||\n                (mazeGrid[randRow][randCol + 1] === \"wall\" && mazeGrid[randRow][randCol - 1] === \"wall\" && mazeGrid[randRow + 1][randCol] !== \"wall\" && mazeGrid[randRow - 1][randCol] !== \"wall\")\n            )\n        ) {\n            mazeGrid[randRow][randCol] = \"path\"\n            mazeAnimations.push([randRow, randCol])\n            loopsMade++\n        }\n    }\n\n    return [mazeGrid, mazeAnimations]\n}\n\nexport const nodeFinder = (mazeGrid, entrance, exit) => { // Finds nodes, points at which the maze either turns or forks, for use in building graphs\n    const nodeAnimations = [];\n    const nodeList = []; // List of nodes with the location and directions of nearest nodes\n\n    // Add the start of the maze to the animations\n    nodeAnimations.push(entrance)\n\n    nodeList.push([...entrance, [2]])\n\n    for (let row = 1; row < mazeGrid.length - 1; row++) { // Cycles through rows and columns, searching for nodes in each odd row/col\n        for (let col = 1; col < mazeGrid[0].length - 1; col++) {\n            const directions = [];\n            for (let direction = 0; direction < 4; direction++) {\n\n                switch (direction) {\n                    case 0:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row - 1][col] === \"path\") { // Up: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 1:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col + 1] === \"path\") { // Right: if potential path column right is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 2:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row + 1][col] === \"path\") { // Down: if potential path column down is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 3:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col - 1] === \"path\") { // Left: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                }\n            }\n            if (directions.length === 1) { // If dead end, corner, or intersection\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 2 && (directions[0] - directions[1]) % 2 !== 0) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 3 || directions.length === 4) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            }\n\n        }\n    }\n    // Add the end of the maze to the animations\n    nodeAnimations.push(exit)\n    nodeList.push([...exit, [0]])\n\n    const nodeMazeGrid = JSON.parse(JSON.stringify(mazeGrid))    // Deep copy the maze grid\n    nodeList.forEach(node => nodeMazeGrid[node[0]][node[1]] = \"node\")\n\n    const nodeWeights = weightFinder(nodeMazeGrid, nodeList)\n\n    return [nodeAnimations, nodeWeights]\n}\n\nconst weightFinder = (nodeMazeGrid, nodeList) => {\n    const nodeWeights = {};\n    nodeList.forEach(node => {\n        const [row, col] = [node[0], node[1]];\n        const nodeDirections = []\n        const directions = node[2]\n        directions.forEach(direction => {\n            let i = 1;\n\n\n            switch (direction) {\n                case 0: // Up\n                    while (row - i >= 0 && nodeMazeGrid[row - i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 1: // Right\n                    while (col + i < nodeMazeGrid[row].length && nodeMazeGrid[row][col + i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 2: // Down\n                    while (row + i < nodeMazeGrid.length && nodeMazeGrid[row + i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 3: // Left\n                    while (col - i >= 0 && nodeMazeGrid[row][col - i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n            }\n        })\n        nodeWeights[`${row},${col}`] = nodeDirections\n    })\n    return nodeWeights;\n}\n","export const nodeFinder = (mazeGrid, entrance, exit) => { // Finds nodes, points at which the maze either turns or forks, for use in building graphs\n    const nodeAnimations = [];\n    const nodeList = []; // List of nodes with the location and directions of nearest nodes\n\n    // Add the start of the maze to the animations\n    nodeAnimations.push(entrance)\n\n    nodeList.push([...entrance, [2]])\n\n    for (let row = 1; row < mazeGrid.length - 1; row++) { // Cycles through rows and columns, searching for nodes in each odd row/col\n        for (let col = 1; col < mazeGrid[0].length - 1; col++) {\n            const directions = [];\n            for (let direction = 0; direction < 4; direction++) {\n\n                switch (direction) {\n                    case 0:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row - 1][col] === \"path\") { // Up: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 1:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col + 1] === \"path\") { // Right: if potential path column right is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 2:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row + 1][col] === \"path\") { // Down: if potential path column down is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 3:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col - 1] === \"path\") { // Left: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                }\n            }\n            if (directions.length === 1) { // If dead end, corner, or intersection\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 2 && (directions[0] - directions[1]) % 2 !== 0) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 3 || directions.length === 4) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            }\n\n        }\n    }\n    // Add the end of the maze to the animations\n    nodeAnimations.push(exit)\n    nodeList.push([...exit, [0]])\n\n    const nodeMazeGrid = JSON.parse(JSON.stringify(mazeGrid))    // Deep copy the maze grid\n    nodeList.forEach(node => nodeMazeGrid[node[0]][node[1]] = \"node\")\n\n    const nodeWeights = weightFinder(nodeMazeGrid, nodeList)\n\n    return [nodeAnimations, nodeWeights]\n}\n\nconst weightFinder = (nodeMazeGrid, nodeList) => { // Finds weights for building an edge graph of the maze\n    const nodeWeights = {};\n    nodeList.forEach(node => {\n        const [row, col] = [node[0], node[1]];\n        const nodeDirections = []\n        const directions = node[2]\n        directions.forEach(direction => {\n            let i = 1;\n\n\n            switch (direction) {\n                case 0: // Up\n                    while (row - i >= 0 && nodeMazeGrid[row - i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 1: // Right\n                    while (col + i < nodeMazeGrid[row].length && nodeMazeGrid[row][col + i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 2: // Down\n                    while (row + i < nodeMazeGrid.length && nodeMazeGrid[row + i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 3: // Left\n                    while (col - i >= 0 && nodeMazeGrid[row][col - i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n            }\n        })\n        nodeWeights[`${row},${col}`] = nodeDirections\n    })\n    return nodeWeights;\n}\n\nconst shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\n\n// Maze-solving algorithms:\n\nexport const solveMaze = (grid, defaults, algorithm) => {\n    const newGrid = JSON.parse(JSON.stringify(grid)); // Deep copy of grid\n    const animations = { solvingAnimations: [], backtrackingAnimations: [] };\n\n    let solvingAlgorithm = dijkstrasSolvingAlgorithm\n    switch (algorithm) {\n        case \"depthFirst\":\n            solvingAlgorithm = depthFirstSearchSolvingAlgorithm;\n            break;\n        case \"breadthFirst\":\n            solvingAlgorithm = breadthFirstSearchSolvingAlgorithm\n            break;\n        case \"dijkstra's\":\n            solvingAlgorithm = dijkstrasSolvingAlgorithm\n            break;\n        case \"a-star\":\n            solvingAlgorithm = aStarSolvingAlgorithm\n            break;\n    }\n\n    solvingAlgorithm(defaults.start, defaults.enter, defaults.exit, newGrid, animations)\n    return animations\n}\n\nconst depthFirstSearchSolvingAlgorithm = (startNode, prevNode, endNode, newGrid, animations) => {\n    const node = startNode;\n\n    if ((node[0] === endNode[0]) && (node[1] === endNode[1])) {\n        animations.backtrackingAnimations.push(node)\n        animations.backtrackingAnimations.push(prevNode)\n        return true\n    }\n\n    let mazeEndFound = false;\n    const [row, col] = node;\n    newGrid[row][col] = \"checked\";\n    animations.solvingAnimations.push(node)\n\n    const directionArray = shuffle([...Array(4).keys()]);\n    for (let i = 0; i < 4; i++) {\n\n        const direction = directionArray[i]\n\n        switch (direction) {\n\n            case 0: // Up: checks if 2 squares up is not over edge and there is a path toward that direction\n                if ((row - 1 >= 0) && (newGrid[row - 1][col] === \"path\")) {\n                    const newNode = [row - 1, col];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n\n                }\n                break;\n            case 1: // Right: checks if 2 squares right is not over edge and there is a path toward that direction\n                if ((col + 1 < newGrid[row].length) && (newGrid[row][col + 1] === \"path\")) {\n                    const newNode = [row, col + 1];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n                }\n                break;\n            case 2: // Down: checks if 2 squares down is not over edge and there is a path toward that direction\n                if ((row + 1 < newGrid.length) && (newGrid[row + 1][col] === \"path\")) {\n                    const newNode = [row + 1, col];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n                }\n                break;\n            case 3: // Left: checks if 2 squares left is not over edge and there is a path toward that direction\n                if ((col - 1 >= 0) && (newGrid[row][col - 1] === \"path\")) {\n                    const newNode = [row, col - 1];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n                }\n                break;\n\n        }\n        if (mazeEndFound) {\n            animations.backtrackingAnimations.push(prevNode)\n            return mazeEndFound\n        }\n\n    }\n    return mazeEndFound\n\n}\n\nconst breadthFirstSearchSolvingAlgorithm = (startNode, prevNode, endNode, newGrid, animations) => {\n\n    const frontierQueue = [];\n    const backtrackDictionary = {};\n    frontierQueue.push(prevNode);\n    let checking = true;\n\n\n    const breadthFirstRecursion = (frontierQueue, endNode, newGrid, animations, backtrackDictionary) => {\n        const node = frontierQueue.shift();\n\n        if (node[0] === endNode[0] && node[1] === endNode[1]) return false\n\n        animations.solvingAnimations.push(node);\n\n        const [row, col] = [node[0], node[1]];\n        newGrid[row][col] = \"checked\";\n\n        for (let i = 0; i < 4; i++) {\n            const direction = i;\n\n            switch (direction) {\n\n                case 0: // Up: checks if 2 squares up is not over edge and there is a path toward that direction\n                    if ((row - 1 >= 0) && (newGrid[row - 1][col] === \"path\")) {\n                        const newNode = [row - 1, col];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n                case 1: // Right: checks if 2 squares right is not over edge and there is a path toward that direction\n                    if ((col + 1 < newGrid[row].length) && (newGrid[row][col + 1] === \"path\")) {\n                        const newNode = [row, col + 1];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n                case 2: // Down: checks if 2 squares down is not over edge and there is a path toward that direction\n                    if ((row + 1 < newGrid.length) && (newGrid[row + 1][col] === \"path\")) {\n                        const newNode = [row + 1, col];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n                case 3: // Left: checks if 2 squares left is not over edge and there is a path toward that direction\n                    if ((col - 1 >= 0) && (newGrid[row][col - 1] === \"path\")) {\n                        const newNode = [row, col - 1];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n            }\n        }\n        return (frontierQueue.length > 0)\n    }\n\n    while (checking) {\n        checking = breadthFirstRecursion(frontierQueue, endNode, newGrid, animations, backtrackDictionary);\n    }\n\n    let btNode = endNode;\n    animations.backtrackingAnimations.push(btNode);\n    while (!((btNode[0] === startNode[0]) && (btNode[1] === startNode[1]))) {\n        const dictionaryString = `${btNode[0]},${btNode[1]}`;\n        btNode = backtrackDictionary[dictionaryString]\n        animations.backtrackingAnimations.push(btNode);\n    }\n\n}\n\nconst nodeAndWeightFinder = (mazeGrid, baseNode) => { // Finds nodes, points at which the maze either turns or forks, and their corresponding weights to the base node\n    const nodeAndWeightList = []; // List of nodes with the location and directions of nearest nodes \n    const [row, col] = baseNode;\n    \n    for (let direction = 0; direction < 4; direction++) {\n        \n        let counter = 1;\n        let node;\n        switch (direction) {\n            case 0:\n                if (baseNode[0] - counter >= 0 && mazeGrid[baseNode[0] - counter][baseNode[1]] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0] - counter, baseNode[1]])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n            case 1:\n                if (baseNode[1] + counter < mazeGrid[0].length && mazeGrid[baseNode[0]][baseNode[1] + counter] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0], baseNode[1] + counter])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n            case 2:\n                if (baseNode[0] + counter < mazeGrid.length && mazeGrid[baseNode[0] + counter][baseNode[1]] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0] + counter, baseNode[1]])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n            case 3:\n                if (baseNode[1] - counter >= 0 && mazeGrid[baseNode[0]][baseNode[1] - counter] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0], baseNode[1] - counter])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n        }\n    }\n    \n    return nodeAndWeightList\n}\n\nconst isANode = (mazeGrid, node) => { // Checks if selected location is a node or not\n    // Scans four directions and \n    const [row, col] = node;\n    \n    const directions = [];\n    if (row > 0 && mazeGrid[row - 1][col] === \"path\") { // Up\n        directions.push(0)\n    } \n    if (col < mazeGrid[0].length - 1 && mazeGrid[row][col + 1] === \"path\") { // Right\n        directions.push(1)\n    } \n    if (row < mazeGrid.length - 1 && mazeGrid[row + 1][col] === \"path\") { // Down\n        directions.push(2)\n    } \n    if (col > 0 && mazeGrid[row][col - 1] === \"path\") { // Left\n        directions.push(3)\n    }\n    \n    if (directions.length === 1 || directions.length > 2 || (directions[0] - directions[1]) % 2 !== 0) { \n        // Is either a dead end or a t-junction/4-way or a corner \n        return true\n    }\n\n    return false\n}\n\n\nconst dijkstrasSolvingAlgorithm = (startNode, enterNode, exitNode, mazeGrid, animations, heuristic = false) => {\n    const lowestUnvisitedNode = (distances, visitedNodes) => {\n        let min = [null, Infinity];\n        Object.entries(distances).forEach((distance) => {\n            const currentDistanceStr = distance[0];\n            if (!visitedNodes[currentDistanceStr] && distances[currentDistanceStr] < min[1]) {\n                min = [currentDistanceStr, distance[1]];\n            }\n        })\n\n        return (min[0] === null) ? null : min[0].split(\",\");\n    }\n\n    // Initialize distances dictionary for start and end nodes\n    const distances = {};\n    distances[`${enterNode[0]},${enterNode[1]}`] = 0;\n    distances[`${exitNode[0]},${exitNode[1]}`] = Infinity;\n\n    // Initialize parent nodes dictionary\n    const parentNodes = {};\n    parentNodes[`${exitNode[0]},${exitNode[1]}`] = null;\n\n    // Initialize arrays for visited and unvisited nodes\n    const visitedNodes = {};\n    let unvisitedNodes = nodeAndWeightFinder(mazeGrid, enterNode)\n    \n    let currentNode = enterNode;\n    animations.solvingAnimations.push([enterNode])\n    while (currentNode !== null && (currentNode[0] !== exitNode[0] && currentNode[1] !== exitNode[1])) { // Exits if out of nodes or at end\n        console.log(\"loop\")\n        // Converts back from string to number\n        const [row, col] = [Number(currentNode[0]), Number(currentNode[1])];\n        animations.solvingAnimations.push([row, col])\n\n        const currentNodeStr = `${row},${col}` // String for node currently looking at, for lookup in dictionary\n        const currentDistance = distances[currentNodeStr]; // Distance of current node from start\n        unvisitedNodes = nodeAndWeightFinder(mazeGrid, [row, col]) // Find weights of all attached nodes, meaning distances from current node\n        unvisitedNodes.forEach((edge) => { // Cycle through all nearest nodes\n            const [direction, edgeDistance] = [edge[0], edge[1]] // Direction and distance/weight to that direction\n            let childNode, childNodeStr, totalWeight;\n            let hWeight = 0; // Additional heuristic weight, for use in A*\n            const distanceFromStart = currentDistance + edgeDistance\n\n            switch (direction) {\n                case 0: //Up\n                    // Make new node and node string\n                    childNode = [row - edgeDistance, col];  \n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0; \n                    totalWeight = distanceFromStart + hWeight\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                case 1: //Right\n                    // Make new node and node string\n                    childNode = [row, col + edgeDistance];\n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0;\n                    totalWeight = distanceFromStart + hWeight;\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                case 2: //Down\n                    // Make new node and node string\n                    childNode = [row + edgeDistance, col];\n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0;\n                    totalWeight = distanceFromStart + hWeight;\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                case 3: //Left\n                    // Make new node and node string\n                    childNode = [row, col - edgeDistance];\n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0;\n                    totalWeight = distanceFromStart + hWeight;\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        })\n\n        visitedNodes[currentNodeStr] = unvisitedNodes;\n        currentNode = lowestUnvisitedNode(distances, visitedNodes)\n    }\n\n    if (currentNode === null || (currentNode[0] === exitNode[0] && currentNode[1] === exitNode[1])) {\n        let backtrackNode = exitNode;\n        animations.backtrackingAnimations.push(backtrackNode)\n\n        while (backtrackNode[0] !== enterNode[0] && backtrackNode[1] !== enterNode[1]) {\n            const newNodeStrArray = parentNodes[`${backtrackNode[0]},${backtrackNode[1]}`].split(\",\")\n            backtrackNode = [Number(newNodeStrArray[0]), newNodeStrArray[1]]\n            animations.backtrackingAnimations.push(backtrackNode)\n\n        }\n    }\n}\n\nconst aStarSolvingAlgorithm = (startNode, enterNode, exitNode, mazeGrid, animations) => {\n    dijkstrasSolvingAlgorithm(startNode, enterNode, exitNode, mazeGrid, animations, true)\n}","// Animations\n\nexport const animateMazeDrawing = (mazeAnimations, canvas, cellSize) => {\n    const ctx = canvas.current.getContext('2d');\n\n    let counter = 0;\n    let stepId;\n    function drawPath() {\n        if (mazeAnimations.drawingAnimations.length !== 0) {\n\n            for (let i = 0; i < 725; i++) {\n                if (counter < mazeAnimations.drawingAnimations.length) {\n                    const animation = mazeAnimations.drawingAnimations[counter];\n                    const [row, col] = animation;\n                    ctx.clearRect(col * cellSize, row * cellSize, cellSize, cellSize);\n                    counter++\n                }\n            }\n\n            stepId = window.requestAnimationFrame(drawPath);\n            \n\n        }\n    }\n    const play = () => {\n        window.requestAnimationFrame(drawPath)\n    }\n\n    const stop = () => {\n        cancelAnimationFrame(stepId)\n        return stepId\n    }\n\n    play()\n\n}\n\n    // if (mazeAnimations.nodeAnimations.length !== 0) {\n    //     mazeAnimations.nodeAnimations.forEach((animation, index) => {\n    //         setTimeout(() => {\n    //             const [row, col] = animation;\n    //             ctx.fillStyle = \"#ff0000\"\n    //             ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n    //         }, drawSpeed * mazeAnimations.drawingAnimations.length + drawSpeed * index); // Set a delay based on the time to finish the drawing animation, before drawing the nodes\n    //     })\n    // }\n\n\nexport const animateMazeSolving = (solvingAnimations, canvas, cellSize, drawSpeed) => {\n    const ctx = canvas.current.getContext('2d');\n\n    if (solvingAnimations !== []) {\n\n        solvingAnimations.forEach((animation, index) => {\n            setTimeout(() => {\n                ctx.fillStyle = \"#ff0000\"\n                const [row, col] = animation;\n                ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n            }, drawSpeed * index);\n        })\n\n    }\n}\n\nexport const animateMazeSolvingBacktrack = (backtrackingAnimations, canvas, cellSize, drawSpeed, delay) => {\n    const ctx = canvas.current.getContext('2d');\n\n    if (backtrackingAnimations !== []) {\n\n        backtrackingAnimations.forEach((animation, index) => {\n            setTimeout(() => {\n                ctx.fillStyle = \"#fcf000\"\n                const [row, col] = animation;\n                ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n            }, delay + drawSpeed * index);\n        })\n\n    }\n}","import React, { useState, useEffect, useRef } from 'react';\nimport { initializeGrid, generateMaze, clearCanvas, fillCanvas } from './PathfindingFunctions/mazeGeneratingFunctions.js';\nimport { solveMaze, nodeFinder } from './PathfindingFunctions/mazeSolvingFunctions.js';\nimport { animateMazeDrawing, animateMazeSolving, animateMazeSolvingBacktrack } from './PathfindingFunctions/mazeAnimatingFunctions.js';\n\n\nconst Pathfinding = () => {\n    const canvas = useRef(null);\n    const [cellSize, setCellSize] = useState(10) // Fix this so that it's set with number of cells, not sizee !!!!\n    const [canvasDimensions, setCanvasDimensions] = useState({width: cellSize*51, height: cellSize*51, x: 0, y: 0}) //FIX SO THAT SET PROGRAMMATICALLY\n    const [grid, setGrid] = useState([])\n    const [mazeAnimations, setMazeAnimations] = useState({ drawingAnimations: [], nodeAnimations: [] })\n    const [solvingAnimations, setSolvingAnimations] = useState([])\n    const [drawSpeed, setDrawSpeed] = useState(0)\n    const [mazeGenAlgo, setMazeGenAlgo] = useState(\"eller's\")\n    const [mazeSolveAlgo, setMazeSolveAlgo] = useState(\"depthFirst\")\n\n    useEffect(() => {\n        const [initialGrid, x, y] = initializeGrid(canvas, cellSize, canvasDimensions)\n        console.log(window.innerHeight);\n        \n        setGrid(initialGrid)\n        setCanvasDimensions({\n            ...canvasDimensions,\n            x,\n            y\n        })\n\n    }, [])\n\n    \n    \n\n    // Get all algorithms to work on the non-maze board\n    // Once finished, fix up website and prepare for deployment\n\n    // Possible add-ons\n        // Pixelpainting descrambler\n        // Other maze-building algos - Hunt & kill, sidewinder, prims, kruskal, ellers\n        // Other algorithms - \n            // Pathfinding - best first search\n            // Sorting Heap Sort\n        // More animations - \n            //Pathfinding - show red backtrack and removal for backtracking building algo, current node highlighted in green, path in rainbow colors, show nodes of node graph and connnxns, make a binary search tree and animate it being built\n            // Sorting - \n        // More functionality \n            //Pathfinding - can go forwards and reverse, adjust number of loops, adjust size, adjust speed, reset maze solve or build, make it possible to skip animations, random wall generation, A* draws the optimal path, Dijkstra draws the optimal path?\n\n    \n\n    const [mazeGenerating, setMazeGenerating] = useState(false)\n\n    useEffect(() => {\n        \n        if(mazeGenerating) {\n            const fillGrid = fillCanvas(canvas, cellSize)\n\n            const [mazeGrid, animations, mazeFinished] = generateMaze(fillGrid, mazeGenAlgo)\n\n            setMazeAnimations(animations)\n            setGrid(mazeGrid)\n            if (mazeFinished) {\n                setMazeGenerating(false)\n            }\n\n        }\n    }, [mazeGenerating])\n\n\n\n    const [backtrackingAnimations, setBacktrackingAnimations] = useState([])\n    \n\n    const [mazeSolving, setMazeSolving] = useState(false)\n    useEffect(() => {\n        if (mazeSolving) {\n            const defaults = { enter: [0, 1], exit: [grid.length - 1, grid[0].length - 2], start: [1, 1] };\n            const animations = solveMaze(grid, defaults, mazeSolveAlgo)\n            console.log(\"maze done\");\n            \n            setSolvingAnimations(animations.solvingAnimations)\n            setBacktrackingAnimations(animations.backtrackingAnimations)\n            setMazeSolving(false)\n        }\n        \n    }, [mazeSolving, grid])\n\n\n    \n\n    useEffect(() => {\n        const test = animateMazeDrawing(mazeAnimations, canvas, cellSize, drawSpeed);\n        console.log(test);\n        \n    }, [mazeAnimations]);\n\n\n    \n\n    useEffect(() => {\n        animateMazeSolving(solvingAnimations, canvas, cellSize, drawSpeed)\n    }, [ solvingAnimations]);\n\n    \n\n    useEffect(() => {\n        const delay = solvingAnimations.length * drawSpeed;\n        animateMazeSolvingBacktrack(backtrackingAnimations, canvas, cellSize, drawSpeed, delay)\n    }, [backtrackingAnimations]);\n    \n    const handleOnClick = (e) => {\n        \n        const [row, col] = [Math.floor((e.clientY - canvasDimensions.y) / cellSize), Math.floor((e.clientX - canvasDimensions.x + .5) / cellSize)];\n        \n        const newGrid = [...grid];\n\n        const ctx = canvas.current.getContext('2d');\n        if (grid[row][col] !== \"wall\") {\n            ctx.fillStyle = \"#444\";\n            ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n        } else {\n            ctx.clearRect(col * cellSize, row * cellSize, cellSize, cellSize);\n        }\n\n        newGrid[row][col] = (newGrid[row][col] === \"wall\") ? \"wall\" : \"path\"\n        setGrid(newGrid)\n    };\n\n\n    const [mouseDown, setMouseDown] = useState(false)\n    const [fillType, setFillType] = useState(\"wall\")\n    const handleMouseDown = (e) => {\n        setMouseDown(true)\n        console.log(e);\n        const [row, col] = [Math.floor((e.clientY - canvasDimensions.y) / cellSize), Math.floor((e.clientX - canvasDimensions.x + .5) / cellSize)];\n        setFillType((grid[row][col] === \"wall\") ? \"path\" : \"wall\")\n    }\n\n    const handleMouseUp = (e) => {\n        setMouseDown(false)\n    }\n\n    const handleMouseOut = (e) => {\n        setMouseDown(false)\n    }\n\n    const handleMouseMove = (e) => {\n        if (mouseDown) {\n            const [row, col] = [Math.floor((e.clientY - canvasDimensions.y) / cellSize), Math.floor((e.clientX - canvasDimensions.x + .5) / cellSize)];\n\n            const newGrid = [...grid];\n\n            const ctx = canvas.current.getContext('2d');\n            if (fillType === \"wall\") {\n                ctx.fillStyle = \"#444\";\n                ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n                newGrid[row][col] = \"wall\";\n            } else {\n                ctx.clearRect(col * cellSize, row * cellSize, cellSize, cellSize);\n                newGrid[row][col] = \"path\";\n            }\n\n            setGrid(newGrid)\n        }\n    }\n\n    const handleClearCanvas = () => {\n        const clearGrid = clearCanvas(canvas, cellSize)\n        setGrid(clearGrid)\n    }\n\n    const handleFillCanvas = () => {\n        const fillGrid = fillCanvas(canvas, cellSize)\n        setGrid(fillGrid)\n    }\n\n    \n    return (\n        <div>\n            <div className=\"nav-bar\">\n                <div className=\"gen-algo-bar\">\n                    <button onClick={() => setMazeGenAlgo(\"eller's\")}>Eller's</button>\n                    <button onClick={() => setMazeGenAlgo(\"depthFirst\")}>Depth First</button>\n                </div>\n                <div className=\"gen-algo-bar\">\n                    <button onClick={() => setMazeSolveAlgo(\"depthFirst\")}>Depth First</button>\n                    <button onClick={() => setMazeSolveAlgo(\"breadthFirst\")}>Breadth First</button>\n                    <button onClick={() => setMazeSolveAlgo(\"dijkstra's\")}>Dijkstra's</button>\n                    <button onClick={() => setMazeSolveAlgo(\"a-star\")}>A-star</button>\n                </div>\n                <div className=\"sliders-bar\">\n                    <input onChange=\"\" type=\"range\" min=\"1\" max=\"100\" value=\"50\" class=\"slider\" id=\"myRange\"></input>\n                </div>\n            </div>\n            <div id=\"canvas\">\n                <button onClick={handleClearCanvas}>Clear</button>\n                <button onClick={handleFillCanvas}>Fill</button>\n                <canvas onClick={handleOnClick} onMouseDown={handleMouseDown} onMouseUp={handleMouseUp} onMouseOut={handleMouseOut} onMouseMove={handleMouseMove} ref={canvas}></canvas>\n                <button onClick={() => setMazeGenerating(true)}>Generate Maze</button>\n                <button onClick={() => setMazeSolving(true)}>Solve Maze</button>\n                <button onClick ={() => animateMazeDrawing.play()}>Play</button>\n            </div>\n        </div>\n    )\n}\n\nexport default Pathfinding;\n","import React from 'react';\nimport { BrowserRouter as Router, Route, Switch, Link } from 'react-router-dom';\n\nimport './app.css';\n\nimport Sorting from './Sorting';\nimport Pathfinding from './Pathfinding'\n\nconst App = () => {\n    return (\n        <div className=\"page\">\n             <Router>\n                <nav className=\"nav-bar\">\n                    <div>\n                        <ul className=\"chart-types\">\n                            <li><Link className=\"chart-link\" id=\"sorting\"to=\"/sorting\">Sorting</Link></li>\n                            <li><Link  className=\"chart-link\" id=\"pathfinding\" to=\"/pathfinding\">Pathfinding</Link></li>\n                        </ul>\n                    </div>\n                </nav>\n\n                <Switch>\n                    <Route path=\"/sorting\">\n                        <Sorting />\n                    </Route>\n                    <Route path=\"/pathfinding\">\n                        <Pathfinding />\n                    </Route>\n                </Switch>\n            </Router>\n        </div>\n    )\n};\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n    <App/> , document.getElementById('root')\n);\n\n"],"sourceRoot":""}