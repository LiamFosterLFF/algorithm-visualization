{"version":3,"sources":["Components/MainPage/maze-card-image.png","Components/MainPage/sorting-card-image.png","Components/MainNavbar.js","Components/MainPage/index.js","Components/DropdownMenu.js","Components/ControlButtons.js","Components/Sorting/utilities/barChartFunctions.js","Components/Sorting/utilities/colorMapFunctions.js","Components/Sorting/utilities/pixelMapFunctions.js","Components/Sorting/utilities/index.js","Components/Sorting/BarChart/Bar.js","Components/Sorting/BarChart/index.js","Components/Sorting/ColorMap/ColorBar.js","Components/Sorting/ColorMap/index.js","Components/Sorting/PixelMap/PixelBar.js","Components/Sorting/PixelMap/index.js","Components/Sorting/index.js","Components/Pathfinding/PathfindingFunctions/mazeGeneratingFunctions.js","Components/Pathfinding/PathfindingFunctions/mazeSolvingFunctions.js","Components/Slider.js","Components/Pathfinding/index.js","Components/useInterval.js","App.js","index.js"],"names":["module","exports","MainNavbar","url","location","useLocation","history","useHistory","handleClick","route","push","Navbar","Nav","variant","activeKey","pathname","Item","Link","href","onClick","toLowerCase","Collapse","className","to","MainPage","CardDeck","Card","style","cursor","Img","src","sortingCardImage","Body","Title","Text","Footer","Button","mazeCardImage","DropdownMenu","props","toggleText","title","type","menuOptions","algorithms","map","option","ind","Dropdown","select","Toggle","id","Menu","ControlButtons","buttons","size","ButtonGroup","button","function","disabled","text","mergeSortHelper","mainArray","startIdx","endIdx","auxArray","animations","midIdx","Math","floor","merge","i","j","k","animation","comparison","range","swap","sortFunctions","barChart","shuffle","barList","bar","barHeight","random","defaultSort","defaultSortAnimation","bubbleSort","origArr","arr","n","length","bubbleSortAnimation","chart","document","getElementsByClassName","barAnimations","forEach","index","bar1","bar2","ht1","ht2","animation1","animate","backgroundColor","duration","delay","animation2","height","fill","animation3","animation4","selectionSort","minIndex","selectionSortAnimation","baseChild","checkingChild","minChild","baseHeight","minHeight","insertionSort","insertionSortAnimation","swapElLt","swapElLtHt","swapElRt","swapElRtHt","mergeSort","origArray","mergeSortAnimation","compareEl1","compareEl2","swapEl","swapHt","quickSort","array","partition","left","right","pivot","quickSortHelper","quickSortAnimation","leftEl","rightEl","leftHt","rightHt","radixSort","countBuckets","max","toString","l","stringNum","d","shift","counter","num","radixSortAnimation","element","colorMap","colorList","color","hueValue","swapColor1","swapColor2","baseColor","minColor","swapElLtColor","swapElRtColor","swapColor","leftColor","rightColor","pixelMap","pixelBarList","pixBar","pixelBarHeights","compareEl1Bottom","childNodes","compareEl1Top","compareEl2Bottom","compareEl2Top","swapHt1Top","swapHt1Bottom","swapHt2Top","swapHt2Bottom","baseChildTop","baseChildBottom","minChildTop","minChildBottom","baseTopHeight","baseBottomHeight","minTopHeight","minBottomHeight","swapElLtTop","swapElLtBottom","swapElLtTopHeight","swapElLtBottomHeight","swapElRtTop","swapElRtBottom","swapElRtTopHeight","swapElRtBottomHeight","swapElTop","swapElBottom","swapTopHeight","swapBottomHeight","leftElTop","leftElBottom","rightElTop","rightElBottom","leftTopHeight","leftBottomHeight","rightTopHeight","rightBottomHeight","numArr","elementTop","elementBottom","heightTop","heightBottom","Bar","barStyle","BarChart","bars","barIndex","key","ColorBar","colorBarStyle","ColorMap","colorIndex","PixelBar","heights","firstSegmentStyle","secondSegmentStyle","thirdSegmentStyle","PixelMap","barHeights","Sorting","useState","chartType","setChartType","setBars","setAnimations","sort","setSort","sortType","setSortType","animationType","setAnimationType","useEffect","cancelAnimations","formatSortFunctionName","sortText","split","restartAnimations","pauseAnimations","playState","pause","cancel","Tabs","onSelect","Tab","eventKey","play","playAnimations","calculateCanvasSize","windowDims","cellSize","normalizeDimension","dimension","noOfCells","canvasViewportDims","width","getFullCanvas","canvasDimensions","cols","rows","fillGrid","row","col","defaultMazeAlgorithm","startNode","prevNode","origMazeGrid","ellersMazeAlgorithm","mazeGrid","JSON","parse","stringify","setNoCounter","undefined","placeHolder","setNo","setCounter","extensionNo","extensionCounter","extensionColumn","pathMazeGrid","depthFirstMazeAlgorithm","node","prevRow","prevCol","newAnimations","directionArray","Array","keys","nodeFinder","entrance","exit","nodeAnimations","nodeList","directions","direction","nodeMazeGrid","weightFinder","nodeWeights","nodeDirections","defaultSolvingAlgorithm","depthFirstSearchSolvingAlgorithm","endNode","newGrid","backtrackingAnimations","mazeEndFound","solvingAnimations","newNode","breadthFirstSearchSolvingAlgorithm","frontierQueue","backtrackDictionary","checking","breadthFirstRecursion","btNode","nodeAndWeightFinder","baseNode","nodeAndWeightList","isANode","dijkstrasSolvingAlgorithm","enterNode","exitNode","heuristic","lowestUnvisitedNode","distances","visitedNodes","min","Infinity","Object","entries","distance","currentDistanceStr","parentNodes","unvisitedNodes","currentNode","Number","currentNodeStr","currentDistance","edge","childNode","childNodeStr","totalWeight","edgeDistance","distanceFromStart","backtrackNode","newNodeStrArray","aStarSolvingAlgorithm","Slider","for","onChange","e","setValue","target","value","class","Pathfinding","mazeAnimations","mazeGenAlgo","setMazeGenAlgo","mazeSolveAlgo","setMazeSolveAlgo","storedMaze","setStoredMaze","animationSpeed","setAnimationSpeed","animationStack","setAnimationStack","playingAnimations","setPlayingAnimations","window","innerWidth","innerHeight","windowDimensions","setWindowDimensions","noOfCellsAcross","setCanvasDimensions","handleResize","addEventListener","_","removeEventListener","cells","setCells","ctx","getElementById","getContext","cell","fillStyle","fillRect","getMouseCellLocation","canvasBoundingBox","getBoundingClientRect","clientY","y","clientX","x","isDrawing","setIsDrawing","fillType","setFillType","previousPoint","setPreviousPoint","handleMouseOutUp","callback","savedCallback","useRef","current","setInterval","clearInterval","useInterval","newCells","remainingStack","noOfUpdates","handleFillCanvas","resetSolvingAnimations","onMouseDown","flippedCellContent","handleMouseDown","onMouseUp","onMouseOut","onMouseMove","isPreviousPoint","rowDiff","colDiff","maxDiff","abs","rowJump","colJump","mCol","handleMouseMove","getClearCanvas","grid","algorithm","mazeFinished","mazeAlgorithm","start","generateMaze","defaults","enter","solvingAlgorithm","solveMaze","App","from","path","component","ReactDOM","render"],"mappings":"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","file":"static/js/main.2cf0bc09.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/maze-card-image.f83e9fd7.png\";","module.exports = __webpack_public_path__ + \"static/media/sorting-card-image.9f5ceac9.png\";","import React from 'react';\nimport { Nav, Navbar } from 'react-bootstrap';\nimport { Link, useLocation, useHistory } from 'react-router-dom';\n\nconst MainNavbar = () => {\n\n    const location = useLocation();\n\n    const isCurrentURL = (url) => {\n        return location.pathname.toLowerCase() === url.toLowerCase();\n    }\n\n    let history = useHistory();\n    \n    const handleClick = (route) => {\n        history.push(`/${route}`);\n    }\n\n    return (\n        <Navbar>\n            <Nav variant=\"pills\" activeKey={location.pathname} >\n                <Nav.Item>\n                    <Nav.Link href=\"/sorting\" onClick={() => handleClick(\"sorting\")}>Sorting</Nav.Link>\n                </Nav.Item>\n                <Nav.Item>\n                    <Nav.Link href=\"/pathfinding\" onClick={() => handleClick(\"pathfinding\")}>Pathfinding</Nav.Link>\n                </Nav.Item>\n            </Nav>\n            { isCurrentURL(\"/main\") ? \n            null : \n            <Navbar.Collapse className=\"justify-content-end\">\n                <Link to=\"/main\">Back to Main</Link>\n            </Navbar.Collapse>\n            }\n        </Navbar>\n    )\n}\n\nexport default MainNavbar;","import React from 'react';\nimport { CardDeck, Card, Button } from 'react-bootstrap';\nimport { useHistory } from \"react-router-dom\";\n\nimport mazeCardImage from \"./maze-card-image.png\";\nimport sortingCardImage from \"./sorting-card-image.png\";\n\nconst MainPage = () => {\n\n    let history = useHistory();\n    \n    const handleClick = (route) => {\n        history.push(`/${route}`);\n    }\n      \n    return (\n        <CardDeck>\n            <Card onClick={() => handleClick(\"sorting\")} style={{cursor: \"pointer\"}}>\n                <Card.Img variant=\"top\" src={sortingCardImage} />\n                <Card.Body>\n                <Card.Title>Sorting Algorithms</Card.Title>\n                <Card.Text>\n                    Set of three different visualizations of the most common algorithms used for sorting arrays.\n                </Card.Text>\n                </Card.Body>\n                <Card.Footer>\n                    <Button>Click Here to Open</Button>\n                </Card.Footer>\n            </Card>\n            <Card onClick={() => handleClick(\"pathfinding\")} style={{cursor: \"pointer\"}}>\n                <Card.Img variant=\"top\" src={mazeCardImage}/>\n                <Card.Body>\n                <Card.Title>Maze Algorithms</Card.Title>\n                <Card.Text>\n                    Visualization of a set of algorithms commonly used for maze generation and solving.\n                </Card.Text>\n                </Card.Body>\n                <Card.Footer>\n                    <Button>Click Here to Open</Button>\n                </Card.Footer>\n            </Card>\n        </CardDeck>\n    )\n}\n\nexport default MainPage;","import React from 'react';\nimport { Dropdown } from 'react-bootstrap';\n\nconst DropdownMenu = (props) => {\n\n    const toggleText = (props.title === \"default\") ? `Choose ${props.type} Algorithm` : props.title;\n    const menuOptions = props.algorithms.map((option, ind) => \n        <Dropdown.Item \n            onClick={() => props.select(option)} \n            href={`#/action-${ind+1}`}\n        >\n            {option}\n        </Dropdown.Item>\n    )  \n\n    return (\n        <>\n            <Dropdown>\n                <Dropdown.Toggle variant=\"success\" id=\"dropdown-basic\">\n                    {toggleText}\n                </Dropdown.Toggle>\n\n                <Dropdown.Menu>\n                    {menuOptions}\n                </Dropdown.Menu>\n            </Dropdown>\n\n        </>\n    ) \n}\n\nexport default DropdownMenu;","import React from 'react';\nimport { Button, ButtonGroup } from 'react-bootstrap';\n\nconst ControlButtons = ({ buttons, size }) => {\n\n    return (\n        <div>\n            <ButtonGroup>\n                {buttons.map(button => \n                     <Button size={size || \"lg\"} onClick={() => button.function()} disabled={button.disabled}>{button.text}</Button>\n                )}\n            </ButtonGroup>\n        </div>\n    )\n}\nexport default ControlButtons;","\nconst shuffle = () => {\n    const bars = 100;\n    const barList = [];\n    for (let bar = 0; bar < bars; bar++) {\n        const barHeight = Math.floor(Math.random() * 1000);\n        barList.push(barHeight)\n    }\n    return barList;\n}\n\n const defaultSort = () => {\n    return []\n}\n\n const defaultSortAnimation = () => {\n    return []\n}\n\n// Bubble Sort\n const bubbleSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n                animations.push([[j, arr[j+1]], [j + 1, arr[j]]])\n            }\n        }\n        \n    }\n    return animations\n}\n\n const bubbleSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const bar1 = chart[animation[0][0]];\n        const bar2 = chart[animation[1][0]];\n        const ht1 = `${animation[0][1] / 10}%`\n        const ht2 = `${animation[1][1] / 10}%`\n        \n\n        // Highlight the two elements to be swapped, and swap their heights\n        // Default as paused so they don't start automatically every time\n        const animation1 = bar1.animate([{backgroundColor: 'rgb(51, 226, 217)'}, {backgroundColor: 'red'}], {duration: duration, delay: index * duration});\n        const animation2 = bar1.animate([{ height: ht2 }, { height: ht2 }], { fill: \"forwards\", duration: duration, delay: index * duration });\n        const animation3 = bar2.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration });\n        const animation4 = bar2.animate([{ height: ht1 }, { height: ht1 }], { fill: \"forwards\", duration: duration, delay: index * duration });\n\n        // Save animations for reuse\n        barAnimations.push(\n            animation1, animation2, animation3, animation4\n        )\n    })\n\n    return barAnimations\n}\n\n// Selection Sort \n const selectionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        let minIndex = i;\n        for (let j = i; j < n; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j\n            }\n            // Checks if sort has reached the end of Array, if so, records that there will be a swap between i and min\n            let swap = false;\n            if (j === n - 1) {\n                swap = true;\n            }\n            // Push the base Element, the element being checked, the current minimum, and an indication of whether a swap has occurred\n            animations.push([[i, arr[i]], [j, arr[j]], [minIndex, arr[minIndex]], swap])\n        }\n        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n    return animations\n}\n\n const selectionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 3;// The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n    \n    animations.forEach((animation, index) => {\n        const baseChild = chart[animation[0][0]];\n        const checkingChild = chart[animation[1][0]];\n        const minChild = chart[animation[2][0]];\n        const baseHeight = `${animation[0][1] / 10}%`\n        const minHeight = `${animation[2][1] / 10}%`\n        const swap = animation[3];\n\n        // Highlight the base of the section being checked, and the current element being compared against the minimum, in bubbleSort, while the min is highlighted in red\n        barAnimations.push(\n            baseChild.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'blue' }], { duration: duration, delay: index * duration }),\n            checkingChild.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'blue' }], { duration: duration, delay: index * duration }),\n            minChild.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration }),\n        )\n        // if the two elements are to be swapped, perform the swap \n        if (swap === true) {\n            barAnimations.push(\n                minChild.animate([{ height: baseHeight }, { height: baseHeight }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChild.animate([{ height: minHeight }, { height: minHeight }], { fill: \"forwards\", duration: duration, delay: index * duration })\n            )\n        }\n    })\n\n    return barAnimations\n}\n\n// Insertion Sort \n const insertionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n\n\n    // Move up through the array one at a time, and insert each new element into already sorted numbers to the left in its proper (ascending) position \n    for (let i = 1; i < n; i++) {\n        const key = arr[i]\n        let j = i - 1;\n        while (j >= 0 && arr[j] > arr[j+1]) {\n            animations.push([[j, arr[j]], [j+1, arr[j+1]]]);\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            j = j - 1\n        }\n    }\n    \n    return animations\n}\n\n const insertionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElLt = chart[animation[0][0]];\n        const swapElLtHt = `${animation[0][1] / 10}%`;\n        const swapElRt = chart[animation[1][0]];\n        const swapElRtHt = `${animation[1][1] / 10}%`;\n        \n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElRt.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            swapElRt.animate([{ height: swapElLtHt }, { height: swapElLtHt }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElLt.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            swapElLt.animate([{ height: swapElRtHt }, { height: swapElRtHt }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n    \n    return barAnimations\n}\n\n// Merge Sort \n const mergeSort = (origArray) => {\n    // Two separate arrays, one main one and one to hold swapped values until they can be unswapped. Avoids having to create a buffer array during the sorting process\n    const mainArray = [...origArray];\n    const auxArray = [...mainArray]\n    const n = mainArray.length\n    const animations = [];\n    if (n <= 1) {\n        return mainArray\n    }\n    // Initialize first function call\n    mergeSortHelper(mainArray, 0, n - 1, auxArray, animations);\n\n    return animations;\n}\n\nconst mergeSortHelper = (mainArray, startIdx, endIdx, auxArray, animations) => {\n    // Base case, returns if only one element in array\n    if (startIdx === endIdx) return;\n\n    // Find middle index of array, place to split before coming merge\n    const midIdx = Math.floor((startIdx + endIdx) / 2);\n\n    // recursively call function on each half of the array, to keep splitting until base case of 1 is reached. Also, notice that auxArray and mainArray are swapped from initial function call; it's complicated but basically this allows the aux array and main array to keep switching back and forth and save the values from the previous merge, which means that I don't have to create a temporary array to hold the values\n    mergeSortHelper(auxArray, startIdx, midIdx, mainArray, animations);\n    mergeSortHelper(auxArray, midIdx + 1, endIdx, mainArray, animations);\n\n    // Call the merge function to sort the values and combine back together\n    merge(mainArray, startIdx, midIdx, endIdx, auxArray, animations)\n}\n\nconst merge = (mainArray, startIdx, midIdx, endIdx, auxArray, animations) => {\n    // Copies the values of the aux array into the main array, putting the next lowest value from either array at value k\n    let i = startIdx;\n    let j = midIdx + 1;\n    let k = startIdx;\n    \n    // Pick the lowest value from either array and put it into the main array\n    while (i <= midIdx && j <= endIdx) {\n        const animation = {};\n        animation.comparison = [i, j];\n        animation.range = [startIdx, endIdx]\n        if (auxArray[i] >= auxArray[j]) {\n            animation.swap = [k, auxArray[j]]\n            mainArray[k++] = auxArray[j++]\n        } else {\n            animation.swap = [k, auxArray[i]]\n            mainArray[k++] = auxArray[i++]\n        }\n        animations.push(animation);\n    }\n\n    // While there are still values in only one of the two arrays being merged, copy them in; they are already ordered from previous sorts \n    while (j <= endIdx) {\n        animations.push({\n            comparison: [j, j],\n            swap: [k, auxArray[j]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[j++]\n\n    }\n    while (i <= midIdx) {\n        animations.push({\n            comparison: [i, i],\n            swap: [k, auxArray[i]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[i++]\n    }\n}\n\n const mergeSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 30;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const compareEl1 = chart[animation.comparison[0]];\n        const compareEl2 = chart[animation.comparison[1]];\n        const swapEl = chart[animation.swap[0]];\n        const swapHt = `${animation.swap[1] / 10}%`;\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            compareEl1.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            compareEl2.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            swapEl.animate([{ height: swapHt }, { height: swapHt }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n// Quick Sort \n const quickSort = (origArray) => {\n    // Copy original array so as not to mutate it \n    const array = [...origArray];\n    const animations = [];\n\n    const quickSortHelper = (array, left, right, animations) => {\n        if (left >= right) return;\n\n        // Find the center index, by sorting from the two ends and so that everything to the left of the pivot is smaller, and everything right is larger\n        const index = partition(array, left, right);\n        \n        // split the array into two halves, and call recursively on the two halves \n        quickSortHelper(array, left, index - 1, animations);\n        quickSortHelper(array, index, right, animations);\n    }\n\n    const partition = (array, left, right) => {\n        // Pivot starts from right end of subarray \n        const pivot = right;\n        right--;\n        // Keep moving pointers towards middle until two pointers cross one another\n        while (left <= right) {\n            // Find a left side element smaller than pivot, and a right side one larger, and switch them \n            while (array[left] < array[pivot]) {\n                left++\n            }\n            while (array[right] > array[pivot]) {\n                right--\n            }\n            if (left <= right) {\n                animations.push([[left, array[left]], [right, array[right]], [pivot, array[pivot]]]);\n                [array[left], array[right]] = [array[right], array[left]]\n                left++\n                right--\n            }\n        }\n        // Move the pivot into the middle \n        animations.push([[left, array[left]], [pivot, array[pivot]], [pivot, array[pivot]]]);\n        [array[left], array[pivot]] = [array[pivot], array[left]]\n        return left;\n    }\n    // Initial function call \n    quickSortHelper(array, 0, array.length - 1)\n\n    return animations\n}\n\n const quickSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 30;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        \n        const leftEl = chart[animation[0][0]];\n        const rightEl = chart[animation[1][0]];\n        const pivot = chart[animation[2][0]];\n        const leftHt = `${animation[0][1] / 10}%`;\n        const rightHt = `${animation[1][1] / 10}%`;\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            leftEl.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            leftEl.animate([{ height: leftHt }, { height: rightHt }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightEl.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'green' }], { duration: duration, delay: index * duration }),\n            rightEl.animate([{ height: rightHt }, { height: leftHt }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            pivot.animate([{ backgroundColor: 'rgb(51, 226, 217)' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n// Radix Bar Sort \n const radixSort = (origArr) => {\n    const arr = [...origArr] // Copy original array so as not to mutate it\n    const animations = [];\n\n    // initialize an array subarrays representing numbers 0 through 9, according to their index in parent array \n    const countBuckets = [];\n    for (let i = 0; i < 10; i++) {\n        countBuckets[i] = []\n    }\n\n    let max = 0;\n    // find length of longest number by digits, by converting it to string and measuring its length, then comparing to all other numbers \n    for (let j = 0; j < arr.length; j++) {\n        max = (arr[j].toString().length > max) ? arr[j].toString().length : max;\n    }\n\n    // cycle through array once for each digit in longest number from array \n    for (let l = 0; l < max; l++) {\n\n        while (arr.length) {\n            const stringNum = arr[0].toString()  // Convert front number in array to string\n            const d = stringNum.length - l - 1 // Starting from rightmost digit on first iteration, then moving left on next iteration\n            const digit = (stringNum[d]) ? stringNum[d] : 0 // Select either that digit, or (if too short) use 0\n            countBuckets[digit].push(arr.shift()) // Remove number from array and place into bucket array corresponding to that digit\n        }\n        let counter = 0;\n        for (let i = 0; i < 10; i++) { // Cycle through all 10 counter arrays, from lowest to highest\n            while (countBuckets[i].length) {  // Cycle through counter array until empty\n                const num = countBuckets[i].shift() // Save number in variable, so it can be added both to old array and to animation\n                arr.push(num)\n                animations.push([num, counter])\n                counter++\n            }\n        }\n    }\n    return animations\n\n}\n\n const radixSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"bar\");\n    const duration = 30;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const element = chart[animation[1]];\n        const height = `${animation[0] / 10}%`;\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            element.animate([{ backgroundColor: 'red' }, { backgroundColor: 'red' }], { duration: duration, delay: index * duration }),\n            element.animate([{ height: height }, { height: height }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\nconst barChartFunctions = {\n    shuffle,\n    defaultSort,\n    defaultSortAnimation,\n    bubbleSort, \n    bubbleSortAnimation, \n    selectionSort,\n    selectionSortAnimation,\n    insertionSort,\n    insertionSortAnimation,\n    mergeSort,\n    mergeSortAnimation,\n    quickSort,\n    quickSortAnimation,\n    radixSort,\n    radixSortAnimation,\n}\n\nexport default barChartFunctions;\n// // Color Map Animations\n\n// // Bubble Sort Color Map Animation\n// export const colorMapBubbleSortAnimation = (animations) => {\n//     // Sets the animations using the Web Animations API\n//     const chart = document.getElementsByClassName(\"color-bar\");\n//     const duration = .5;   // The base duration, for easy changing later (duration can also be changed via the API)\n//     const barAnimations = [];\n//     animations.forEach((animation, index) => {\n//         const compareEl1 = chart[animation[0][0]];\n//         const compareEl2 = chart[animation[1][0]];\n//         const swapColor1 = animation[0][1];\n//         const swapColor2 = animation[1][1];\n\n\n//         // Exchange the colors of the two elements being selected\n//         barAnimations.push(\n//             compareEl1.animate([{ backgroundColor: `hsl(${swapColor2}, 100%, 50%)` }, { backgroundColor: `hsl(${swapColor2}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n//             compareEl2.animate([{ backgroundColor: `hsl(${swapColor1}, 100%, 50%)` }, { backgroundColor: `hsl(${swapColor1}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n\n//         )\n\n//     })\n//     return barAnimations\n// }\n\n\n// // PixelMap Animations \n\n// // Pixel Map Bubble Sort\n// export const pixelMapBubbleSort = (origArr) => {\n//     // Clone the original array so as not to mutate it\n//     const arr = [...origArr]\n//     // Store the indices of the swaps made in order, to be used in the animations\n//     const animations = []\n//     const n = arr.length;\n//     for (let i = 0; i < n; i++) {\n//         for (let j = 0; j < n - i - 1; j++) {\n//             if (arr[j][0] > arr[j + 1][0]) {\n//                 [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n//                 animations.push([j, j + 1])\n//             }\n//         }\n//     }\n//     return animations\n// }\n\n// // Bubble Sort Pixel Map Animation\n// export const bubbleSortPixelMapAnimation = (animations, speed) => {\n//     for (let i = 0; i < animations.length; i++) {\n//         const [ind1, ind2] = animations[i]\n//         setTimeout(() => {\n//             const parent = document.getElementsByClassName('chart');\n//             const child1 = parent[0].childNodes[ind1];\n//             const child2 = parent[0].childNodes[ind2];\n\n//             // child1.style.backgroundColor = \"red\";\n//             // child2.style.backgroundColor = \"red\";\n//             for (let i = 0; i <= 2; i++) {\n//                 [child1.childNodes[i].style.height, child2.childNodes[i].style.height] = [child2.childNodes[i].style.height, child1.childNodes[i].style.height]\n\n//             }\n//             setTimeout(() => {\n//                 // child1.style.backgroundColor = \"rgb(51, 226, 217)\";\n//                 // child2.style.backgroundColor = \"rgb(51, 226, 217)\";\n//             }, speed);\n//         }, i * speed);\n//     }\n// }\n\n\n\n\n\n// // ***Display Functions***\n\n// // BarChart\n// export const barShuffle = (bars) => {\n//     const barList = [];\n//     for (let bar = 0; bar < bars; bar++) {\n//         const barHeight = Math.floor(Math.random() * 1000);\n//         barList.push(barHeight)\n//     }\n//     return barList;\n// }\n\n\n// // ColorMap\n\n\n\n\n\n// // PixelMap\n// const shuffle = (array) => {\n\n//     for (let i = array.length - 1; i > 0; i--) {\n//         let j = Math.floor(Math.random() * (i + 1));\n//         [array[i], array[j]] = [array[j], array[i]];\n//     }\n//     return array\n// };\n\n\n// export const pixelBarShuffle = () => {\n//     const pixelBarList = [];\n//     const height = 200;\n//     for (let pixBar = 0; pixBar < height; pixBar++) {\n//         const pixelBarHeights = [height - pixBar - 1, 1, pixBar]\n//         pixelBarList.push(pixelBarHeights)\n//     }\n//     return shuffle(pixelBarList)\n// }\n\n\n// // PixelPainting\n\n\n\n\n\n\n\n\n","const shuffle = () => {\n    const bars = 200;\n    const colorList = [];\n    for (let color = 0; color < bars; color++) {\n        const hueValue = Math.floor(Math.random() * 359)\n\n        colorList.push(hueValue)\n    }\n    return colorList\n}\n\nconst defaultSort = () => {\n    return []\n}\n\nconst defaultSortAnimation = () => {\n    return []\n}\n\n// ColorMap Bubble Sort\n\nconst bubbleSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n\n    return animations\n}\n\n\n// Bubble Sort Color Map Animation\nconst bubbleSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = .5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n    animations.forEach((animation, index) => {\n        const compareEl1 = chart[animation[0][0]];\n        const compareEl2 = chart[animation[1][0]];\n        const swapColor1 = animation[0][1];\n        const swapColor2 = animation[1][1];\n\n\n        // Exchange the colors of the two elements being selected\n        barAnimations.push(\n            compareEl1.animate([{ backgroundColor: `hsl(${swapColor2}, 100%, 50%)` }, { backgroundColor: `hsl(${swapColor2}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            compareEl2.animate([{ backgroundColor: `hsl(${swapColor1}, 100%, 50%)` }, { backgroundColor: `hsl(${swapColor1}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n\n        )\n\n    })\n    return barAnimations\n}\n\n// Selection Sort \nconst selectionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        let minIndex = i;\n        for (let j = i; j < n; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j\n            }\n            // Checks if sort has reached the end of Array, if so, records that there will be a swap between i and min\n            let swap = false;\n            if (j === n - 1) {\n                swap = true;\n            }\n            // Push the base Element, the element being checked, the current minimum, and an indication of whether a swap has occurred\n            animations.push([[i, arr[i]], [j, arr[j]], [minIndex, arr[minIndex]], swap])\n        }\n        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n    return animations\n}\n\nconst selectionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = .5;// The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const baseChild = chart[animation[0][0]];\n        const minChild = chart[animation[2][0]];\n        const baseColor = animation[0][1]\n        const minColor = animation[2][1]\n        const swap = animation[3];\n\n        // if the two elements are to be swapped, perform the swap \n        if (swap === true) {\n            barAnimations.push(\n                minChild.animate([{ backgroundColor: `hsl(${baseColor}, 100%, 50%)` }, { backgroundColor: `hsl(${baseColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChild.animate([{ backgroundColor: `hsl(${minColor}, 100%, 50%)` }, { backgroundColor: `hsl(${minColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n            )\n        }\n    })\n\n    return barAnimations\n}\n\n// Insertion Sort \nconst insertionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n\n\n    // Move up through the array one at a time, and insert each new element into already sorted numbers to the left in its proper (ascending) position \n    for (let i = 1; i < n; i++) {\n        const key = arr[i]\n        let j = i - 1;\n        while (j >= 0 && arr[j] > arr[j + 1]) {\n            animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            j = j - 1\n        }\n    }\n\n    return animations\n}\n\nconst insertionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElLt = chart[animation[0][0]];\n        const swapElLtColor = animation[0][1];\n        const swapElRt = chart[animation[1][0]];\n        const swapElRtColor = animation[1][1];\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElLt.animate([{ backgroundColor: `hsl(${swapElRtColor}, 100%, 50%)` }, { backgroundColor: `hsl(${swapElRtColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElRt.animate([{ backgroundColor: `hsl(${swapElLtColor}, 100%, 50%)` }, { backgroundColor: `hsl(${swapElLtColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n// Merge Sort \nconst mergeSort = (origArray) => {\n    // Two separate arrays, one main one and one to hold swapped values until they can be unswapped. Avoids having to create a buffer array during the sorting process\n    const mainArray = [...origArray];\n    const auxArray = [...mainArray]\n    const n = mainArray.length\n    const animations = [];\n    if (n <= 1) {\n        return mainArray\n    }\n    // Initialize first function call\n    mergeSortHelper(mainArray, 0, n - 1, auxArray, animations);\n\n    return animations;\n}\n\nconst mergeSortHelper = (mainArray, startIdx, endIdx, auxArray, animations) => {\n    // Base case, returns if only one element in array\n    if (startIdx === endIdx) return;\n\n    // Find middle index of array, place to split before coming merge\n    const midIdx = Math.floor((startIdx + endIdx) / 2);\n\n    // recursively call function on each half of the array, to keep splitting until base case of 1 is reached. Also, notice that auxArray and mainArray are swapped from initial function call; it's complicated but basically this allows the aux array and main array to keep switching back and forth and save the values from the previous merge, which means that I don't have to create a temporary array to hold the values\n    mergeSortHelper(auxArray, startIdx, midIdx, mainArray, animations);\n    mergeSortHelper(auxArray, midIdx + 1, endIdx, mainArray, animations);\n\n    // Call the merge function to sort the values and combine back together\n    merge(mainArray, startIdx, midIdx, endIdx, auxArray, animations)\n}\n\nconst merge = (mainArray, startIdx, midIdx, endIdx, auxArray, animations) => {\n    // Copies the values of the aux array into the main array, putting the next lowest value from either array at value k\n    let i = startIdx;\n    let j = midIdx + 1;\n    let k = startIdx;\n\n    // Pick the lowest value from either array and put it into the main array\n    while (i <= midIdx && j <= endIdx) {\n        const animation = {};\n        animation.comparison = [i, j];\n        animation.range = [startIdx, endIdx]\n        if (auxArray[i] >= auxArray[j]) {\n            animation.swap = [k, auxArray[j]]\n            mainArray[k++] = auxArray[j++]\n        } else {\n            animation.swap = [k, auxArray[i]]\n            mainArray[k++] = auxArray[i++]\n        }\n        animations.push(animation);\n    }\n\n    // While there are still values in only one of the two arrays being merged, copy them in; they are already ordered from previous sorts \n    while (j <= endIdx) {\n        animations.push({\n            comparison: [j, j],\n            swap: [k, auxArray[j]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[j++]\n\n    }\n    while (i <= midIdx) {\n        animations.push({\n            comparison: [i, i],\n            swap: [k, auxArray[i]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[i++]\n    }\n}\n\nconst mergeSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapEl = chart[animation.swap[0]];\n        const swapColor = animation.swap[1];\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapEl.animate([{ backgroundColor: `hsl(${swapColor}, 100%, 50%)` }, { backgroundColor: `hsl(${swapColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n        )\n    })\n\n    return barAnimations\n}\n\n// Quick Sort \nconst quickSort = (origArray) => {\n    // Copy original array so as not to mutate it \n    const array = [...origArray];\n    const animations = [];\n\n    const quickSortHelper = (array, left, right, animations) => {\n        if (left >= right) return;\n\n        // Find the center index, by sorting from the two ends and so that everything to the left of the pivot is smaller, and everything right is larger\n        const index = partition(array, left, right);\n\n        // split the array into two halves, and call recursively on the two halves \n        quickSortHelper(array, left, index - 1, animations);\n        quickSortHelper(array, index, right, animations);\n    }\n\n    const partition = (array, left, right) => {\n        // Pivot starts from right end of subarray \n        const pivot = right;\n        right--;\n        // Keep moving pointers towards middle until two pointers cross one another\n        while (left <= right) {\n            // Find a left side element smaller than pivot, and a right side one larger, and switch them \n            while (array[left] < array[pivot]) {\n                left++\n            }\n            while (array[right] > array[pivot]) {\n                right--\n            }\n            if (left <= right) {\n                animations.push([[left, array[left]], [right, array[right]], [pivot, array[pivot]]]);\n                [array[left], array[right]] = [array[right], array[left]]\n                left++\n                right--\n            }\n        }\n        // Move the pivot into the middle \n        animations.push([[left, array[left]], [pivot, array[pivot]], [pivot, array[pivot]]]);\n        [array[left], array[pivot]] = [array[pivot], array[left]]\n        return left;\n    }\n    // Initial function call \n    quickSortHelper(array, 0, array.length - 1)\n\n    return animations\n}\n\nconst quickSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const leftEl = chart[animation[0][0]];\n        const rightEl = chart[animation[1][0]];\n        const leftColor = animation[0][1];\n        const rightColor = animation[1][1];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            leftEl.animate([{ backgroundColor: `hsl(${rightColor}, 100%, 50%)` }, { backgroundColor: `hsl(${rightColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightEl.animate([{ backgroundColor: `hsl(${leftColor}, 100%, 50%)` }, { backgroundColor: `hsl(${leftColor}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n// Radix Bar Sort \nconst radixSort = (origArr) => {\n    const arr = [...origArr] // Copy original array so as not to mutate it\n    const animations = [];\n\n    // initialize an array subarrays representing numbers 0 through 9, according to their index in parent array \n    const countBuckets = [];\n    for (let i = 0; i < 10; i++) {\n        countBuckets[i] = []\n    }\n\n    let max = 0;\n    // find length of longest number by digits, by converting it to string and measuring its length, then comparing to all other numbers \n    for (let j = 0; j < arr.length; j++) {\n        max = (arr[j].toString().length > max) ? arr[j].toString().length : max;\n    }\n\n    // cycle through array once for each digit in longest number from array \n    for (let l = 0; l < max; l++) {\n\n        while (arr.length) {\n            const stringNum = arr[0].toString()  // Convert front number in array to string\n            const d = stringNum.length - l - 1 // Starting from rightmost digit on first iteration, then moving left on next iteration\n            const digit = (stringNum[d]) ? stringNum[d] : 0 // Select either that digit, or (if too short) use 0\n            countBuckets[digit].push(arr.shift()) // Remove number from array and place into bucket array corresponding to that digit\n        }\n        let counter = 0;\n        for (let i = 0; i < 10; i++) { // Cycle through all 10 counter arrays, from lowest to highest\n            while (countBuckets[i].length) {  // Cycle through counter array until empty\n                const num = countBuckets[i].shift() // Save number in variable, so it can be added both to old array and to animation\n                arr.push(num)\n                animations.push([num, counter])\n                counter++\n            }\n        }\n    }\n    return animations\n\n}\n\nconst radixSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"color-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const element = chart[animation[1]];\n        const color = animation[0];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            element.animate([{ backgroundColor: `hsl(${color}, 100%, 50%)` }, { backgroundColor: `hsl(${color}, 100%, 50%)` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\nconst colorMapFunctions = {\n    shuffle,\n    defaultSort,\n    defaultSortAnimation,\n    bubbleSort, \n    bubbleSortAnimation, \n    selectionSort,\n    selectionSortAnimation,\n    insertionSort,\n    insertionSortAnimation,\n    mergeSort,\n    mergeSortAnimation,\n    quickSort,\n    quickSortAnimation,\n    radixSort,\n    radixSortAnimation,\n};\n\nexport default colorMapFunctions;","const shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\nconst pixelBarShuffle = () => {\n    const height = 100;\n    const pixelBarList = [];\n    for (let pixBar = 0; pixBar < height; pixBar++) {\n        const pixelBarHeights = [pixBar, 1, height - pixBar - 1]\n        pixelBarList.push(pixelBarHeights)\n    }\n    return shuffle(pixelBarList)\n}\n\n// Sorting Functions\nconst defaultSort = () => {\n    return []\n}\n\nconst defaultSortAnimation = () => {\n    return []\n}\n\n// ColorMap Bubble Sort\nconst bubbleSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n            if (arr[j][0] > arr[j + 1][0]) {\n                animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n    \n    return animations\n}\n\n// Bubble Sort Color Map Animation\nconst bubbleSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = .5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n    animations.forEach((animation, index) => {\n        const compareEl1Bottom = chart[animation[0][0]].childNodes[0];\n        const compareEl1Top = chart[animation[0][0]].childNodes[2];\n        const compareEl2Bottom = chart[animation[1][0]].childNodes[0];\n        const compareEl2Top = chart[animation[1][0]].childNodes[2];\n\n        const swapHt1Top = animation[0][1][0];\n        const swapHt1Bottom = animation[0][1][2];\n\n        const swapHt2Top = animation[1][1][0];\n        const swapHt2Bottom = animation[1][1][2];\n\n        \n\n        // Exchange the colors of the two elements being selected\n        barAnimations.push(\n            compareEl1Bottom.animate([{ height: `${swapHt2Bottom}%` }, { height: `${swapHt2Bottom}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            compareEl1Top.animate([{ height: `${swapHt2Top}%` }, { height: `${swapHt2Top}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }), \n            compareEl2Bottom.animate([{ height: `${swapHt1Bottom}%` }, { height: `${swapHt1Bottom}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            compareEl2Top.animate([{ height: `${swapHt1Top}%` }, { height: `${swapHt1Top}%` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n\n    })\n    return barAnimations\n}\n\n// Selection Sort \nconst selectionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        let minIndex = i;\n        for (let j = i; j < n; j++) {\n            if (arr[j][0] < arr[minIndex][0]) {\n                minIndex = j\n            }\n            // Checks if sort has reached the end of Array, if so, records that there will be a swap between i and min\n            let swap = false;\n            if (j === n - 1) {\n                swap = true;\n            }\n            // Push the base Element, the element being checked, the current minimum, and an indication of whether a swap has occurred\n            animations.push([[i, arr[i]], [j, arr[j]], [minIndex, arr[minIndex]], swap])\n        }\n        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n    \n    return animations\n}\n\nconst selectionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = .5;// The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const baseChildTop = chart[animation[0][0]].childNodes[0];\n        const baseChildBottom = chart[animation[0][0]].childNodes[2];\n        const minChildTop = chart[animation[2][0]].childNodes[0];\n        const minChildBottom = chart[animation[2][0]].childNodes[2];\n        const baseTopHeight = animation[0][1][2];\n        const baseBottomHeight = animation[0][1][0];\n        const minTopHeight = animation[2][1][2];\n        const minBottomHeight = animation[2][1][0];\n        const swap = animation[3];\n        \n        // if the two elements are to be swapped, perform the swap \n        if (swap === true) {\n            barAnimations.push(\n                minChildTop.animate([{ height: `${baseTopHeight}%` }, { height: `${baseTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChildTop.animate([{ height: `${minTopHeight}%` }, { height: `${minTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                minChildBottom.animate([{ height: `${baseBottomHeight}%` }, { height: `${baseBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n                baseChildBottom.animate([{ height: `${minBottomHeight}%` }, { height: `${minBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n            )\n        }\n    })\n\n    return barAnimations\n}\n\n// Insertion Sort \nconst insertionSort = (origArr) => {\n    // Clone the original array so as not to mutate it\n    const arr = [...origArr]\n    // Store the indices of the swaps made in order, to be used in the animations\n    const animations = []\n    const n = arr.length;\n\n\n    // Move up through the array one at a time, and insert each new element into already sorted numbers to the left in its proper (ascending) position \n    for (let i = 1; i < n; i++) {\n        const key = arr[i]\n        let j = i - 1;\n        while (j >= 0 && arr[j][0] > arr[j + 1][0]) {\n            animations.push([[j, arr[j]], [j + 1, arr[j + 1]]]);\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            j = j - 1\n        }\n    }\n\n    return animations\n}\n\nconst insertionSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 3;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElLtTop = chart[animation[0][0]].childNodes[0];\n        const swapElLtBottom = chart[animation[0][0]].childNodes[2];\n        const swapElLtTopHeight = animation[0][1][2];\n        const swapElLtBottomHeight = animation[0][1][0];\n        const swapElRtTop = chart[animation[1][0]].childNodes[0];\n        const swapElRtBottom = chart[animation[1][0]].childNodes[2];\n        const swapElRtTopHeight = animation[1][1][2];\n        const swapElRtBottomHeight = animation[1][1][0];\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElLtTop.animate([{ height: `${swapElRtTopHeight}%` }, { height: `${swapElRtTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElLtBottom.animate([{ height: `${swapElRtBottomHeight}%` }, { height: `${swapElRtBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElRtTop.animate([{ height: `${swapElLtTopHeight}%` }, { height: `${swapElLtTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElRtBottom.animate([{ height: `${swapElLtBottomHeight}%` }, { height: `${swapElLtBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n        )\n    })\n\n    return barAnimations\n}\n\n// Merge Sort \nconst mergeSort = (origArray) => {\n    // Two separate arrays, one main one and one to hold swapped values until they can be unswapped. Avoids having to create a buffer array during the sorting process\n    const mainArray = [...origArray];\n    const auxArray = [...mainArray]\n    const n = mainArray.length\n    const animations = [];\n    if (n <= 1) {\n        return mainArray\n    }\n    // Initialize first function call\n    mergeSortHelper(mainArray, 0, n - 1, auxArray, animations);\n    \n    return animations;\n}\n\nconst mergeSortHelper = (mainArray, startIdx, endIdx, auxArray, animations) => {\n    // Base case, returns if only one element in array\n    if (startIdx === endIdx) return;\n\n    // Find middle index of array, place to split before coming merge\n    const midIdx = Math.floor((startIdx + endIdx) / 2);\n\n    // recursively call function on each half of the array, to keep splitting until base case of 1 is reached. Also, notice that auxArray and mainArray are swapped from initial function call; it's complicated but basically this allows the aux array and main array to keep switching back and forth and save the values from the previous merge, which means that I don't have to create a temporary array to hold the values\n    mergeSortHelper(auxArray, startIdx, midIdx, mainArray, animations);\n    mergeSortHelper(auxArray, midIdx + 1, endIdx, mainArray, animations);\n\n    // Call the merge function to sort the values and combine back together\n    merge(mainArray, startIdx, midIdx, endIdx, auxArray, animations)\n}\n\nconst merge = (mainArray, startIdx, midIdx, endIdx, auxArray, animations) => {\n    // Copies the values of the aux array into the main array, putting the next lowest value from either array at value k\n    let i = startIdx;\n    let j = midIdx + 1;\n    let k = startIdx;\n\n    // Pick the lowest value from either array and put it into the main array\n    while (i <= midIdx && j <= endIdx) {\n        const animation = {};\n        animation.comparison = [i, j];\n        animation.range = [startIdx, endIdx]\n        if (auxArray[i][0] >= auxArray[j][0]) {\n            animation.swap = [k, auxArray[j]]\n            mainArray[k++] = auxArray[j++]\n        } else {\n            animation.swap = [k, auxArray[i]]\n            mainArray[k++] = auxArray[i++]\n        }\n        animations.push(animation);\n    }\n\n    // While there are still values in only one of the two arrays being merged, copy them in; they are already ordered from previous sorts \n    while (j <= endIdx) {\n        animations.push({\n            comparison: [j, j],\n            swap: [k, auxArray[j]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[j++]\n\n    }\n    while (i <= midIdx) {\n        animations.push({\n            comparison: [i, i],\n            swap: [k, auxArray[i]],\n            range: [startIdx, endIdx]\n        })\n        mainArray[k++] = auxArray[i++]\n    }\n}\n\nconst mergeSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n        const swapElTop = chart[animation.swap[0]].childNodes[0];\n        const swapElBottom = chart[animation.swap[0]].childNodes[2];\n\n        const swapTopHeight = animation.swap[1][2];\n        const swapBottomHeight = animation.swap[1][0];\n\n\n        // Highlight two elements being compared in green, and animate them being swapped\n        barAnimations.push(\n            swapElTop.animate([{ height: `${swapTopHeight}%` }, { height: `${swapTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            swapElBottom.animate([{ height: `${swapBottomHeight}%` }, { height: `${swapBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n        )\n    })\n\n    return barAnimations\n}\n\n// Quick Sort \nconst quickSort = (origArray) => {\n    // Copy original array so as not to mutate it \n    const array = [...origArray];\n    const animations = [];\n\n    const quickSortHelper = (array, left, right, animations) => {\n        if (left >= right) return;\n\n        // Find the center index, by sorting from the two ends and so that everything to the left of the pivot is smaller, and everything right is larger\n        const index = partition(array, left, right);\n\n        // split the array into two halves, and call recursively on the two halves \n        quickSortHelper(array, left, index - 1, animations);\n        quickSortHelper(array, index, right, animations);\n    }\n\n    const partition = (array, left, right) => {\n        // Pivot starts from right end of subarray \n        const pivot = right;\n        right--;\n        // Keep moving pointers towards middle until two pointers cross one another\n        while (left <= right) {\n            // Find a left side element smaller than pivot, and a right side one larger, and switch them \n            while (array[left][2] < array[pivot][2]) {\n                left++\n            }\n            while (array[right][2] > array[pivot][2]) {\n                right--\n            }\n            if (left <= right) {\n                animations.push([[left, array[left]], [right, array[right]], [pivot, array[pivot]]]);\n                [array[left], array[right]] = [array[right], array[left]]\n                left++\n                right--\n            }\n        }\n        // Move the pivot into the middle \n        animations.push([[left, array[left]], [pivot, array[pivot]], [pivot, array[pivot]]]);\n        [array[left], array[pivot]] = [array[pivot], array[left]]\n        return left;\n    }\n    // Initial function call \n    quickSortHelper(array, 0, array.length - 1)\n    \n    return animations\n}\n\nconst quickSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const leftElTop = chart[animation[0][0]].childNodes[0];\n        const leftElBottom = chart[animation[0][0]].childNodes[2];\n        const rightElTop = chart[animation[1][0]].childNodes[0];\n        const rightElBottom = chart[animation[1][0]].childNodes[2];\n        const leftTopHeight = animation[0][1][0];\n        const leftBottomHeight = animation[0][1][2];\n        const rightTopHeight = animation[1][1][0];\n        const rightBottomHeight = animation[1][1][2];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            leftElTop.animate([{ height: `${rightTopHeight}%` }, { height: `${rightTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            leftElBottom.animate([{ height: `${rightBottomHeight}%` }, { height: `${rightBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightElTop.animate([{ height: `${leftTopHeight}%` }, { height: `${leftTopHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            rightElBottom.animate([{ height: `${leftBottomHeight}%` }, { height: `${leftBottomHeight}%` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\n// Radix Bar Sort \nconst radixSort = (origArr) => {\n    const arr = [...origArr] // Copy original array so as not to mutate it\n    const animations = [];\n\n    // initialize an array subarrays representing numbers 0 through 9, according to their index in parent array \n    const countBuckets = [];\n    for (let i = 0; i < 10; i++) {\n        countBuckets[i] = []\n    }\n\n    let max = 0;\n    // find length of longest number by digits, by converting it to string and measuring its length, then comparing to all other numbers \n    for (let j = 0; j < arr.length; j++) {\n        max = (arr[j].toString().length > max) ? arr[j].toString().length : max;\n    }\n\n    // cycle through array once for each digit in longest number from array \n    for (let l = 0; l < max; l++) {\n\n        while (arr.length) {\n            const stringNum = arr[0][0].toString()  // Convert front number in array to string\n            const d = stringNum.length - l - 1 // Starting from rightmost digit on first iteration, then moving left on next iteration\n            const digit = (stringNum[d]) ? stringNum[d] : 0 // Select either that digit, or (if too short) use 0\n            countBuckets[digit].push(arr.shift()) // Remove number from array and place into bucket array corresponding to that digit\n        }\n        let counter = 0;\n        for (let i = 0; i < 10; i++) { // Cycle through all 10 counter arrays, from lowest to highest\n            while (countBuckets[i].length) {  // Cycle through counter array until empty\n                const numArr = countBuckets[i].shift() // Save number in variable, so it can be added both to old array and to animation\n                arr.push(numArr)\n                animations.push([numArr, counter])\n                counter++\n            }\n        }\n    }\n    \n    return animations\n\n}\n\nconst radixSortAnimation = (animations) => {\n    // Sets the animations using the Web Animations API\n    const chart = document.getElementsByClassName(\"pixel-bar\");\n    const duration = 5;   // The base duration, for easy changing later (duration can also be changed via the API)\n    const barAnimations = [];\n\n    animations.forEach((animation, index) => {\n\n        const elementTop = chart[animation[1]].childNodes[0];\n        const elementBottom = chart[animation[1]].childNodes[2];\n        const heightTop = animation[0][2];\n        const heightBottom = animation[0][0];\n\n\n        // Highlight two elements being compared in green, and pivot in red, and animate them being swapped\n        barAnimations.push(\n            elementTop.animate([{ height: `${heightTop}%` }, { height: `${heightTop}%` }], { fill: \"forwards\", duration: duration, delay: index * duration }),\n            elementBottom.animate([{ height: `${heightBottom}%` }, { height: `${heightBottom}%` }], { fill: \"forwards\", duration: duration, delay: index * duration })\n        )\n    })\n\n    return barAnimations\n}\n\nconst pixelMapFunctions = {\n    shuffle: pixelBarShuffle,\n    defaultSort,\n    defaultSortAnimation,\n    bubbleSort, \n    bubbleSortAnimation, \n    selectionSort,\n    selectionSortAnimation,\n    insertionSort,\n    insertionSortAnimation,\n    mergeSort,\n    mergeSortAnimation,\n    quickSort,\n    quickSortAnimation,\n    radixSort,\n    radixSortAnimation,\n};\n\nexport default pixelMapFunctions;","import barChart from \"../utilities/barChartFunctions\";\nimport colorMap from \"../utilities/colorMapFunctions\";\nimport pixelMap from \"../utilities/pixelMapFunctions\";\n\nconst sortFunctions = {\n    barChart,\n    colorMap,\n    pixelMap\n}\n\nexport default sortFunctions;","import React from 'react';\n\nconst Bar = ({ height }) => {\n    const barHeightinPercent = height/10;\n    const barStyle = {\n        height: `${barHeightinPercent}%`\n    }\n    \n    return (\n        <div className=\"bar\" style={barStyle}></div>\n    )\n}\n\nexport default Bar;","import React from 'react';\nimport Bar from './Bar';\n\nconst BarChart = ({ bars }) => {\n    return (\n        <div className=\"chart\">\n            {bars.map((barHeight, barIndex) => {\n                return (\n                    <Bar key={barIndex} height={barHeight} />\n                )\n            })}\n        </div>\n    )\n}\n\nexport default BarChart;","import React from 'react';\n\nconst ColorBar = ({ color }) => {\n\n    const colorBarStyle = {\n        backgroundColor: `hsl(${color}, 100%, 50%)`\n    }\n    \n    return (\n        <div className=\"color-bar\" style={colorBarStyle}></div>\n    )\n}\n\nexport default ColorBar;","import React from 'react';\nimport ColorBar from \"./ColorBar\";\n\nconst ColorMap = ({ bars }) => {\n\n    return (\n        <div className=\"chart\">\n            {bars.map((color, colorIndex) => {\n                return (\n                    <ColorBar key={colorIndex} color={color} />\n                )\n            })}\n        </div>\n    )\n}\n\nexport default ColorMap;","import React from 'react';\n\nconst PixelBar = ({ heights }) => {\n    const firstSegmentStyle = {\n        height: `${heights[0]}%`,\n        backgroundColor: '#000'\n    }\n    const secondSegmentStyle = {\n        height: `${heights[1]}%`,\n        backgroundColor: '#fff)'\n    }\n    const thirdSegmentStyle = {\n        height: `${heights[2]}%`,\n        backgroundColor: '#000'\n    }\n\n    \n    return (\n        <div className=\"pixel-bar\">\n            <div style={firstSegmentStyle}></div>\n            <div style={secondSegmentStyle}></div>\n            <div style={thirdSegmentStyle}></div>\n        </div>\n    )\n}\n\nexport default PixelBar;","import React, { useState, useEffect } from 'react';\nimport PixelBar from \"./PixelBar\";\n\nconst PixelMap = ({ bars }) => {\n\n    return (\n        <div className=\"chart\">\n            {bars.map((barHeights, barIndex) => {\n                return (\n                    <PixelBar key={barIndex} heights={barHeights} />\n                )\n            })}\n        </div>\n    )\n}\n\nexport default PixelMap;","import React, { useState, useEffect } from 'react';\nimport { Tab, Tabs } from 'react-bootstrap';\n\nimport DropdownMenu from '../DropdownMenu';\nimport ControlButtons from '../ControlButtons';\nimport sortFunctions from \"./utilities\";\n\nimport BarChart from './BarChart';\nimport ColorMap from './ColorMap';\nimport PixelMap from './PixelMap';\n// import PixelPainting from './PixelPainting';\n\nconst Sorting = () => {  \n    \n    const [ chartType, setChartType ] = useState(\"barChart\");\n    const [ bars, setBars] = useState(sortFunctions[chartType].shuffle());\n    const [ animations, setAnimations ] = useState([])\n    // Sort value used to set sorts and animations, honestly following three could be a single state item\n    const [ sort, setSort ] = useState(\"default\")\n    const [ sortType, setSortType ] = useState({function: sortFunctions[chartType].defaultSort });\n    const [ animationType, setAnimationType ] = useState({ function: sortFunctions[chartType].defaultSortAnimation });\n    \n    // Side effect for changing chart type, resets bars and animations every time chart is changed (currently, could save possibly)\n    useEffect(() => {\n        cancelAnimations(animations)\n        setSort(\"default\")\n        // Currently, bars are set by their personal functions but this will need to change if they are to be changeable dynamically\n        setBars(sortFunctions[chartType].shuffle())\n        setAnimations([])\n    }, [chartType])\n    \n    // As said above, this would probably be better if it were a single usestate hook but this is how sorts are changed presently\n    useEffect(() => {\n        const formatSortFunctionName = (sortText) => {\n            return `${sortText.split(' ')[0].toLowerCase()}Sort`\n        }\n        setSortType({ function: sortFunctions[chartType][formatSortFunctionName(sort)]})\n        setAnimationType({ function: sortFunctions[chartType][formatSortFunctionName(sort) + 'Animation']})\n    }, [sort])\n\n    // Changing the sort type cancels the previous animations and sets new ones\n    useEffect(() => {\n        restartAnimations(animations, bars);\n    }, [sortType])\n\n\n    // Control functionality\n    const playAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") { animation.play() }\n        })\n    }\n\n    const pauseAnimations = (animations) => {\n        animations.map((animation) => {\n            if (animation.playState !== \"finished\") { animation.pause() }\n        })\n    }\n\n    const restartAnimations = (animations) => {\n        cancelAnimations(animations);\n        const barAnimations = animationType.function(sortType.function(bars));\n        pauseAnimations(barAnimations)\n        setAnimations(barAnimations);\n    }\n\n    const resetAnimations = () => {\n        setSort(\"default\");\n    }\n\n    const cancelAnimations = animations => {\n        animations.map((animation) => {\n            animation.cancel();\n        })\n    }   \n\n    return (\n        <div>\n            <Tabs\n                id=\"controlled-tab-example\"\n                activeKey={chartType}\n                onSelect={(chart) => setChartType(chart)}\n            >\n                <Tab eventKey=\"barChart\" title=\"Bar Chart\">\n                    <BarChart bars={bars}/>\n                </Tab>\n                <Tab eventKey=\"colorMap\" title=\"Color Map\">\n                    <ColorMap bars={bars}/>\n                </Tab>\n                <Tab eventKey=\"pixelMap\" title=\"Pixel Map\">\n                    <PixelMap bars={bars}/>\n                </Tab>\n            </Tabs>\n            <DropdownMenu\n                type={\"Sorting\"}\n                select={setSort}\n                title={sort}\n                algorithms={[\"Bubble Sort\", \"Insertion Sort\", \"Selection Sort\", \"Merge Sort\", \"Quick Sort\", \"Radix Sort\"]}\n            />\n            <ControlButtons \n                buttons={[\n                    { \"function\": () => playAnimations(animations), text: \"Play\", disabled: (sort === \"default\") } ,\n                    { \"function\": () => pauseAnimations(animations), text: \"Pause\", disabled: (sort === \"default\") } ,\n                    { \"function\": () => restartAnimations(animations), text: \"Restart\", disabled: (sort === \"default\") } ,\n                    { \"function\": () => resetAnimations(animations), text: \"Reset\", disabled: (sort === \"default\") }\n                ]}\n            />\n        </div>\n    )\n}\n\nexport default Sorting;\n\n","export const calculateCanvasSize = (windowDims, cellSize) => {\n    const normalizeDimension = (dimension, cellSize) => {\n        const noOfCells = Math.floor(dimension / cellSize);\n        // Cells have to be odd, as maze has a path every other cell\n        const oddNoOfCells = (noOfCells %2 === 0) ? noOfCells + 1 : noOfCells;\n        const normalizedDim = oddNoOfCells * cellSize;\n        return normalizedDim;\n    }\n\n    // Canvas dims are .8vw, .7vh\n    const canvasViewportDims = {width: .8, height: .7}\n    const canvasDims = {\n        width: normalizeDimension(windowDims.width * canvasViewportDims.width, cellSize), \n        height: normalizeDimension(windowDims.height * canvasViewportDims.height, cellSize)\n    }\n    return canvasDims;\n}\n\nexport const getFullCanvas = (canvasDimensions, cellSize) => {\n    // Construct Grid of Cells\n    const [cols, rows] = [canvasDimensions.width / cellSize, canvasDimensions.height / cellSize]\n    const fillGrid = [];\n    // Builds a rows*cols nested array full of walls\n    for (let row = 0; row < rows; row++) {\n        fillGrid.push([])\n        for (let col = 0; col < cols; col++) {\n            fillGrid[row].push(\"wall\")\n        }\n    }\n    return fillGrid\n}\n\nexport const getClearCanvas = (canvasDimensions, cellSize) => {\n    // Construct Grid of Cells\n    const [cols, rows] = [canvasDimensions.width / cellSize, canvasDimensions.height / cellSize]\n    const fillGrid = [];\n    // Builds a rows*cols nested array full of walls\n    for (let row = 0; row < rows; row++) {\n        fillGrid.push([])\n        for (let col = 0; col < cols; col++) {\n            fillGrid[row].push(\"path\")\n        }\n    }\n    return fillGrid\n}\n\n// Generate initial maze\nexport const generateMaze = (grid, algorithm) => {\n\n    // Number of total columns and total rows\n    let mazeGrid = JSON.parse(JSON.stringify(grid)); // Deep copy grid so as not to mutate\n    const [rows, cols] = [mazeGrid.length, mazeGrid[0].length]\n\n    // Animate drawing the entrance and exit\n    const [entrance, exit, start] = [[0, 1], [mazeGrid.length - 1, mazeGrid[0].length - 2], [1, 1]]\n    let mazeAnimations = [entrance, exit];\n\n    // Add entrance and exit to state, and to grid\n    mazeGrid[entrance[0]][entrance[1]] = \"path\";\n    mazeGrid[exit[0]][exit[1]] = \"path\";\n\n    // Calls with start as current and previous node; this is to allow for previous node to be used in recursive call\n    let mazeFinished;\n    let mazeAlgorithm;\n    switch (algorithm) {\n        case \"Eller's Algorithm\":\n            mazeAlgorithm = ellersMazeAlgorithm\n            break;\n        case \"Recursive Backtracking\":\n            mazeAlgorithm = depthFirstMazeAlgorithm\n            break;\n        case \"default\" :\n            mazeAlgorithm = defaultMazeAlgorithm;\n            break;\n    }\n\n    [mazeGrid, mazeAnimations, mazeFinished] = mazeAlgorithm(start, start, mazeGrid, mazeAnimations)\n    mazeAnimations = mazeAnimations.map((animation) => {\n        return {location: animation, type: \"path\"}\n    })\n    // Add a set number of loops to the maze\n    // const loops = 200;\n    // [mazeGrid, mazeAnimations] = loopMaker(mazeGrid, mazeAnimations, loops);\n\n    let [nodeAnimations, ] = nodeFinder(mazeGrid, entrance, exit)\n    nodeAnimations = nodeAnimations.map((animation) => {\n        return {location: animation, type: \"node\"}\n    })\n    const animations = { mazeAnimations, nodeAnimations }\n\n    return [mazeGrid, animations, mazeFinished]\n}\n\nconst shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\nconst defaultMazeAlgorithm = (startNode, prevNode, origMazeGrid, animations) => {\n    return [origMazeGrid, animations, true]\n}\n\nconst ellersMazeAlgorithm = (startNode, prevNode, origMazeGrid, animations) => {\n    const mazeGrid = JSON.parse(JSON.stringify(origMazeGrid)) // Deep copy so as not to mutate original array\n\n    let setNoCounter = 1; // To keep track of set names, so there's no repeats\n    for (let i = 1; i < mazeGrid[1].length - 1; i += 2) {\n        mazeGrid[1][i] = setNoCounter; // Initialize the cells of the first row to each exist in their own set.\n        animations.push([1,i])\n        setNoCounter++;\n    }\n\n    for (let j = 1; j < mazeGrid.length - 2; j += 2) {  // Repeat until the last row is reached\n        \n        for (let i = 1; i < mazeGrid[j].length - 1; i += 2) {// Randomly join adjacent cells, but only if they are not in the same set.\n            if (mazeGrid[j][i+2] !== undefined && mazeGrid[j][i] !== mazeGrid[j][i + 2]) {\n                if (Math.random() < .5) { // Some of the cells joined together, so left side and right of wall must match\n                    mazeGrid[j][i + 1] = mazeGrid[j][i];\n                    mazeGrid[j][i + 2] = mazeGrid[j][i];\n                    animations.push([j, i+1])\n                }\n            }\n        }\n        \n        let placeHolder = 1;\n        while (placeHolder < mazeGrid[j].length ) {// For each set, randomly create vertical connections downward to the next row\n            \n            const setNo = mazeGrid[j][placeHolder] // Number stored in grid for current set\n            let setCounter = 1;\n            while (mazeGrid[j][placeHolder + setCounter * 2] === setNo) { // Counts how many in a row have the same setNo\n                setCounter += 1\n            }\n            \n            // For each set, randomly create a random number (1+) of vertical connections downward to the next row.\n            const extensionNo = 1 + Math.floor(Math.random() * setCounter) * .5;\n            let extensionCounter = 0;\n            while (extensionCounter < extensionNo) {  // Keeps cycling until correct number of columns are created\n                const extensionColumn = Math.floor(Math.random() * setCounter) * 2;\n                if (mazeGrid[j + 1][placeHolder + extensionColumn] === \"wall\") {\n                    mazeGrid[j + 1][placeHolder + extensionColumn] = setNo;\n                    animations.push([j + 1, placeHolder + extensionColumn]);\n                    mazeGrid[j + 2][placeHolder + extensionColumn] = setNo;\n                    animations.push([j + 2, placeHolder + extensionColumn]);\n                    extensionCounter ++\n                }\n            } // Consecutive columns are linked together in next section\n\n            \n\n            placeHolder += setCounter*2; // Moves to the next set\n        }\n        \n        for (let l = 1; l < mazeGrid[j].length - 1; l += 2) { \n            if (mazeGrid[j + 2][l] === \"wall\") {// Flesh out the next row by putting any remaining cells into their own sets.\n                mazeGrid[j + 2][l] = setNoCounter;\n                animations.push([j + 2, l])\n                setNoCounter++\n            } \n        }\n    }\n    for (let i = 1; i < mazeGrid[0].length - 2; i+=2) { //For the last row, join all adjacent cells that do not share a set\n        if (mazeGrid[mazeGrid.length - 2][i] !== mazeGrid[mazeGrid.length - 2][i + 2]) {\n            mazeGrid[mazeGrid.length - 2][i + 1] = mazeGrid[mazeGrid.length - 2][i];\n            animations.push([mazeGrid.length - 2, i + 1]);\n            mazeGrid[mazeGrid.length - 2][i + 2] = mazeGrid[mazeGrid.length - 2][i];\n            animations.push([mazeGrid.length - 2, i + 2]);\n        }\n    }\n\n    const pathMazeGrid = []\n    for (let i = 0; i < mazeGrid.length; i++) {\n        const row = [];\n        for (let j = 0; j < mazeGrid[i].length; j++) {\n            if (mazeGrid[i][j] !== \"wall\") {\n                row.push(\"path\")\n            } else {\n                row.push(\"wall\")\n            }\n        }\n        pathMazeGrid.push(row)\n    }\n    \n\n    \n    return [pathMazeGrid, animations, true]\n    \n}\n\nconst depthFirstMazeAlgorithm = (startNode, prevNode, mazeGrid, animations) => {\n    // Draws maze using recursive depth-first algorithm\n    const node = startNode;\n\n    const [row, col] = node;\n\n    mazeGrid[row][col] = \"path\";\n    const [prevRow, prevCol] = prevNode\n    mazeGrid[prevRow][prevCol] = \"path\";\n    let deadEnd = false;\n\n    let newAnimations = [...animations, prevNode, node] // Add current node to path animation\n    const directionArray = shuffle([...Array(4).keys()]); // Create a random array of directions to choose from\n    for (let i = 0; i < 4; i++) {  // Choose the next direction to go in, or return dead end\n        const direction = directionArray[i]\n        switch (direction) {\n            case 0: // Up: if potential path column above is not edge or filled\n                if (((row - 2) >= 0) && (mazeGrid[row - 2][col] === \"wall\")) {\n                    const [midNode, newNode] = [[row - 1, col], [row - 2, col]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n            case 1: // Right: if two squares to the right is not over edge or filled\n                if (((col + 2) < mazeGrid[row].length) && (mazeGrid[row][col + 2] === \"wall\")) {\n                    const [midNode, newNode] = [[row, col + 1], [row, col + 2]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n            case 2: // Down: if potential path column below is not edge or filled\n\n                if (((row + 2) < mazeGrid.length) && (mazeGrid[row + 2][col] === \"wall\")) {\n                    const [midNode, newNode] = [[row + 1, col], [row + 2, col]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n            case 3: // Left: if two squares to the left is not over edge or filled\n                if (((col - 2) >= 0) && (mazeGrid[row][col - 2] === \"wall\")) {\n                    const [midNode, newNode] = [[row, col - 1], [row, col - 2]];\n                    [mazeGrid, newAnimations, deadEnd] = depthFirstMazeAlgorithm(newNode, midNode, mazeGrid, newAnimations)\n                }\n                break;\n        }\n    }\n    deadEnd = true\n    return [mazeGrid, newAnimations, deadEnd]\n}\n\nconst loopMaker = (mazeGrid, mazeAnimations, loopsRequired) => {\n    let loopsMade = 0;\n    while (loopsMade < loopsRequired) {\n        // Not selecting the bottom 20 % of the maze makes loops more likely to form\n        // Only selects numbers between 1 and 80% of mazeGrid length\n        const randRow = Math.floor(Math.random() * (mazeGrid.length * .8 - 1)) + 1\n        // Select any column except for first and last\n        const randCol = Math.floor(Math.random() * (mazeGrid[0].length - 2)) + 1\n        if ( // Forms loops better by only choosing walls sandwiched between two other walls, but not 3 ways corners\n            mazeGrid[randRow][randCol] === \"wall\"\n            && (\n                (mazeGrid[randRow + 1][randCol] === \"wall\" && mazeGrid[randRow - 1][randCol] === \"wall\" && mazeGrid[randRow][randCol + 1] !== \"wall\" && mazeGrid[randRow][randCol - 1] !== \"wall\") ||\n                (mazeGrid[randRow][randCol + 1] === \"wall\" && mazeGrid[randRow][randCol - 1] === \"wall\" && mazeGrid[randRow + 1][randCol] !== \"wall\" && mazeGrid[randRow - 1][randCol] !== \"wall\")\n            )\n        ) {\n            mazeGrid[randRow][randCol] = \"path\"\n            mazeAnimations.push([randRow, randCol])\n            loopsMade++\n        }\n    }\n\n    return [mazeGrid, mazeAnimations]\n}\n\nexport const nodeFinder = (mazeGrid, entrance, exit) => { // Finds nodes, points at which the maze either turns or forks, for use in building graphs\n    const nodeAnimations = [];\n    const nodeList = []; // List of nodes with the location and directions of nearest nodes\n\n    // Add the start of the maze to the animations\n    nodeAnimations.push(entrance)\n\n    nodeList.push([...entrance, [2]])\n\n    for (let row = 1; row < mazeGrid.length - 1; row++) { // Cycles through rows and columns, searching for nodes in each odd row/col\n        for (let col = 1; col < mazeGrid[0].length - 1; col++) {\n            const directions = [];\n            for (let direction = 0; direction < 4; direction++) {\n\n                switch (direction) {\n                    case 0:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row - 1][col] === \"path\") { // Up: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 1:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col + 1] === \"path\") { // Right: if potential path column right is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 2:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row + 1][col] === \"path\") { // Down: if potential path column down is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 3:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col - 1] === \"path\") { // Left: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                }\n            }\n            if (directions.length === 1) { // If dead end, corner, or intersection\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 2 && (directions[0] - directions[1]) % 2 !== 0) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 3 || directions.length === 4) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            }\n\n        }\n    }\n    // Add the end of the maze to the animations\n    nodeAnimations.push(exit)\n    nodeList.push([...exit, [0]])\n\n    const nodeMazeGrid = JSON.parse(JSON.stringify(mazeGrid))    // Deep copy the maze grid\n    nodeList.forEach(node => nodeMazeGrid[node[0]][node[1]] = \"node\")\n\n    const nodeWeights = weightFinder(nodeMazeGrid, nodeList)\n\n    return [nodeAnimations, nodeWeights]\n}\n\nconst weightFinder = (nodeMazeGrid, nodeList) => {\n    const nodeWeights = {};\n    nodeList.forEach(node => {\n        const [row, col] = [node[0], node[1]];\n        const nodeDirections = []\n        const directions = node[2]\n        directions.forEach(direction => {\n            let i = 1;\n\n\n            switch (direction) {\n                case 0: // Up\n                    while (row - i >= 0 && nodeMazeGrid[row - i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 1: // Right\n                    while (col + i < nodeMazeGrid[row].length && nodeMazeGrid[row][col + i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 2: // Down\n                    while (row + i < nodeMazeGrid.length && nodeMazeGrid[row + i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 3: // Left\n                    while (col - i >= 0 && nodeMazeGrid[row][col - i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n            }\n        })\n        nodeWeights[`${row},${col}`] = nodeDirections\n    })\n    return nodeWeights;\n}\n","export const nodeFinder = (mazeGrid, entrance, exit) => { // Finds nodes, points at which the maze either turns or forks, for use in building graphs\n    const nodeAnimations = [];\n    const nodeList = []; // List of nodes with the location and directions of nearest nodes\n\n    // Add the start of the maze to the animations\n    nodeAnimations.push(entrance)\n\n    nodeList.push([...entrance, [2]])\n\n    for (let row = 1; row < mazeGrid.length - 1; row++) { // Cycles through rows and columns, searching for nodes in each odd row/col\n        for (let col = 1; col < mazeGrid[0].length - 1; col++) {\n            const directions = [];\n            for (let direction = 0; direction < 4; direction++) {\n\n                switch (direction) {\n                    case 0:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row - 1][col] === \"path\") { // Up: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 1:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col + 1] === \"path\") { // Right: if potential path column right is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 2:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row + 1][col] === \"path\") { // Down: if potential path column down is path\n                            directions.push(direction)\n                        }\n                        break;\n                    case 3:\n                        if (mazeGrid[row][col] === \"path\" && mazeGrid[row][col - 1] === \"path\") { // Left: if potential path column above is path\n                            directions.push(direction)\n                        }\n                        break;\n                }\n            }\n            if (directions.length === 1) { // If dead end, corner, or intersection\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 2 && (directions[0] - directions[1]) % 2 !== 0) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            } else if (directions.length === 3 || directions.length === 4) {\n                nodeAnimations.push([row, col])\n                nodeList.push([row, col, directions])\n            }\n\n        }\n    }\n    // Add the end of the maze to the animations\n    nodeAnimations.push(exit)\n    nodeList.push([...exit, [0]])\n\n    const nodeMazeGrid = JSON.parse(JSON.stringify(mazeGrid))    // Deep copy the maze grid\n    nodeList.forEach(node => nodeMazeGrid[node[0]][node[1]] = \"node\")\n\n    const nodeWeights = weightFinder(nodeMazeGrid, nodeList)\n\n    return [nodeAnimations, nodeWeights]\n}\n\nconst weightFinder = (nodeMazeGrid, nodeList) => { // Finds weights for building an edge graph of the maze\n    const nodeWeights = {};\n    nodeList.forEach(node => {\n        const [row, col] = [node[0], node[1]];\n        const nodeDirections = []\n        const directions = node[2]\n        directions.forEach(direction => {\n            let i = 1;\n\n\n            switch (direction) {\n                case 0: // Up\n                    while (row - i >= 0 && nodeMazeGrid[row - i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 1: // Right\n                    while (col + i < nodeMazeGrid[row].length && nodeMazeGrid[row][col + i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 2: // Down\n                    while (row + i < nodeMazeGrid.length && nodeMazeGrid[row + i][col] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n                case 3: // Left\n                    while (col - i >= 0 && nodeMazeGrid[row][col - i] !== \"node\") {\n                        i++\n                    }\n                    nodeDirections.push([direction, i])\n                    break;\n            }\n        })\n        nodeWeights[`${row},${col}`] = nodeDirections\n    })\n    return nodeWeights;\n}\n\nconst shuffle = (array) => {\n\n    for (let i = array.length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n    return array\n};\n\n\n// Maze-solving algorithms:\n\nexport const solveMaze = (grid, defaults, algorithm) => {\n    const newGrid = JSON.parse(JSON.stringify(grid)); // Deep copy of grid\n    const animations = { solvingAnimations: [], backtrackingAnimations: [] };\n\n    let solvingAlgorithm;\n    switch (algorithm) {\n        case \"Depth-First Search\":\n            solvingAlgorithm = depthFirstSearchSolvingAlgorithm;\n            break;\n        case \"Breadth-First Search\":\n            solvingAlgorithm = breadthFirstSearchSolvingAlgorithm\n            break;\n        case \"Djikstra's Algorithm\":\n            solvingAlgorithm = dijkstrasSolvingAlgorithm\n            break;\n        case \"A* Search Algorithm\":\n            solvingAlgorithm = aStarSolvingAlgorithm\n            break;\n        default: \n            solvingAlgorithm = defaultSolvingAlgorithm;\n            break;\n    }\n\n    solvingAlgorithm(defaults.start, defaults.enter, defaults.exit, newGrid, animations)\n    const mappedSolvingAnimations = animations.solvingAnimations.map((animation) => {\n        return {location: animation, type: \"searched\"}\n    })\n    const mappedBacktrackingAnimations = animations.backtrackingAnimations.map((animation) => {\n        return {location: animation, type: \"backtrack\"}\n    })\n    \n    const mappedAnimations = {\n        solvingAnimations: mappedSolvingAnimations,\n        backtrackingAnimations: mappedBacktrackingAnimations\n    }\n    return mappedAnimations\n}\n\nconst defaultSolvingAlgorithm = (startNode, prevNode, origMazeGrid, animations) => {\n    return false\n}\n\nconst depthFirstSearchSolvingAlgorithm = (startNode, prevNode, endNode, newGrid, animations) => {\n    const node = startNode;\n\n    if ((node[0] === endNode[0]) && (node[1] === endNode[1])) {\n        animations.backtrackingAnimations.push(node)\n        animations.backtrackingAnimations.push(prevNode)\n        return true\n    }\n\n    let mazeEndFound = false;\n    const [row, col] = node;\n    newGrid[row][col] = \"checked\";\n    animations.solvingAnimations.push(node)\n\n    const directionArray = shuffle([...Array(4).keys()]);\n    for (let i = 0; i < 4; i++) {\n\n        const direction = directionArray[i]\n\n        switch (direction) {\n\n            case 0: // Up: checks if 2 squares up is not over edge and there is a path toward that direction\n                if ((row - 1 >= 0) && (newGrid[row - 1][col] === \"path\")) {\n                    const newNode = [row - 1, col];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n\n                }\n                break;\n            case 1: // Right: checks if 2 squares right is not over edge and there is a path toward that direction\n                if ((col + 1 < newGrid[row].length) && (newGrid[row][col + 1] === \"path\")) {\n                    const newNode = [row, col + 1];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n                }\n                break;\n            case 2: // Down: checks if 2 squares down is not over edge and there is a path toward that direction\n                if ((row + 1 < newGrid.length) && (newGrid[row + 1][col] === \"path\")) {\n                    const newNode = [row + 1, col];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n                }\n                break;\n            case 3: // Left: checks if 2 squares left is not over edge and there is a path toward that direction\n                if ((col - 1 >= 0) && (newGrid[row][col - 1] === \"path\")) {\n                    const newNode = [row, col - 1];\n                    animations.solvingAnimations.push(newNode)\n                    mazeEndFound = depthFirstSearchSolvingAlgorithm(newNode, node, endNode, newGrid, animations);\n                }\n                break;\n\n        }\n        if (mazeEndFound) {\n            animations.backtrackingAnimations.push(prevNode)\n            return mazeEndFound\n        }\n\n    }\n    return mazeEndFound\n\n}\n\nconst breadthFirstSearchSolvingAlgorithm = (startNode, prevNode, endNode, newGrid, animations) => {\n\n    const frontierQueue = [];\n    const backtrackDictionary = {};\n    frontierQueue.push(prevNode);\n    let checking = true;\n\n\n    const breadthFirstRecursion = (frontierQueue, endNode, newGrid, animations, backtrackDictionary) => {\n        const node = frontierQueue.shift();\n\n        if (node[0] === endNode[0] && node[1] === endNode[1]) return false\n\n        animations.solvingAnimations.push(node);\n\n        const [row, col] = [node[0], node[1]];\n        newGrid[row][col] = \"checked\";\n\n        for (let i = 0; i < 4; i++) {\n            const direction = i;\n\n            switch (direction) {\n\n                case 0: // Up: checks if 2 squares up is not over edge and there is a path toward that direction\n                    if ((row - 1 >= 0) && (newGrid[row - 1][col] === \"path\")) {\n                        const newNode = [row - 1, col];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n                case 1: // Right: checks if 2 squares right is not over edge and there is a path toward that direction\n                    if ((col + 1 < newGrid[row].length) && (newGrid[row][col + 1] === \"path\")) {\n                        const newNode = [row, col + 1];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n                case 2: // Down: checks if 2 squares down is not over edge and there is a path toward that direction\n                    if ((row + 1 < newGrid.length) && (newGrid[row + 1][col] === \"path\")) {\n                        const newNode = [row + 1, col];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n                case 3: // Left: checks if 2 squares left is not over edge and there is a path toward that direction\n                    if ((col - 1 >= 0) && (newGrid[row][col - 1] === \"path\")) {\n                        const newNode = [row, col - 1];\n                        frontierQueue.push(newNode);\n                        backtrackDictionary[newNode] = node;\n                    }\n                    break;\n\n            }\n        }\n        return (frontierQueue.length > 0)\n    }\n\n    while (checking) {\n        checking = breadthFirstRecursion(frontierQueue, endNode, newGrid, animations, backtrackDictionary);\n    }\n\n    let btNode = endNode;\n    animations.backtrackingAnimations.push(btNode);\n    while (!((btNode[0] === startNode[0]) && (btNode[1] === startNode[1]))) {\n        const dictionaryString = `${btNode[0]},${btNode[1]}`;\n        btNode = backtrackDictionary[dictionaryString]\n        animations.backtrackingAnimations.push(btNode);\n    }\n\n}\n\nconst nodeAndWeightFinder = (mazeGrid, baseNode) => { // Finds nodes, points at which the maze either turns or forks, and their corresponding weights to the base node\n    const nodeAndWeightList = []; // List of nodes with the location and directions of nearest nodes \n    const [row, col] = baseNode;\n    \n    for (let direction = 0; direction < 4; direction++) {\n        \n        let counter = 1;\n        let node;\n        switch (direction) {\n            case 0:\n                if (baseNode[0] - counter >= 0 && mazeGrid[baseNode[0] - counter][baseNode[1]] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0] - counter, baseNode[1]])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n            case 1:\n                if (baseNode[1] + counter < mazeGrid[0].length && mazeGrid[baseNode[0]][baseNode[1] + counter] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0], baseNode[1] + counter])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n            case 2:\n                if (baseNode[0] + counter < mazeGrid.length && mazeGrid[baseNode[0] + counter][baseNode[1]] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0] + counter, baseNode[1]])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n            case 3:\n                if (baseNode[1] - counter >= 0 && mazeGrid[baseNode[0]][baseNode[1] - counter] === \"path\") {\n                    while (!isANode(mazeGrid, [baseNode[0], baseNode[1] - counter])) { // Up: if potential path column above is path\n                        counter++\n                    }\n                    nodeAndWeightList.push([direction, counter])\n                }\n                break;\n        }\n    }\n    \n    return nodeAndWeightList\n}\n\nconst isANode = (mazeGrid, node) => { // Checks if selected location is a node or not\n    // Scans four directions and \n    const [row, col] = node;\n    \n    const directions = [];\n    if (row > 0 && mazeGrid[row - 1][col] === \"path\") { // Up\n        directions.push(0)\n    } \n    if (col < mazeGrid[0].length - 1 && mazeGrid[row][col + 1] === \"path\") { // Right\n        directions.push(1)\n    } \n    if (row < mazeGrid.length - 1 && mazeGrid[row + 1][col] === \"path\") { // Down\n        directions.push(2)\n    } \n    if (col > 0 && mazeGrid[row][col - 1] === \"path\") { // Left\n        directions.push(3)\n    }\n    \n    if (directions.length === 1 || directions.length > 2 || (directions[0] - directions[1]) % 2 !== 0) { \n        // Is either a dead end or a t-junction/4-way or a corner \n        return true\n    }\n\n    return false\n}\n\n\nconst dijkstrasSolvingAlgorithm = (startNode, enterNode, exitNode, mazeGrid, animations, heuristic = false) => {\n    const lowestUnvisitedNode = (distances, visitedNodes) => {\n        let min = [null, Infinity];\n        Object.entries(distances).forEach((distance) => {\n            const currentDistanceStr = distance[0];\n            if (!visitedNodes[currentDistanceStr] && distances[currentDistanceStr] < min[1]) {\n                min = [currentDistanceStr, distance[1]];\n            }\n        })\n\n        return (min[0] === null) ? null : min[0].split(\",\");\n    }\n\n    // Initialize distances dictionary for start and end nodes\n    const distances = {};\n    distances[`${enterNode[0]},${enterNode[1]}`] = 0;\n    distances[`${exitNode[0]},${exitNode[1]}`] = Infinity;\n\n    // Initialize parent nodes dictionary\n    const parentNodes = {};\n    parentNodes[`${exitNode[0]},${exitNode[1]}`] = null;\n\n    // Initialize arrays for visited and unvisited nodes\n    const visitedNodes = {};\n    let unvisitedNodes = nodeAndWeightFinder(mazeGrid, enterNode)\n    \n    let currentNode = enterNode;\n    animations.solvingAnimations.push(enterNode)\n    while (currentNode !== null && (currentNode[0] !== exitNode[0] && currentNode[1] !== exitNode[1])) { // Exits if out of nodes or at end\n        // Converts back from string to number\n        const [row, col] = [Number(currentNode[0]), Number(currentNode[1])];\n        animations.solvingAnimations.push([row, col])\n\n        const currentNodeStr = `${row},${col}` // String for node currently looking at, for lookup in dictionary\n        const currentDistance = distances[currentNodeStr]; // Distance of current node from start\n        unvisitedNodes = nodeAndWeightFinder(mazeGrid, [row, col]) // Find weights of all attached nodes, meaning distances from current node\n        unvisitedNodes.forEach((edge) => { // Cycle through all nearest nodes\n            const [direction, edgeDistance] = [edge[0], edge[1]] // Direction and distance/weight to that direction\n            let childNode, childNodeStr, totalWeight;\n            let hWeight = 0; // Additional heuristic weight, for use in A*\n            const distanceFromStart = currentDistance + edgeDistance\n\n            switch (direction) {\n                case 0: //Up\n                    // Make new node and node string\n                    childNode = [row - edgeDistance, col];  \n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0; \n                    totalWeight = distanceFromStart + hWeight\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                case 1: //Right\n                    // Make new node and node string\n                    childNode = [row, col + edgeDistance];\n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0;\n                    totalWeight = distanceFromStart + hWeight;\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                case 2: //Down\n                    // Make new node and node string\n                    childNode = [row + edgeDistance, col];\n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0;\n                    totalWeight = distanceFromStart + hWeight;\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                case 3: //Left\n                    // Make new node and node string\n                    childNode = [row, col - edgeDistance];\n                    childNodeStr = `${childNode[0]},${childNode[1]}`;\n                    // Calculate heuristic weight based on Manhattan distance, if using heuristic\n                    hWeight = (heuristic) ? (exitNode[0] - childNode[0]) + (exitNode[1] - childNode[1]) : 0;\n                    totalWeight = distanceFromStart + hWeight;\n                    // Update distance if weight is smaller than previously recorded (if recorded at all, else weight == infinity)\n                    if (distances[childNodeStr] === undefined || distances[childNodeStr] > (totalWeight)) {\n                        distances[childNodeStr] = totalWeight;\n                        parentNodes[childNodeStr] = currentNodeStr;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        })\n\n        visitedNodes[currentNodeStr] = unvisitedNodes;\n        currentNode = lowestUnvisitedNode(distances, visitedNodes)\n    }\n\n    if (currentNode === null || (currentNode[0] === exitNode[0] && currentNode[1] === exitNode[1])) {\n        let backtrackNode = exitNode;\n        animations.backtrackingAnimations.push(backtrackNode)\n\n        while (backtrackNode[0] !== enterNode[0] && backtrackNode[1] !== enterNode[1]) {\n            const newNodeStrArray = parentNodes[`${backtrackNode[0]},${backtrackNode[1]}`].split(\",\")\n            backtrackNode = [Number(newNodeStrArray[0]), newNodeStrArray[1]]\n            animations.backtrackingAnimations.push(backtrackNode)\n\n        }\n    }\n}\n\nconst aStarSolvingAlgorithm = (startNode, enterNode, exitNode, mazeGrid, animations) => {\n    dijkstrasSolvingAlgorithm(startNode, enterNode, exitNode, mazeGrid, animations, true)\n}","import React from 'react'\n\nconst Slider = (props) => {\n    return (\n        <div className=\"sliders-bar\">\n            <label for=\"myRange\">Animation Speed</label>\n            <input onChange={(e) => props.setValue(e.target.value)} type=\"range\" min=\"1\" max=\"100\" value={props.value} class=\"slider\" id=\"myRange\"></input>\n        </div>\n    )\n}\n\nexport default Slider;","import React, { useState, useEffect, useRef } from 'react';\nimport { useInterval } from '../useInterval'\n// Import all functions from a single file as a dictionary, order them better as well\nimport { initializeGrid, generateMaze, getFullCanvas, getClearCanvas, calculateCanvasSize } from './PathfindingFunctions/mazeGeneratingFunctions.js';\n\nimport { solveMaze, nodeFinder } from './PathfindingFunctions/mazeSolvingFunctions.js';\nimport { animateMazeDrawing, animateMazeSolving, animateMazeSolvingBacktrack } from './PathfindingFunctions/mazeAnimatingFunctions.js';\n\nimport DropdownMenu from '../DropdownMenu.js';\nimport ControlButtons from '../ControlButtons.js';\nimport Slider from '../Slider';\n\nconst Pathfinding = () => {\n    const [animations, setAnimations] = useState({ mazeAnimations: [], nodeAnimations: [], solvingAnimations: [], backtrackingAnimations: [] })\n    const [mazeGenAlgo, setMazeGenAlgo] = useState(\"default\")\n    const [mazeSolveAlgo, setMazeSolveAlgo] = useState(\"default\")\n    const [ storedMaze, setStoredMaze ] = useState([])\n    // Speed controlled by slider\n    const [ animationSpeed, setAnimationSpeed ] = useState(50)\n    // Animations controlled using a stack, allows for pausing as well as easy repeats and works better with interval\n    const [ animationStack, setAnimationStack ] = useState([])\n    const [ playingAnimations, setPlayingAnimations ] = useState(false)\n    const [windowDimensions, setWindowDimensions] = useState({ width: window.innerWidth, height: window.innerHeight });\n\n    // Calculate size of cells on basis of how many cells wide the maze should be (can be adjusted with slider)\n    const [noOfCellsAcross, setNoOfCellsAcross] = useState(100)\n    const [cellSize, setCellSize] = useState(Math.floor(windowDimensions.width / noOfCellsAcross))\n\n    // Calculate size of canvas on basis of cell size\n    const [canvasDimensions, setCanvasDimensions] = useState(calculateCanvasSize(windowDimensions, cellSize))\n\n    // Reset window dimension state every time window resized (w/ cleanup function)\n    useEffect(() => {\n        function handleResize() {\n            setWindowDimensions({\n                height: window.innerHeight,\n                width: window.innerWidth\n            })\n        }\n        window.addEventListener('resize', handleResize);\n\n        return _ => {\n            window.removeEventListener('resize', handleResize)\n        }\n    })\n\n    // Recalculate canvas dimensions every time window dimensions change\n    useEffect(() => {\n        setCanvasDimensions(calculateCanvasSize(windowDimensions, cellSize))\n    }, [windowDimensions])\n\n    const [cells, setCells] = useState(getFullCanvas(canvasDimensions, cellSize))\n    // Reset grid to completely filled in every time canvas resizes\n    useEffect(() => {\n        setCells(getFullCanvas(canvasDimensions, cellSize))\n    }, [canvasDimensions])\n\n    // Redraw canvas cells every time array representing them are changed\n    useEffect(() => {\n        const canvas = document.getElementById('canvas');\n        const ctx = canvas.getContext('2d');\n        for (let row = 0; row < cells.length; row++) {\n            for (let col = 0; col < cells[row].length; col++) {\n                const cell = cells[row][col];\n                const colorDict = {\n                    \"wall\": '#444',\n                    \"path\": '#fff',\n                    \"node\": \"#0000ff\",\n                    \"searched\": \"#ff0000\",\n                    \"backtrack\": \"#ffff00\"\n                }\n                ctx.fillStyle = colorDict[cell];\n                ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);\n            }\n        }\n    }, [cells])\n\n    // Screen clicking functionality\n    const getMouseCellLocation = (e, cellSize) => {\n        // Needs canvas to subtract size of bounding box\n        const canvas = document.getElementById('canvas');\n        const canvasBoundingBox = canvas.getBoundingClientRect();\n        // Returns [row, col]\n        return [Math.floor((e.clientY - canvasBoundingBox.y) / cellSize), Math.floor((e.clientX - canvasBoundingBox.x + .5) / cellSize)]\n    }\n\n    // Mousedown starts you drawing\n    const [ isDrawing, setIsDrawing ] = useState(false)\n    // Moving sets all interim points to the opposite of whatever the original cell was\n    const [ fillType, setFillType ] = useState(null)\n    // Saving previous point allows us to catch all points dragged over (as browser event has fairly slow fire rate)\n    const [ previousPoint, setPreviousPoint ] = useState([null, null])\n\n    // Clicking changes the color of that cell, clicking + holding has separate functionality\n    const handleMouseDown = (e) => {\n        const [row, col] = getMouseCellLocation(e, cellSize);\n        setPreviousPoint([row, col])\n        const newCells = [...cells];\n        // Fill type remains constant as the opposite of cell content before the click, so you can draw lines after click\n        const flippedCellContent = (newCells[row][col] === \"wall\") ? \"path\" : \"wall\"\n        setFillType(flippedCellContent)\n        newCells[row][col] = flippedCellContent;\n        setCells(newCells)\n        setIsDrawing(true)\n    }\n\n    // Unclicking and moving out of frame/canvas releases mouse being held\n    const handleMouseOutUp = () => {\n        setIsDrawing(false)\n        setPreviousPoint([null, null])\n    }\n\n    // Moving while mouse being held draws manhattan lines on the canvas\n    const handleMouseMove = (e) => {\n        const [row, col] = getMouseCellLocation(e, cellSize);\n        const isPreviousPoint = (row === previousPoint[0] && col === previousPoint[1])\n        if (isDrawing && !isPreviousPoint) {\n            const newCells = [...cells];\n            // Find all cells in between two points by:\n            // Finding Manhattan distance values between the two points\n            const [rowDiff, colDiff] = [row - previousPoint[0], col - previousPoint[1]];\n            // Choosing which one is larger (in absolute terms)\n            const maxDiff = Math.max(Math.abs(rowDiff), Math.abs(colDiff));\n            // Cycling through all cells in between previousPoint and current one\n            // Add the smallest jump along the line between cells that will change value of one of the cells\n            for (let i = 0; i < maxDiff; i++) {\n                const [rowJump, colJump] = [rowDiff * ((i+1) / maxDiff), colDiff * ((i+1) / maxDiff)];\n                const [mRow, mCol] = [Math.floor(previousPoint[0] + rowJump), Math.floor(previousPoint[1] + colJump)];\n                newCells[mRow][mCol] = fillType;\n\n            }\n            setCells(newCells)\n            setPreviousPoint([row, col])\n        }\n    }\n\n    const handleGenerateMaze = () => {\n        // Fill in cells for use by algorithm, default is walls\n        const fillGrid = getFullCanvas(canvasDimensions, cellSize)\n        setCells(fillGrid)\n        const [ mazeGrid, {mazeAnimations, nodeAnimations}, ] = generateMaze(fillGrid, mazeGenAlgo)\n        // Store maze for use in reset\n        setStoredMaze(mazeGrid)\n        setAnimations({\n            ...animations,\n            mazeAnimations,\n            nodeAnimations,\n        })\n        // Add to stack and play animations\n        setAnimationStack([...animationStack, ...mazeAnimations])\n        setPlayingAnimations(true)\n    }\n\n    const handleSolveMaze = () => {\n        // Uses a set of default entry, exit, start points; these are adjustable but currently not part of state\n        const defaults = { enter: [0, 1], exit: [cells.length - 1, cells[0].length - 2], start: [1, 1] };\n\n        // // Reset cells to those stored in maze cells, in case a solution already in place\n        setCells(storedMaze)\n        const {solvingAnimations, backtrackingAnimations} = solveMaze(cells, defaults, mazeSolveAlgo)\n        setAnimations({\n            ...animations,\n            solvingAnimations,\n            backtrackingAnimations\n        })\n        // Add to stack and play animations\n        setAnimationStack([...animationStack, ...solvingAnimations, ...backtrackingAnimations])\n        setPlayingAnimations(true)\n    }\n\n\n    // Custom hook for animations - can control speed, choose type, control playback\n    useInterval(() => {     \n        const newCells = [...cells];\n        const remainingStack = [...animationStack]\n        const noOfUpdates = animationSpeed;\n        for (let i = 0; i < noOfUpdates; i++) {\n            if (remainingStack.length) {\n                const animation = remainingStack.shift();\n                const [row, col] = animation.location;\n                newCells[row][col] = animation.type;\n            } else {\n                setPlayingAnimations(false)\n            }\n        }\n        setAnimationStack(remainingStack)\n        setCells(newCells)\n    }, playingAnimations ? 5 : null);\n\n    // Control functionality\n    const handleClearCanvas = () => {\n        setCells(getClearCanvas(canvasDimensions, cellSize));\n    }\n\n    const handleFillCanvas = () => {\n        setCells(getFullCanvas(canvasDimensions, cellSize));\n    }\n\n    const playAnimations = (animationType) => {\n        setPlayingAnimations(true);\n    }\n\n    const pauseAnimations = () => {\n        setPlayingAnimations(false);\n    }\n\n    const resetSolvingAnimations = () => {\n        handleFillCanvas()\n        setCells(storedMaze);\n    }\n\n    const replayAnimations = () => {\n        resetSolvingAnimations()\n        playAnimations()\n    }\n\n    return (\n        <div>\n\n            <Slider \n                value={animationSpeed}\n                setValue={setAnimationSpeed}\n            />\n\n            <div style={{ width: canvasDimensions.width, height: canvasDimensions.height }}>\n                <canvas \n                    id=\"canvas\"\n                    \n                    width={canvasDimensions.width}\n                    height={canvasDimensions.height}\n                    \n                    onMouseDown={(e) => handleMouseDown(e)} \n                    onMouseUp={() => handleMouseOutUp()} \n                    onMouseOut={() => handleMouseOutUp()} \n                    onMouseMove={(e) => handleMouseMove(e)}\n                />\n            </div>\n            <div>\n                <div className=\"input-group justify-content-center\" >\n                    <DropdownMenu\n                        type={\"Maze Generation\"}\n                        select={setMazeGenAlgo}\n                        title={mazeGenAlgo}\n                        algorithms={[\"Eller's Algorithm\", \"Recursive Backtracking\"]}\n                    />\n                    <DropdownMenu\n                        type={\"Maze Solving\"}\n                        select={setMazeSolveAlgo}\n                        title={mazeSolveAlgo}\n                        algorithms={[\"Depth-First Search\", \"Breadth-First Search\", \"Djikstra's Algorithm\", \"A* Search Algorithm\"]}\n                    />\n                </div>\n                <ControlButtons\n                    size = {\"sm\"}\n                    buttons={[\n                        { \"function\": handleClearCanvas, text: \"Clear\", disabled: false },\n                        { \"function\": handleFillCanvas, text: \"Fill\", disabled: false },\n                        { \"function\": handleGenerateMaze, text: \"Generate Maze\", disabled: (mazeGenAlgo === \"default\") },\n                        { \"function\": handleSolveMaze, text: \"Solve Maze\", disabled: (mazeSolveAlgo === 'default') },\n                    ]}\n                />\n                <ControlButtons\n                    size = {\"sm\"}\n                    buttons={[\n                        { \"function\": playAnimations, text: \"Play\", disabled: (mazeGenAlgo === \"default\") },\n                        { \"function\": pauseAnimations, text: \"Pause\", disabled: (mazeGenAlgo === \"default\") },\n                        { \"function\": resetSolvingAnimations, text: \"Reset\", disabled: (mazeGenAlgo === \"default\") },\n                        { \"function\": replayAnimations, text: \"Replay\", disabled: (mazeGenAlgo === \"default\") },\n                    ]}\n                />\n            </div>\n        </div>\n    )\n}\n\nexport default Pathfinding;\n\n","import React, { useEffect, useRef } from 'react';\n\nexport const useInterval = (callback, delay) => {\n    const savedCallback = useRef();\n\n    useEffect(() => {\n        savedCallback.current = callback;\n    }, [callback])\n\n    useEffect(() => {\n        const tick = () => {\n            savedCallback.current()\n        }\n        if (delay !== null) {\n            let id = setInterval(tick, delay)\n            return () => clearInterval(id)\n        }\n    }, [delay])\n}\n","import React from 'react';\nimport { BrowserRouter as Router, Route, Switch, Redirect } from 'react-router-dom';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport './app.css';\n\nimport Navbar from './Components/MainNavbar';\n\nimport MainPage from './Components/MainPage';\nimport Sorting from './Components/Sorting';\nimport Pathfinding from './Components/Pathfinding'\n\nconst App = () => {\n\n    return (\n        <div className=\"page\">\n            <Router>\n                <Navbar/>\n\n                <Switch>\n                    <Redirect from= \"/\" to=\"/main\" />\n                    <Route path=\"/main\" component={MainPage} />\n                    <Route path=\"/sorting\" component={Sorting} />\n                    <Route path=\"/pathfinding\" component={Pathfinding} />\n                </Switch>\n            </Router>\n        </div>\n    )\n};\n\nexport default App;\n\n// Still left to do:\n// Bugs: \n//      Play button needs to do something\n//      Sorting bug: why animations tarts early\n//      Get maze building working with no maze\n//      What happens if no solution to maze?\n//      Changing solving algorithm should reset to just maze w/ no solutions\n//      Reset/replay only works on the first go round, then seems to be resetting  to the solved maze\n//      Fix all console warnings on all pages\n//      Github deploy not working with router\n\n// explanations, for\n//      Games Readme\n//      Games How to play\n//      Sorting Algorithms\n//      Sorting Complexity\n//      Pathfinding algorithms\n//      Games Title\n\n// Nice but not necessary:\n//      Sorting slider for bars\n//      Build a dynamic slider for maze cell size\n//      Refactor sorting algorithm state to be a single state value\n//      Sorting animations play automatically?\n//      Go through and comment/possibly refactor algorithms\n//      Alt-text on buttons?\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n    <App/>, document.getElementById('root')\n);\n\n"],"sourceRoot":""}